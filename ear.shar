echo x - README
cat >README <<'!Funky!Stuff!'
			Lyon's Cochlear Model
			By Malcolm Slaney
			Apple Technical Report #13
			(c) November 1988
			Apple Computer, Inc.
			malcolm@apple.com

About this disk
	This disk contains the electronic version of Apple Technical Report 
	#13 which describes the implementation of Richard Lyon's model of the 
	cochlea (the inner ear.)   This disk includes the following 
	information.
		1)	This README file
		2)	Lyon's Cochlear Model (The Mathematica Notebook)
		3)	C and Fortran source code to implement the model 
			with real data (with manual page)
		4)	A Mathematica notebook reader
		5)	A introduction to Mathematica notebooks (Called 
			"Read This First."

How to use this floppy
	The most interesting file on this disk is a Mathematica
	notebook describing Richard Lyon's Cochlear Model.  This is a real 
	live electronic document which can be read and modified by the 
	Mathematica program.  We hope that most people will be able to 
	acquire a copy of Mathematica and interact with the notebook.  This
	is the best way to understand the material.

How to run Mathematica
	Mathematica runs on a number of different computers.  Some machines
	(for example Macintoshes and NeXT) support the concept of a notebook.  
	A notebook is a combination of words and equations that can be read 
	like a normal paper.  In addition the notebook allows the user to 
	interact with the equations and replot the figures (perhaps with new 
	parameters).

	The notebook reader provided with this technical report is a stripped
	down version of the normal Mathematica front end.  This reader will
	allow you to look at the notebook on a Macintosh but not to change 
	any of the parameters or otherwise do any mathematics.  If you want to 
	interact with the notebook you will need to aquire a copy of 
	Mathematica for your favorite machine.  You can purchase a copy of 
	Mathematica from either Wolfram Research (217 398-0700) or from an 
	Apple software dealer.  See the "Read This First" Mathematica notebook 
	for more details.

	You can interact with the notebook using Mathematica on other machines
	but the front end isn't quite as snazzy.  Equations in the model can
	be changed but you will not be able to browse through the document 
	electronically.  If you transfer the data fork of the notebook to a
	different machine the resulting file is a bunch of Mathematica commands
	which can be read in with the "<<" command.

About the source code
	This disk also includes the complete source code to implement the
	cochlear model.  This code has been tested on the following machines
	and environments:
		1)	Cray XMP 4/8 under Unicos 3.0 and 4.0 (48us per loop)
			The all C version runs slower (2ms per loop)
		2)	Sun 3/260 under Sun Unix 4.0 (37ms per loop with 68881)
		3)	Apple Macitosh under MPW 3.0 (60ms per loop)
	The program is written entirely in C but most of the kernel is also
	written in Fortran so that the Cray can vectorize the code.  Makefiles
	are provided for each of these environments.  Please contact the 
	author if you would like this information in some other electronic
	form than a Macintosh floppy. 

	Note the times shown in paranthesis above are the time it takes that 
	machine to execute one iteration through the cochlear loop.  This
	loop implements the filtering, detection and AGC and is executed once
	for every sample.  Any time faster than 64us is better than real time
	for a speech signal digitized at 16khz.

How to unpack this disk
	The files on this floppy are archived and compressed using a utility
	called StuffIt.  To unpack these files just double click on the icons
	and click on the extract button.  The Mathematica related files (the
	MathReader, the introductory notebook "Read This First" and Lyon's
	Cochlear Model) are in an archive called Mathmatica.sit.  The source 
	code, manual pages and documentation for the program are in another
	archive called code.sit.

	Contact the author if you would like this information in some other
	format other than on a Macintosh floppy.


If you have questions
	If you have any questions the author can be reached at the following
	addresses.  
			Malcolm Slaney
			Apple Computer
			20525 Mariani Avenue
			Cupertino, CA 95014
			(408) 974-4535
			malcolm@apple.com       <=====  Best Way
!Funky!Stuff!
echo x - README.v2
cat >README.v2 <<'!Funky!Stuff!'
			Release Notes for
			Version 2 of
			Lyon's Cochlear Model
			August 11, 1989

This note describes the latest implementation of Lyon's Cochlear
Model.  More information about this code can be found in the following
publication:

	Malcolm Slaney,  "Lyon's Cochlear Model," Apple Technical 
	Report #13, November 1988.

This report is available from the Apple Corporate Library.  This
release of the ear code also supports a model of pitch perception
called the correlagram.  This model is documented in the following
publications:
	Lyon, Richard F., "A computational model of  filtering, 
	detection and compression in the cochlea," in Proceedings 
	of the IEEE International Conference Acoustics, Speech and 
	Signal Processing, Paris, France, May 1982.

	Licklider, J. C. R., "A Duplex Theory of Pitch Perception," 
	in Psychological Acoustics, E. D. Schubert, ed., Dowden, 
	Hutchingson and Ross,  Inc., Stroudsburg, PA, 1979.

The following statement applies to the software enclosed here:

	Even though Apple has reviewed this software, Apple makes 
	no warranty or representation, either express or implied, 
	with respect to this software, its quality, accuracy, 
	merchantability, or fitness for a particular purpose.  
	As a result, this software is provided "as is," and you, 
	its user, are assuming the entire risk as to its quality and
	accuracy.

	Copyright (c) 1988-1989 by Apple Computer, Inc.

You are free to use this program in your own research but we do ask if
you publish any results based on this code that you give Apple Computer
appropriate credit.

The enclosed floppy contains the source code in C for an implementation
of Lyon's cochlear model.  This code has been tested and runs correctly
on the following machines: Cray, Stellar, SGI, Sun-3, Sun-4, VAX,
Sequent Balance and Macintosh (both LightSpeed C and MPW).  This
release is especially interesting since it includes a standard
double-clickable Macintosh application that can be run on any Macintosh
II.  (It is possible to change the makefiles and compile this code to
run it on machines without a MC68881 but the resulting program would
not run very fast.)

This program takes as input a sound file (in a number of different file
formats) and produces either a cochleagram or a correlagram.  A
cochleagram is a representation that roughly corresponds to spectral
energy as a function of time.  A correlagram is our implementation of
Licklider's duplex model of pitch perception.   A correlagram shows the
short time autocorrelation for each time slice of each cochlear
channel.  The result is a two dimensional movie.

This floppy also contains the latest copy of NCSA ImageTool.  The
National Center for Supercomputer Applications (NCSA) wrote ImageTool
to make it easier for researchers to display the results of
supercomputer applications on local workstations.  The version of NCSA
ImageTool supplied on the floppy is appropriate for a Macintosh.
Contact the NCSA at the University of Illinois in Champaign, IL if you
are interested in ImageTool on other platforms.

Configuration
Most of the parameters for this model are set on the command line
(Unix) or using a dialogue box (Macintosh).  These parameters are fully
described in the Unix manual page and allow you to change, for example,
the filter width and the correlation length.

One option that is not set from the command line is the type of file
output.  Depending on the software you are using to analyze the output
of the ear model you might want the output files to be binary floating
point, unsigned 8 bit bytes or readable ASCII text.  These options are
selected by choosing the appropriate definition in the ear.h include
file.  The Macintosh application (MacEar) on this floppy is configured
with the BYTEOUTPUT option so that all output files are 8 bit unsigned
bytes.  This is the type of output that NCSA ImageTool expects.  The
sources are distributed with the FLOATOUTPUT option already enabled.
This makes it easier to test the output and verify that the compiler
and the code  are working as advertised.

Custom output types are also possible.  Look for the preprocessor
symbol "OGC" for an example of how to add your favorite file format.

Correlagram Parameters
When computing correlagrams we have decided that the following
parameters yield more pleasing results then the defaults.  Note that
these values will probably change as we get more experience with this
model.  Contact the author for the latest parameters.

taufactor=1 - This parameter gives the location of a first order low
pass filter that is used to prevent aliasing in the correlagram.  The
standard value is three.

df=1 - This sets the decimation factor to one so that each output
sample from the cochleagram is passed to the correlation algorithms.

clag=512 - This is the number of lags to compute in the correlation.
This implementation of the correlagram is implemented with FFTs and a
Hamming window is used to reduce the edge effects.  Only half of the
autocorrelation output is shown because of the additional error
introduced by the window at the end of the correlation.

normalize=.5 - The correlagram output is normalized by dividing each
value by the largest value in the correlagram raised to this power.
This provides a bit of compression.

earq=4 - The sharpness of the earfilters is changed from 8 to 4 thus
making the filters wider.  We think this agrees with the physics of the
ear.  The sharp tuning curves measured by most researchers is probably
due to the Automatic Gain Control.

stepfactor=.125 - When the earq is changed it is also necessary to
change the stepfactor so that the number of filters per band remains
approximately constant.

Using the Macintosh Implementation
The best way to compute a correlagram is to first create an empty
folder to contain the output files.  Using the "Correlation Output
File" entry in the main dialogue box the name of this empty folder and
a small file prefix should be entered.  The resulting correlagram data
will be written, one time slice per file, into files that are named by
combining the file prefix with the numerical sample number and the file
size.   This directory can then be specified in the Animate option of
NCSA ImageTool to see the resulting correlagram.  If you recompile this
application on the Macintosh you will need to make sure that the
BYTEOUTPUT option is selected in the ear.h include file.

When this application is run on a Macintosh (double click on the MacEar
file) a dialogue box is put on the screen and the user can specify the
following parameters

Input File Name - The name of the file containing the input data in one
of the following formats: ADC, WAV (raw bytes at 16 khz), floating
point numbers (at 16 khz sampling interval) or Macintosh SoundEdit
files (the file suffix, m7, m11 or m22 specifies the sampling interval
in khz.)  The default name for the input file is data.adc.

Output File Name - The resulting cochleagram is written into this file
as a two dimensional array of floating point numbers.  For each output
time slice all channels are written with the highest frequency channel
(closest to the base) written first.

Correlagram Output File - If a file name is specified then a
correlagram is computed.  The resulting correlations are stored in
files named by the file name concatenated with the input sample
number.  Since a large number of output files are computed it is best
if the file name prefix is in an otherwise empty folder.  The files are
stored as an array of bytes and the image size is included in the file
name as needed by ImageTool.

The other parameters in the dialogue box are described in the Unix
manual page for this software.

You can create input files for this code in a couple of different
ways.  If you have access to the Macintosh programs MacRecorder and
SoundEdit (from Farallon) then you can create sound files with
SoundEdit and process them with MacEar.  MacEar does not understand
file types you must use the proper file suffix (m7, m11, m22 depending
on sampling rate) to tell MacEar which file format you are using.
Alternatively you can use your favorite programming language to create
an ADC file.  Please note that the description of the ADC format
published with Apple Technical Report #13 was wrong.  A corrected
version of the manual page is included.

Timing

The following table should give you a rough estimate of the speed of
this code on various architectures.  The numbers on the SGI, Stellar
and Sequent machines represent the speed of the unoptimized program and
should be considered a worst case.  Using the parallel pipelines and
multiple processors on these machines should allow even greater speeds.
These optimizations have already been done for the Cray.

This table shows the amount of time it will take to compute a
cochleagram and correlagram for one second of speech input.  Note that
the total run time of this program when computing a correlagram will be
the cochleagram time plus the correlagram time.  This table assumes a
16 khz sampling interval and computing a correlagram 62.5 times a
second.

Machine Cochleagram     Correlagram     Notes
Cray XMP 4/8            1s              1.2s
SGI             	29s             116s    Unoptimized
Stellar         	147s            531s    Unoptimized
Sun-4           	147s            612s
VAX 11/8600             147s            687s
NeXT            	280s            1244s
Sequent Balance (1uP)   326s            1375s   Compiled with -f1167
Sun 3-160               584s            3125s   Compiled with -ffpa
Sequent Balance (1uP)   601s            2625s   80387 floating point
MacII (MPW)             968s            4731s
MacII (LightSpeed)      1187s           4768s

Note, that the correlagram code runs on all four processors of our
Cray.  If you want to compare your favorite machine to a Cray then the
ratios you compute using the correlagram times will be four times
higher than if you use the cochleagram times.

Testing
This program has been tested on a number of different machines and it
is believed to be portable.  But with changing software and new
machines it is hard to be guarantee perfect results.  The following
table lists the first 40 output values in one of the correlagram output
files.  If you get these values on your machine you can be pretty sure
that you have a working program.  (For example some of the early Sun-4
C compilers do not compile the complex number part of this program
correctly.)

These values correspond to the first 40 values of the correlagram at
sample number 256.  The correlagram was computed with an impulse input
and a decimation factor of 1.  All other parameters were left as the
default values.  See the installation instructions for your machine for
more details.
	0.195377        0.189904        0.177765        0.159345
	0.139094        0.119075        0.100709        0.0846115
	0.0706457       0.0588005       0.0486537       0.0401317
	0.0329156       0.0269265       0.0219505       0.0178976
	0.0146134       0.0119977       0.00992131      0.00829443
	0.00700704      0.00599529      0.00517166      0.00450445
	0.00393385      0.00345277      0.0030259       0.00265654
	0.0023235       0.00203234      0.00176916      0.00153883
	0.00133157      0.00115085      0.000989414     0.000849415
	0.000725371     0.000618426     0.000524416     0.000443835

Unix Installation
To install this program on a Unix machine do the following.

1)      Copy all of the source files into a directory.  You might want
to use a program like NCSA Telnet (and the builtin FTP program) to
transfer the files from the Macintosh to your Unix machine.  Or contact
the author to get the sources via FTP over the Internet or on tape.

2)      Type the command        make -f Makefile.unix depend

3)      Type the command        make -f Makefile.unix ear

4)      Type the command        mkdir tmp

5)      Run the command         ear +i df=1 cf=tmp/f

6)      Verify the output with  od -f "tmp/f00256(256x84)"

Note that not all machines support the "-f" (floating point) option.
This is especially true of System V machines.  In these cases edit the
file ear.h and specify the TEXTOUTPUT option.  (See the comments in
this include file for more details.)  You can then remake the program
and now the file "tmp/f00256(256x84)" is a text file.

Cray Installation
To install this program on a Cray supercomputer running Unicos 5.0 or
higher do the following.

1)      Copy all of the source files into a directory.  You might want
to use a program like NCSA Telnet (and the builtin FTP program) to
transfer the files from the Macintosh to your Cray.  Or contact the
author to get the sources via FTP over the Internet or on tape.

2)      Type the command        make depend

3)      Type the command        make fear

4)      Type the command        mkdir tmp

5)      Run the command         fear +i df=1 cf=tmp/f

6)      Verify the output with  od -f "tmp/f00256(256x84)"

Macintosh Installation
The enclosed floppy contains a ready to run application that computes
cochleagrams and correlagrams.  To see the output do the following.

0)      So that the software can fit onto one floppy it is distributed
as two StuffIt archives.  The first archive contains the ear model
source and MacEar application.  The second archive contains the NCSA
Image Application.   You should copy these archives onto your hard disk
and then double click on them.  They will automatically be expanded
into the files.

1)      Create an empty folder and name it correlation

2)      Double click on the MacEar application.  A large dialogue box
will appear.

3)      Click on the button next to "Correlation Output File" a
standard file dialogue box will appear.  This button is labeled SET and
is shown in the screen dump after these installation directions.

4)      Open the correlation folder that was created in step one.

5)      Type the file name f and then click the save button.

6)      Click on the radio button next to "Turn on Impulse Input."

7)      Change the decimation factor from 20 to 1.   When this change
is made the box at the beginning of the line will be checked to
indicate the parameter change.

8)      Click the OK button at the bottom of the dialogue box and a
large window will be placed on the screen showing all the parameters of
the ear model.  The calculations of the correlagram will finish in
about 4 minutes (on a Mac-II) and will create four files.  One is
called cochlea.pic (the default cochleagram output file) and the three
correlagrams files are in the folder created in step 4.

9)      Choose the quit option from the file menu.

10)     Now double click on the NCSA ImageTool icon.

11)     Select the Color Table and then the Lightness entry in the
Palettes menu to set the palette to gray.

12)     Now use the "Open..." option in the File menu and select the
"cochlea.pic" in the original ear folder.

13)     The size of the image is x=84 by y=512.  The image will be
oriented as shown below.  This is a cochleagram of an impulse.
		[Picture deleted in ASCII Version.]

	The picture below shows part of the cochleagram of a speech
	signal.  The signal used to generate this cochleagram is
	supplied on the floppy as data.adc (this is the name of the
	default input file for MacEar.)
		[Picture deleted in ASCII Version.]

14)     Now choose the "Animate -> From Memory" option from the File
menu.

15)     Select the correlation directory that was created in step 1
above.

16)     The sizes of the images are correctly listed in the file name
so ImageTool has the correct sizes.  Click on the OK button.

17)     Select the forward option from the animation menu to see the
correlagram animation.  The image is oriented as shown in the picture
below.  This is approximately what the last image of the correlagram of
the impulse should look like.
		[Picture deleted in ASCII Version.]

	The image below shows a time sample of a correlogram.  The dark
	horizontal bands indicate formants and the vertical lines show
	the pitch of the signal.
		[Picture deleted in ASCII Version.]

	Consult the NCSA Image documentation for other graphics and
	animation options.  For example you might want to change the
	scaling of the picture using the interpolate option under the
	tools menu.

Note that all the source files are supplied so that you can modify the
sources and create a new application.  This can be done using either
Symantec's LightSpeed C or Apple's MPW programming environment.  If you
recompile the sources on the Macintosh be sure to check that the output
type option is set correctly in the ear.h file.

Please note that the Macintosh version MacEar will not overwrite
existing files.  If you run the program once and a file is created it
will not be changed if you run the program again.  You must first drag
the file to the trash and empty it or choose a different file name.

Because of the computational requirements this is not a typical
Macintosh application.  This application can easily consume a large
fraction of the available CPU time.  This application relinquishes the
CPU periodically but probably not often enough for other applications
running in the background.Macintosh Dialog Box

		[Picture deleted from ASCII verion.]
The figure above shows the dialog box that is placed on the screen when
MacEar is launched.  The SET buttons along the top left allow the user
to change the input source and the cochleagram and correlagram output
files.  Clicking on one of these buttons brings up the normal Macintosh
file dialog.  The box on the right will show the selected file.  The
format of these files is described in the Unix manual page for the ear
program.

Below the file section are a pair of radio buttons that override the
input file and specify that an impulse should be used.  This is useful
for testing.

The rest of the dialog box is used to change te parameters of the ear
model.  The check box on the far left indicates that the parameter is
changed from the default.  The values on the right can be edited like
any other Macintosh text field.  The meaning of these parameters is
described in the Unix manual page and in the technical report.

Acknowledgements

I would like to thank Steve Rubin (at Apple) for writing and
maintaining the module that creates a Macintosh dialogue box from a
Unix style command line.  I also want to thank Richard Duda (at San
Jose State) and Ron Cole (at the Oregon Graduate Center) for helping me
test early releases of this code.  Thanks to Dave Mellinger (at Stanford
CCRMA) for the Dyaxis and NeXT support.

For more information
For more information please contact the author at
	Malcolm Slaney
	Speech and Hearing Project
	Advanced Technology Group
	Apple Computer
	20525 Mariani Avenue
	Cupertino, CA 95014
	(408) 974-4535
	malcolm@apple.com
!Funky!Stuff!
echo x - UNIX.c
cat >UNIX.c <<'!Funky!Stuff!'
/*
 * This is a Macintosh-to-UNIX interface module.  It does the following:
 * (1) runs a dialog to obtain the command-line arguments to the UNIX program
 * (2) invokes the UNIX program (must change "main" to "UNIX_main")
 * (3) displays a scrolling text window for terminal I/O and supports:
 *     printf
 *     getchar
 *     putchar
 *     exit
 *
 * Written by: Steven M. Rubin, Apple Computer, 1989.
 * Compiles in either LightspeedC or MPW
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1991 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: UNIX.c,v 2.4 91/01/23 11:23:50 malcolm Exp $
 *
 * $Log:	UNIX.c,v $
 * Revision 2.4  91/01/23  11:23:50  malcolm
 * Changed initial parameter dialog so strings are shorter (and window isn't
 * as wide).  Also, changed the pixels per parameter line from 25 to 21.  Both
 * of these were done so that the dialog would fit on the screen on Macs with
 * small screens.  Also changed some indentations in the source and made a
 * few attempts to get the highlights to be drawn correctly when the program
 * starts up (Things like the highlighting of the run button and the boxes
 * around the radio boxes aren't drawn now until some other even causes 
 * ModalDialog to return and force an update.)
 * 
 * Revision 2.3  90/12/18  09:45:22  malcolm
 * Added support for Roy Patterson's Model.
 * 
 * Revision 2.1  90/11/06  20:41:50  malcolm
 * Miscellaneous Fixes
 * 
 * 
 * Revision 2.0.1.1  89/07/28  21:38:57  malcolm
 * Added taufactor parameter to the command line interface.  Also changed
 * dialog text boxes so that they would automatically check their check-box
 * if their parameters changed.
 * 
 * Revision 2.0  89/07/25  18:56:16  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.2  89/07/21  14:37:06  malcolm
 * Changed calls to printf to rubin_printf so that LightSpeed C won't have
 * to put up a console window.
 * 
 * Revision 1.1  89/07/19  12:31:54  malcolm
 * Initial revision
 * 
 *
 * The dialog which obtains the command-line arguments is specified by an array of
 * strings called "parselist", declared below.  The format is as follows:
 *   parselist  := PARAMETERS
 *   PARAMETERS := PARAMETER
 *   PARAMETERS := PARAMETER  PARAMETERS
 *   PARAMETER  := "[" CHOICES "]"
 *   PARAMETER  := "(" CHOICES ")"
 *   PARAMETER  := "INPUTFILE"  [ ":" MACNAME ]
 *   PARAMETER  := "OUTPUTFILE" [ ":" MACNAME ]
 *   CHOICES    := CHOICE
 *   CHOICES    := CHOICE "|" CHOICES
 *   CHOICE     := 'string'     [ ":" MACNAME ]  [ "ON" ]
 *   CHOICE     := 'string'     [ ":" MACNAME ]  [ [ "=" ]  "INPUTFILE" ]
 *   CHOICE     := 'string'     [ ":" MACNAME ]  [ [ "=" ]  "OUTPUTFILE" ]
 *   CHOICE     := 'string1'    [ ":" MACNAME ]  [ [ "=" ]  'string2' ]
 *
 * Less formally, the strings describe a set of parameters to the UNIX program.
 * The parameters may be constant strings, choices from a list, input or output
 * file names.  Optional parameters are surrounded by square brackets.  Here are
 * some examples:
 * (1) The first parameter to a UNIX program is typically the program name.  Here,
 *     a constant string is specified with a quoted parameter (always use single
 *     quotes) and is optionally followed by a colon and another quoted string that
 *     will be displayed in the dialog.  For example, the UNIX program "test"
 *     might begin with:
 *         'test' : 'My test program'
 * (2) A required input file is described with the keyword INPUTFILE, followed by
 *     the optional Macintosh prompt.  For example:
 *         INPUTFILE : 'Input to the program'
 * (3) An optional output file is described with the keyword OUTPUTFILE, and all
 *     surrounded in square brackets:
 *         [OUTPUTFILE : 'Output (default is standard output)']
 * (4) A list of possible keywords is separated with "|" bars, and enclosed in
 *     parenthesis or, if they are optional, enclosed in square brackets.  For
 *     example, if the test program can do one-column or two-column output with
 *     the "-o" and "-t" switches, you might include the following string:
 *         ( '-o' : 'One column output' | '-t' : 'Two column output' )
 * (5) An option may be parameterized if it appears in a required or in an optional
 *     list.  Simply add an additional keyword after the parameter declaration.
 *     For example, the UNIX option "-t FONT" would be described with:
 *         [ '-t' : 'Optional font' 'Font Name' ]
 *     and, if there is no space between the switch and its argument (i.e. if
 *     the UNIX option is "-tFONT", use an "=" before the parameter keyword:
 *         [ '-t' : 'Optional font' = 'Font Name' ]
 * (6) An option may also take an input or output file name.  The UNIX parameter
 *     "-oFILENAME" would be described with:
 *         [ '-o' : 'Output File' = OUTPUTFILE ]
 * (7) An option may be checked by default.  The UNIX parameter
 *     "-warn" will be generated UNLESS it is checked with:
 *         [ '-warn' : 'Print warnings' ON ]
 */


/******************* CHANGE THIS DECLARATION TO FIT YOUR PROGRAM *******************/
char *steves_parselist[] =
{
    "'ear'       : 'The Lyon Cochlear Model 2.2'",
    "INPUTFILE    : 'Filename to be compiled'",
    "('QUISC':'Compile' | 'QUAIL':'Simulate' | 'NETLISP':'Make netlist' |",
    " 'RSIM':'RSIM simulation' | 'NOTARGET':'Ignore')",
    "['/extern'   : 'Assume undefined entities are external' ON]",
    "['/nowarn'   : 'Supress warning messages']",
    "['/lib='     : 'File of QUAIL gates' = INPUTFILE]",
    "['/outfile=' : 'Output file'         = OUTPUTFILE]",
    0
};

char	*parselist[] =
{
	"'ear'     : 'Lyons Cochlear Model 2.2'",
	"['if='     : 'Input File' = INPUTFILE ]",
	"['of='     : 'Output File' = OUTPUTFILE ]",
	"['cf='     : 'Correlation Output File' = OUTPUTFILE ]",
	"('-i'     : 'Turn off Impulse Input' |",
	" '+i'     : 'Turn on Impulse Input' )",
	"('cor=lick'     : 'Licklider Correlogram' |",
	" 'cor=pat'     : 'Patterson Correlogram' )",
/*	"('+a'     : 'Turn on AGC' |",
	" '-a'     : 'Turn off AGC' )",
	"('+c'     : 'Turn on Cascade' |",
	" '-c'     : 'Turn off Cascade' )",
	"('+m'     : 'Turn on Subtraction between Channels' |",
	" '-m'     : 'Turn off Subtraction between Channels' )",		*/
	"['df='  : 'Filter Decimation Factor (df)' = '20']",
	"['taufactor='  : 'Decimation Low Pass Filter (taufactor)' = '3']",
	"['earq='  : 'Filter Width (earq)' = '8']",
	"['stepfactor='  : 'Channel Separation (stepfactor)' = '.25']",
/*	"['breakf='  : 'Bark Scale Break Frequency (breakf)' = '1000']",
	"['sharpness='  : 'Sharpness of zeros compared to poles (sharpness)' = '5']",
	"['offset='  : 'Zero Offset (offset)' = '1.5']",
	"['preemph='  : 'Preemphasis Corner Frequency (preemph)' = '300']",	*/
/*	"['tau1='  : 'AGC #1 Time Constant (tau1)' = '.640']",
	"['tau2='  : 'AGC #2 Time Constant (tau2)' = '.160']",
	"['tau3='  : 'AGC #3 Time Constant (tau3)' = '.080']",
	"['tau4='  : 'AGC #4 Time Constant (tau4)' = '.004']",
	"['target1='  : 'AGC #1 Target Value (target1)' = '.0032']",
	"['target2='  : 'AGC #2 Target Value (target2)' = '.0016']",
	"['target3='  : 'AGC #3 Target Value (target3)' = '.0008']",
	"['target4='  : 'AGC #4 Target Value (target4)' = '.0004']",		*/
	"['clag='  : 'Lags in Correlation (clag)' = '256']",
	"['cstep='  : 'Steps between Correlations (cstep)' = '128']",
/*	"['normalize='  : 'Correlation Normalization (normalize)' = '.75']",	*/
	0
};
/***********************************************************************************/


#ifdef THINK_C
#define	SCREENBITS screenBits
#define	THEPORT    thePort
#define	hfileInfo hFileInfo
#else
#include <Types.h>
#include <Quickdraw.h>
#include <ToolUtils.h>
#include <Fonts.h>
#include <Events.h>
#include <Windows.h>
#include <Dialogs.h>
#include <Menus.h>
#include <Desk.h>
#include <SegLoad.h>
#include <TextEdit.h>
#include <OSUtils.h>
#include <Packages.h>
#include <Memory.h>
#include <OSEvents.h>
#include <Files.h>
#include <Scrap.h>
#define	SCREENBITS qd.screenBits
#define	THEPORT    qd.thePort
#endif

/* definitions for the graphics */
#define	SFONT	   monaco
#define	MENUSIZE   19
#define	SBARWIDTH  15

/* menu and item definitions */
enum {aboutMeCommand = 1};
enum {quitCommand = 1};
enum {cutCommand = 1, copyCommand, pasteCommand};
MenuHandle gra_appleMenu, gra_fileMenu, gra_editMenu;
enum {appleMENU = 128, fileMENU, editMENU};

/* definitions for parsing command-line/dialog description */
#define	EOP       -1		/* end of parse */
#define	UNKNOWN    0		/* unrecognized */
#define	WORD       1		/* a keyword */
#define	SEP        2		/* space or tab */
#define	OPENPAR    3		/* ( */
#define	CLOSEPAR   4		/* ) */
#define	OPENBRAC   5		/* [ */
#define	CLOSEBRAC  6		/* ] */
#define	ORBAR      7		/* | */
#define	QUOTE      8		/* ' */
#define	COLON      9		/* : */
#define	EQUAL     10		/* = */

/* definitions for command-line dialog */
#define	CONCOMMENT    1		/* a "comment" for display only */
#define	CONRADIO      2		/* a radio button */
#define	CONCHECK      3		/* a check box */
#define	CONTYPE      07		/* all above types */
#define	CONGETPAR   010		/* set if it gets a parameter */
#define	CONGETPARI  020		/* set if it gets an input file parameter */
#define	CONGETPARO  040		/* set if it gets an output file parameter */
#define	CONGETNS   0100		/* set if no space before parameter */
#define	CONOPTION  0200		/* set if parameter is optional */

#define	ACTIONSIZE   21		/* height of each line in command-line dialog */
#define	ANSWERWIDTH 150		/* answer width for parameterized command-line entries */

typedef struct
{
    short         control;	/* the control type (see above list) */
    short         checkit;	/* nonzero to check this box by default */
    short         item;		/* actual item in dialog */
    short         teitem;	/* text edit item in dialog */
    char         *display;	/* string to display in dialog */
    char         *string;	/* string to send to UNIX program */
    char         *defaultinput;	/* default input for CONGETPAR */
    short         radiogroup;	/* for grouping radio buttons */
} PARSE;

WindowPtr     gra_textwindow;	/* the standard I/O text window */
DialogPtr     gra_controldialog;/* the controls dialog */
ControlHandle gra_vScroll;	/* vertical scroll control in status window */
TEHandle      gra_TEH;		/* text editing handle in status window */
Rect          gra_dialogrect;	/* rectangle of dialog box */
static short  gra_linesInFolder;/* lines in text folder */
static char **gra_parselist;	/* the list of commands being parsed */
static short  gra_parseline;	/* the line number being parsed */
static char  *gra_parsepos;	/* the position in the line being parsed */
static short  gra_actioncount;	/* number of actions */
static PARSE  gra_action[30];	/* dialogs for command-line */
static int    gra_argc;
static char  *gra_argv[30];

short bufsize = 0, buflen = 0;
Handle buffer;
#define	INCREMENT 256

/*
 * The real "main" program that initializes graphics, runs the command-line dialog,
 * and then calls "_main" as if it was in UNIX
 */
main()
{
    short i, chr, gra_nextevent();

    /* initialize the Macintosh */
#ifndef	THINK_C
    _DATAINIT();
#endif
    MaxApplZone();
    InitGraf(&THEPORT);
    InitFonts();
    FlushEvents(everyEvent, 0);
    InitWindows();
    InitMenus();
    TEInit();
    InitDialogs(0L);
    InitCursor();

    /* do the dialog to get command-line arguments */
    if (gra_getarguments(&gra_argc, gra_argv, parselist) != 0) ExitToShell();

    /* make a text window for interaction */
    gra_initgraphics(gra_action[0].display, gra_action[0].string);

    /* run the main program */
    for(i=0; i<gra_argc; i++) rubin_printf("%s ", gra_argv[i]);
    rubin_printf("\n");
    _main(gra_argc, gra_argv);
    rubin_printf("\n************ PROGRAM RETURNED ************\n");

    /* loop until user exits */
    for(;;) (void)gra_nextevent(&chr);
}

/*
 * Routine to create the scrolling text window for interaction
 */
gra_initgraphics(header, about)
char *header, *about;
{
    Rect r;
    char head[200];

    /* initialize menus */
    gra_appleMenu = NewMenu(appleMENU, "\p\024");
    strcpy(head, " About ");
    strcat(head, about);
    strcat(head, "...");
    head[0] = strlen(&head[1]);
    AppendMenu(gra_appleMenu, head);
    AppendMenu(gra_appleMenu, "\p-");
    AddResMenu(gra_appleMenu, 'DRVR');
    gra_fileMenu = NewMenu(fileMENU, "\pFile");
    gra_editMenu = NewMenu(editMENU, "\pEdit");
    InsertMenu(gra_appleMenu, 0);
    InsertMenu(gra_fileMenu, 0);
    InsertMenu(gra_editMenu, 0);
    DrawMenuBar();
    AppendMenu(gra_fileMenu, "\pQuit/Q");
    AppendMenu(gra_editMenu, "\pCut/X;Copy/C;Paste/V");

    /* create the scrolling status window */
    r.top = SCREENBITS.bounds.top + MENUSIZE*2;
    r.bottom = SCREENBITS.bounds.bottom;
    r.left = SCREENBITS.bounds.left;
    r.right = SCREENBITS.bounds.right;
    head[0] = strlen(header);
    strcpy(&head[1], header);
    gra_textwindow = NewWindow(0L, &r, head, 1, documentProc,
	(WindowPtr)(-1L), 1, 0L);
    SetPort(gra_textwindow);
    EraseRect(&gra_textwindow->portRect);
    DrawGrowIcon(gra_textwindow);
    TextFont(SFONT);
    TextSize(9);
    r = gra_textwindow->portRect;
    r.left = r.right-SBARWIDTH;
    r.right += 1;
    r.bottom -= 14;
    r.top -= 1;
    gra_vScroll = NewControl(gra_textwindow, &r, "\p", 1, 0, 0, 0, scrollBarProc,
	0L);
    r = gra_textwindow->portRect;
    r.right -= SBARWIDTH;
    InsetRect(&r, 4, 4);
    gra_TEH = TENew(&r, &r);
    gra_setview(gra_textwindow);
    TEActivate(gra_TEH);
    ShowControl(gra_vScroll);
}

DoMenu(menu)
long menu;
{
    char name[256];
    GrafPtr savePort;

    switch (HiWord(menu))
    {
	case appleMENU:
	    GetPort(&savePort);
	    if (LoWord(menu) == aboutMeCommand)
	    {
		strcpy(name, gra_action[0].display);
		strcat(name, ".  Macintosh implementation with Quick-shell, by Steven M. Rubin");
		MyAlert(name);
	    } else
	    {
		GetItem(gra_appleMenu, LoWord(menu), name);
		(void)OpenDeskAcc(name);
	    }
	    SetPort(savePort);
	    break;
	case fileMENU:
	    switch (LoWord(menu))
	    {
		case quitCommand: ExitToShell();
	    }
	    break;
	case editMENU:
	    switch (LoWord(menu))
	    {
		case cutCommand:
		    TECut(gra_TEH);
		    ZeroScrap();
		    TEToScrap();
		    break;
		case copyCommand:
		    TECopy(gra_TEH);
		    ZeroScrap();
		    TEToScrap();
		    break;
		case pasteCommand:
		    TEFromScrap();
		    TEPaste(gra_TEH);
		    break;
	    }
	    break;
    }
    HiliteMenu(0);
}

/****************** CODE TO CONTROL THE TEXT WINDOW DURING EXECUTION ******************/

/*
 * Routine to handle events in the text window.  Returns nonzero if a character
 * was read (and placed in "chr").
 */
short gra_nextevent(chr)
short *chr;
{
    EventRecord theEvent;
    short oak, cntlCode;
    long key;
    WindowPtr theWindow, win;
    Rect dragRect;
    pascal void ScrollProc();
    ControlHandle theControl;
    static int firstupdate = 1;

    HiliteMenu(0);
    SystemTask();	/* Handle desk accessories */
    TEIdle(gra_TEH);
    oak = GetNextEvent(everyEvent, &theEvent);
    if (oak != 0) switch (theEvent.what)
    {
	case mouseDown:
	    switch (FindWindow(theEvent.where, &theWindow))
	    {
		case inMenuBar:
		    DoMenu(MenuSelect(theEvent.where));
		    break;
		case inSysWindow:
		    SystemClick(&theEvent, theWindow);
		    break;
		case inContent:
		    if (theWindow != FrontWindow())
		    {
			SelectWindow(theWindow);
			break;
		    }
		    SetPort(theWindow);
		    if (theWindow == gra_textwindow)
		    {
			GlobalToLocal(&theEvent.where);
			cntlCode = FindControl(theEvent.where, theWindow,
			    &theControl);
			if (cntlCode == inThumb)
			{
			    TrackControl(theControl, theEvent.where, 0L);
			    gra_adjusttext();
			    break;
			}
			if (cntlCode == inUpButton || cntlCode == inDownButton ||
			    cntlCode == inPageUp || cntlCode == inPageDown)
			{
			    TrackControl(theControl, theEvent.where, (ProcPtr)&ScrollProc);
			    break;
			}
			TEClick(theEvent.where,
			    (theEvent.modifiers & shiftKey) != 0, gra_TEH);
		    }
		    break;
		case inDrag:
		    if (theWindow == gra_textwindow)
		    {
			SetPort(theWindow);
			dragRect = SCREENBITS.bounds;
			dragRect.top += MENUSIZE;
			DragWindow(theWindow, theEvent.where, &dragRect);
			InsetRect(&dragRect, 4, 4);
		    }
		    break;
		case inGrow:
		    if (theWindow == gra_textwindow)
			gra_MyGrowWindow(theWindow, theEvent.where);
		    break;
		case inGoAway:
		    if (theWindow == gra_textwindow)
		    {
			SetPort(theWindow);
			if (TrackGoAway(theWindow, theEvent.where) != 0)
			    ExitToShell();
		    }
		    break;
	    }
	    break;
	case keyDown: 
	case autoKey:
	    if ((theEvent.modifiers & cmdKey) != 0)
	    {
		key = MenuKey((char)(theEvent.message & charCodeMask));
		DoMenu(key);
		break;
	    }
	    *chr = theEvent.message & charCodeMask;
	    return(1);    
	case activateEvt:
	    if ((WindowPtr)theEvent.message == gra_textwindow)
	    {
		if (theEvent.modifiers&activeFlag) TEFromScrap(); else
		{
		    ZeroScrap();
		    TEToScrap();
		}
	    }
	    break;
	case updateEvt:
	    win = (WindowPtr)theEvent.message;
	    SetPort(win);
	    BeginUpdate(win);
	    if (win == gra_textwindow)
	    {
		if (firstupdate == 0)
		{
		    EraseRect(&win->portRect);
		    DrawControls(win);
		    DrawGrowIcon(win);
		    TEUpdate(&win->portRect, gra_TEH);
		}
		firstupdate = 0;
	    }
	    EndUpdate(win);
	    break;
    }
    return(0);
}

gra_setview(w)
WindowPtr w;
{
    (*gra_TEH)->viewRect = w->portRect;
    (*gra_TEH)->viewRect.right -= SBARWIDTH;
    (*gra_TEH)->viewRect.bottom -= SBARWIDTH;
    InsetRect(&(*gra_TEH)->viewRect, 4, 4);
    gra_linesInFolder = ((*gra_TEH)->viewRect.bottom - (*gra_TEH)->viewRect.top) /
	(*gra_TEH)->lineHeight;
    (*gra_TEH)->viewRect.bottom = (*gra_TEH)->viewRect.top + (*gra_TEH)->lineHeight *
	gra_linesInFolder;
    (*gra_TEH)->destRect.right = (*gra_TEH)->viewRect.right;
    TECalText(gra_TEH);
}

pascal void ScrollProc(theControl, theCode)
ControlHandle theControl;
short theCode;
{
    int pageSize, scrollAmt;

    if (theCode == 0) return;
    pageSize = ((*gra_TEH)->viewRect.bottom-(*gra_TEH)->viewRect.top) / 
	(*gra_TEH)->lineHeight - 1;
    switch (theCode)
    {
	case inUpButton:   scrollAmt = -1;          break;
	case inDownButton: scrollAmt = 1;           break;
	case inPageUp:     scrollAmt = -pageSize;   break;
	case inPageDown:   scrollAmt = pageSize;    break;
    }
    SetCtlValue(theControl, GetCtlValue(theControl)+scrollAmt);
    gra_adjusttext();
}

gra_adjusttext()
{
    int	oldScroll, newScroll, delta;

    oldScroll = (*gra_TEH)->viewRect.top - (*gra_TEH)->destRect.top;
    newScroll = GetCtlValue(gra_vScroll) * (*gra_TEH)->lineHeight;
    delta = oldScroll - newScroll;
    if (delta != 0)
	TEScroll(0, delta, gra_TEH);
}

gra_SetVScroll()
{
    int n;

    n = (*gra_TEH)->nLines - gra_linesInFolder + 1;
    SetCtlMax(gra_vScroll, n > 0 ? n : 0);
}

gra_showselect()
{
    register int topLine, bottomLine, theLine;

    gra_SetVScroll();
    gra_adjusttext();

    topLine = GetCtlValue(gra_vScroll);
    bottomLine = topLine + gra_linesInFolder;

    if ((*gra_TEH)->selStart < (*gra_TEH)->lineStarts[topLine] ||
	    (*gra_TEH)->selStart >= (*gra_TEH)->lineStarts[bottomLine])
    {
	for (theLine = 0; ; theLine++)
	    if ((*gra_TEH)->selStart <= (*gra_TEH)->lineStarts[theLine]) break;
	SetCtlValue(gra_vScroll, theLine - gra_linesInFolder / 2);
	gra_adjusttext();
    }
}

gra_MyGrowWindow(w, p)
WindowPtr w;
Point p;
{
    long theResult;
    short oScroll;
    Rect r, oView;

    SetPort(w);
    SetRect(&r, 80, 80, SCREENBITS.bounds.right, SCREENBITS.bounds.bottom);
    theResult = GrowWindow(w, p, &r);
    if (theResult == 0) return;
    SizeWindow(w, LoWord(theResult), HiWord(theResult), 1);

    InvalRect(&w->portRect);
    oView = (*gra_TEH)->viewRect;
    oScroll = GetCtlValue(gra_vScroll);

    gra_setview(w);
    HidePen();
    MoveControl(gra_vScroll, w->portRect.right - SBARWIDTH, w->portRect.top-1);
    SizeControl(gra_vScroll, SBARWIDTH+1,
	w->portRect.bottom - w->portRect.top-(SBARWIDTH-2));
    ShowPen();

    gra_SetVScroll();
    gra_adjusttext();
}

/****************************** UNIX-LIKE I/O ******************************/

#ifndef	THINK_C

putchar(cmd)
short cmd;
{
    TEKey(cmd, gra_TEH);
    TESetSelect(32767, 32767, gra_TEH);
    gra_showselect();
}

#endif

rubin_printf(s, p1, p2, p3, p4, p5, p6, p7, p8, p9)
char *s, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9;
{
    long len;
    short i;
    char tline[100];

    sprintf(tline, s, p1, p2, p3, p4, p5, p6, p7, p8, p9);
    len = strlen(tline);
#ifdef	THINK_C
    for(i=0; i<len; i++) if (tline[i] == '\n') tline[i] = '\r';
#else
    for(i=0; i<len; i++) if (tline[i] == '\r') tline[i] = '\n';
#endif
    TEInsert(tline, len, gra_TEH);
    len = 32767;
    TESetSelect(len, len, gra_TEH);
    gra_showselect();
}

#ifndef	THINK_C

getchar()
{
    short chr, gra_nextevent();

    for(;;) if (gra_nextevent(&chr) != 0) break;
    return(chr);
}

#endif	THINK_C

rubin_exit(val)
{
    short chr, gra_nextevent();

    printf("\n************ PROGRAM EXITED WITH CODE %d ************\n", val);
    for(;;) (void)gra_nextevent(&chr);
    exit();
}

/***************************** DIALOG FOR COMMAND-LINE *****************************/

/*
 * Routine to parse the structure in "parselist", run a dialog on it, and build a UNIX
 * command line in "argc" and "argv".  Returns nonzero to cancel the dialog
 */
gra_getarguments(argc, argv, parselist)
int *argc;
char *argv[], *parselist[];
{
    char temp[256];
    short i, j, k, len, w, bigw, descent, thistype, len1, itemHit, itemType;
    Rect itemRect;
    Handle itemHdl;
    static Point SFGwhere = {90, 82};
    static Point SFPwhere = {106, 104};
    SFReply reply;
    SFTypeList myTypes;
    char *gra_makefullname();
    FontInfo fontinfo;

    /* parse the argument list, quit if bad */
    gra_parsearguments(parselist);
    if (gra_actioncount < 0)
    {
		*argc = 0;
		return;
    }

    /* determine width of window */
/*  TextFont(courier);
    TextSize(10);		*/
    GetFontInfo(&fontinfo);
    descent = fontinfo.descent;
    bigw = 0;
    for(i=0; i<gra_actioncount; i++)
    {
		len = strlen(gra_action[i].display);
		w = TextWidth(gra_action[i].display, 0, len);
		if ((gra_action[i].control & CONGETPAR) != 0) w += ANSWERWIDTH;
		if ((gra_action[i].control & (CONGETPARI|CONGETPARO)) != 0)
		    w += StringWidth("\pSET") - 6;
		if (w > bigw) bigw = w;
    }
    gra_dialogrect.top = SCREENBITS.bounds.top + 3*MENUSIZE/2;
    gra_dialogrect.bottom = gra_dialogrect.top + (gra_actioncount+1) * ACTIONSIZE +
		ACTIONSIZE/2;
    gra_dialogrect.left = SCREENBITS.bounds.left + 30;
    gra_dialogrect.right = gra_dialogrect.left + 40 + bigw;

    TextFont(systemFont);
    TextSize(12);
    /* build an item list that describes the controls, then make the dialog */
    gra_makecontrols();
    gra_controldialog = NewDialog(0L, &gra_dialogrect, "\p", 1, dBoxProc,
		(WindowPtr)(-1L), 0, 0L, buffer);
    SetPort(gra_controldialog);
/*  TextFont(courier); */
    TextSize(10);	
    gra_setextrainfo();

    /* preset buttons and check boxes */
    for(i=0; i<gra_actioncount; i++)
    {
		thistype = gra_action[i].control & CONTYPE;
		if (thistype == CONCHECK && gra_action[i].checkit != 0)
		{
		    GetDItem(gra_controldialog, gra_action[i].item, &itemType, &itemHdl,
			&itemRect);
		    SetCtlValue((ControlHandle)itemHdl, 1);
		}
		if (thistype == CONRADIO)
		{
		    if (i != 0 && gra_action[i-1].radiogroup == gra_action[i].radiogroup)
			continue;
		    if ((gra_action[i].control&CONOPTION) != 0) continue;
		    GetDItem(gra_controldialog, gra_action[i].item, &itemType, &itemHdl,
			&itemRect);
		    SetCtlValue((ControlHandle)itemHdl, 1);
		}
    }
    DrawDialog(gra_controldialog);
    gra_setextrainfo();

    for(;;){
		ModalDialog(0L, &itemHit);
		if (itemHit == 2) break;
		if (itemHit == 1)
		{
		    /* ensure that all required parameters are given */
		    if (gra_gotitall() != 0) break;
		}
		for(i=0; i<gra_actioncount; i++)
		{
		    thistype = gra_action[i].control & CONTYPE;
		    if (thistype == CONCOMMENT) continue;
		    if (thistype == CONCHECK && itemHit == gra_action[i].teitem)
			  {
			    GetDItem(gra_controldialog, itemHit, &itemType, &itemHdl,
			      &itemRect);
			    GetIText(itemHdl, temp);
			    temp[temp[0]+1] = 0;
			    GetDItem(gra_controldialog, gra_action[i].item, &itemType,
			      &itemHdl, &itemRect);
			    if (strcmp(&temp[1], gra_action[i].defaultinput) != 0)
			      SetCtlValue((ControlHandle)itemHdl, 1);
			    continue;
			  }
			if (gra_action[i].item != itemHit) {
				gra_setextrainfo();				
				continue;
			}
		    if (thistype == CONRADIO)
		    {
				for(k=0; k<gra_actioncount; k++) 
				    if (gra_action[k].radiogroup == gra_action[i].radiogroup)
				{
				    GetDItem(gra_controldialog, gra_action[k].item, &itemType, &itemHdl,
					&itemRect);
				    SetCtlValue((ControlHandle)itemHdl, 0);
				}
				GetDItem(gra_controldialog, itemHit, &itemType, &itemHdl, &itemRect);
				SetCtlValue((ControlHandle)itemHdl, 1);
		    } else if (thistype == CONCHECK)
		    {
				GetDItem(gra_controldialog, itemHit, &itemType, &itemHdl, &itemRect);
				SetCtlValue((ControlHandle)itemHdl, 1-GetCtlValue((ControlHandle)itemHdl));
		    }
	
		    /* "SET" button hit, get file names */
		    if ((gra_action[i].control&CONGETPARI) != 0)
		    {
				SFGetFile(SFGwhere, "\p", 0L, -1, myTypes, 0L, &reply);
				if (reply.good)
				{
				    for(j=0; j<reply.fName[0]; j++) temp[j] = reply.fName[j+1];
				    temp[j] = 0;
				    GetDItem(gra_controldialog, gra_action[i].teitem, &itemType,
					&itemHdl, &itemRect);
				    SetIText(itemHdl, gra_makefullname(temp, reply.vRefNum));
				}
				gra_setextrainfo();
		    } else if ((gra_action[i].control&CONGETPARO) != 0)
		    {
				SFPutFile(SFPwhere, "\p", "\p", 0L, &reply);
				if (reply.good)
				{
				    for(j=0; j<reply.fName[0]; j++) temp[j] = reply.fName[j+1];
				    temp[j] = 0;
				    GetDItem(gra_controldialog, gra_action[i].teitem, &itemType,
					&itemHdl, &itemRect);
				    SetIText(itemHdl, gra_makefullname(temp, reply.vRefNum));
				}
				gra_setextrainfo();
		    }
		}
    }

    /* compose the UNIX command line */
    *argc = 0;
    for(i=0; i<gra_actioncount; i++)
    {
	thistype = gra_action[i].control & CONTYPE;
	if (thistype == CONRADIO || thistype == CONCHECK)
	{
	    GetDItem(gra_controldialog, gra_action[i].item, &itemType, &itemHdl,
		&itemRect);
	    if (GetCtlValue((ControlHandle)itemHdl) == 0) continue;
	}
	len1 = strlen(gra_action[i].string);
	if ((gra_action[i].control & (CONGETPAR|CONGETNS)) ==
	    (CONGETPAR|CONGETNS))
	{
	    GetDItem(gra_controldialog, gra_action[i].teitem, &itemType, &itemHdl,
		&itemRect);
	    GetIText(itemHdl, temp);
	    argv[*argc] = NewPtr(len1+temp[0]+1);
	    strcpy(argv[*argc], gra_action[i].string);
	    for(j=0; j<temp[0]; j++) argv[*argc][len1+j] = temp[j+1];
	    argv[*argc][len1+temp[0]] = 0;
	} else
	{
	    argv[*argc] = NewPtr(len1+1);
	    strcpy(argv[*argc], gra_action[i].string);
	}
	(*argc)++;
	if ((gra_action[i].control & (CONGETPAR|CONGETNS)) == CONGETPAR)
	{
	    GetDItem(gra_controldialog, gra_action[i].teitem, &itemType, &itemHdl,
		&itemRect);
	    GetIText(itemHdl, temp);
	    argv[*argc] = NewPtr(temp[0]+1);
	    for(j=0; j<temp[0]; j++) argv[*argc][j] = temp[j+1];
	    argv[*argc][temp[0]] = 0;
	    (*argc)++;
	}
    }

    /* terminate the window */
    DisposDialog(gra_controldialog);
    if (itemHit == 2) return(1);
    return(0);
}

/* Routine to fill in extra graphics in the dialog */
gra_setextrainfo()
{
    short itemType, i, k, bigw, w, thistype;
    Handle itemHdl;
    Rect itemRect;

    /* highlight the RUN button */
    SetPort(gra_controldialog);
    GetDItem(gra_controldialog, 1, &itemType, &itemHdl, &itemRect);
    PenSize(3, 3);
    InsetRect(&itemRect, -4, -4);
    FrameRoundRect(&itemRect, 16, 16);
    PenSize(1, 1);

    for(i=0; i<gra_actioncount; i++)
    {
	thistype = gra_action[i].control & CONTYPE;
	if (thistype == CONRADIO)
	{
	    if (i != 0 && gra_action[i-1].radiogroup == gra_action[i].radiogroup)
		continue;
	    bigw = 0;
	    for(k=i; k<gra_actioncount; k++)
	    {
		if (gra_action[k].radiogroup != gra_action[i].radiogroup) break;
		w = TextWidth(gra_action[k].display, 0, strlen(gra_action[k].display));
		if (w > bigw) bigw = w;
	    }
	    itemRect.left = gra_controldialog->portRect.left + 8;
	    itemRect.right = itemRect.left + 24 + bigw;
	    itemRect.top = (i+1)*ACTIONSIZE-18;
	    itemRect.bottom = k*ACTIONSIZE+2;
	    PenSize(2, 2);
	    FrameRect(&itemRect);
	    PenSize(1, 1);
	    continue;
	}

	/* draw an arrow if not optional */
	if ((gra_action[i].control&CONOPTION) == 0 && thistype != CONRADIO)
	{
	    MoveTo(gra_controldialog->portRect.left, (i+1)*ACTIONSIZE-9);
	    PenSize(2, 2);
	    Line(6, 0);   Line(-2, 2);   Move(0, -4);   Line(2, 2);
	    PenSize(1, 1);
	}
    }
}

needinbuf(amt)
short amt;
{
    Handle newbuf;
    short i;

    if (buflen + amt > bufsize)
    {
	newbuf = NewHandle(buflen+amt+INCREMENT);
	if (newbuf == 0L) ExitToShell();
	if (buflen != 0)
	{
	    for(i=0; i<buflen; i++) (*newbuf)[i] = (*buffer)[i];
	    DisposHandle(buffer);
	}
	bufsize = buflen + amt + INCREMENT;
	buffer = newbuf;
    }
}

addchtobuffer(ch)
char ch;
{
    needinbuf(1);
    (*buffer)[buflen++] = ch;
}

addwdtobuffer(w)
short w;
{
    needinbuf(2);
    (*buffer)[buflen++] = w >> 8;
    (*buffer)[buflen++] = w & 0377;
}

addstrtobuffer(str)
char *str;
{
    short len, i, olen;

    olen = len = strlen(str);
    if ((len&1) != 0) len++;
    needinbuf(len+1);
    (*buffer)[buflen++] = olen;
    for(i=0; i<len; i++) (*buffer)[buflen++] = str[i];
}

/*
 * Routine to make a handle to an item list that describes the controls in the dialog
 * window.
 */
gra_makecontrols()
{
    short i, k, len, w, thistype, thisitem, dwid, sw, nonoptions;

    /* compute number of items */
    k = gra_actioncount + 2;
    nonoptions = 0;
    for(i=0; i<gra_actioncount; i++)
    {
	if ((gra_action[i].control&CONGETPAR) != 0) k++;
	if ((gra_action[i].control&(CONGETPARI|CONGETPARO)) != 0) k++;
	if ((gra_action[i].control&CONOPTION) == 0 &&
	    (gra_action[i].control&CONTYPE) != CONRADIO) nonoptions++;
    }
    if (nonoptions != 0) k++;

    /* first word is number of items minus 1 */
    addwdtobuffer(k-1);

    /* add "RUN" button */
    addwdtobuffer(0);   addwdtobuffer(0);
    addwdtobuffer((gra_actioncount+1)*ACTIONSIZE+4 - 20);
    addwdtobuffer(20);
    addwdtobuffer((gra_actioncount+1)*ACTIONSIZE+4);
    addwdtobuffer(60);
    addchtobuffer(ctrlItem + btnCtrl);
    addstrtobuffer("RUN");

    /* add "cancel" button */
    dwid = gra_dialogrect.right - gra_dialogrect.left;
    addwdtobuffer(0);   addwdtobuffer(0);
    addwdtobuffer((gra_actioncount+1)*ACTIONSIZE+4 - 20);
    addwdtobuffer(dwid - 80);
    addwdtobuffer((gra_actioncount+1)*ACTIONSIZE+4);
    addwdtobuffer(dwid - 20);
    addchtobuffer(ctrlItem + btnCtrl);
    addstrtobuffer("CANCEL");

    thisitem = 3;
    for(i=0; i<gra_actioncount; i++)
    {
	thistype = gra_action[i].control & CONTYPE;
	len = strlen(gra_action[i].display);
	w = TextWidth(gra_action[i].display, 0, len);
	if (thistype == CONCOMMENT)
	{
	    /* placeholder for handle */
	    addwdtobuffer(0);   addwdtobuffer(0);
	    addwdtobuffer((i+1)*ACTIONSIZE - 16);
	    addwdtobuffer((dwid - w) / 2);
	    addwdtobuffer((i+1)*ACTIONSIZE);
	    addwdtobuffer(dwid);
	    addchtobuffer(statText);
	    addstrtobuffer(gra_action[i].display);
	    thisitem++;
	    continue;
	}

	/* setup for radio button or check box */
	if ((gra_action[i].control&(CONGETPARI|CONGETPARO)) != 0)
	{
	    sw = StringWidth("\pSET") + 8;
	    addwdtobuffer(0);   addwdtobuffer(0);
	    addwdtobuffer((i+1)*ACTIONSIZE - 16);
	    addwdtobuffer(14+sw);
	    addwdtobuffer((i+1)*ACTIONSIZE);
	    addwdtobuffer(15+sw+w);
	    addchtobuffer(statText);
	    addstrtobuffer(gra_action[i].display);
	    thisitem++;

	    addwdtobuffer(0);   addwdtobuffer(0);
	    addwdtobuffer((i+1)*ACTIONSIZE - 16);
	    addwdtobuffer(10);
	    addwdtobuffer((i+1)*ACTIONSIZE);
	    addwdtobuffer(10+sw);
	    addchtobuffer(ctrlItem + btnCtrl);
	    addstrtobuffer("SET");
	} else
	{
	    addwdtobuffer(0);   addwdtobuffer(0);
	    addwdtobuffer((i+1)*ACTIONSIZE - 16);
	    addwdtobuffer(10);
	    addwdtobuffer((i+1)*ACTIONSIZE);
	    addwdtobuffer(30+w);
	    if (thistype == CONCHECK) addchtobuffer(ctrlItem + chkCtrl); else
		if (thistype == CONRADIO) addchtobuffer(ctrlItem + radCtrl); else
		    addchtobuffer(statText);
	    addstrtobuffer(gra_action[i].display);
	}
	gra_action[i].item = thisitem++;

	/* add input box if there is any */
	if ((gra_action[i].control&CONGETPAR) != 0)
	{
	    /* placeholder for handle */
	    addwdtobuffer(0);   addwdtobuffer(0);
	    addwdtobuffer((i+1)*ACTIONSIZE - 16);	/* TOP */
	    addwdtobuffer(dwid - 6 - ANSWERWIDTH);	/* LEFT */
	    addwdtobuffer((i+1)*ACTIONSIZE);		/* BOTTOM */
	    addwdtobuffer(dwid - 10);			/* RIGHT */
	    addchtobuffer(editText);
	    addstrtobuffer(gra_action[i].defaultinput);
	    gra_action[i].teitem = thisitem++;
	}
    }

    /* explain the arrow */
    if (nonoptions != 0)
    {
		addwdtobuffer(0);   addwdtobuffer(0);
		addwdtobuffer((gra_actioncount+1)*ACTIONSIZE+4 - 20);
		w = StringWidth("Arrows show required items");
		i = (dwid-20 - w)/2 + 60;
		addwdtobuffer(60+i);
		addwdtobuffer((gra_actioncount+1)*ACTIONSIZE+4);
		addwdtobuffer(dwid - 80);
		addchtobuffer(statText);
		addstrtobuffer("Arrows show required items");
    }
}

/*
 * Routine to convert a partial name with reference number into a full path name
 */
char *gra_makefullname(thisname, refnum)
char *thisname;
short refnum;
{
    short err;
    CInfoPBRec cpb;
    char line[256];
    static char sofar[256];

    strcpy(&sofar[1], thisname);
    cpb.hfileInfo.ioVRefNum = refnum;
    cpb.hfileInfo.ioDirID = 0;
    cpb.hfileInfo.ioCompletion = 0L;
    cpb.hfileInfo.ioNamePtr = (StringPtr)line;
    cpb.hfileInfo.ioFDirIndex = -1;
    for(;;)
    {
	err = PBGetCatInfo(&cpb, 0);
	if (err != noErr) break;
	line[line[0]+1] = 0;
	strcat(line, ":");
	strcat(line, &sofar[1]);
	strcpy(&sofar[1], &line[1]);
	if (cpb.hfileInfo.ioFlParID == 0) break;
	cpb.hfileInfo.ioDirID = cpb.hfileInfo.ioFlParID;
    }
    sofar[0] = strlen(&sofar[1]);
    return(sofar);
}

/*
 * Routine to parse "parselist" into a series of dialog actions in "gra_action".
 * Returns -1 on error.
 */
gra_parsearguments(parselist)
char *parselist[];
{
    int i, type, radiopackage, optional, inlist;
    char *line, *tempstring, *macstring;

    gra_parseline = -1;
    gra_parselist = parselist;

    /* first parse the parameters */
    radiopackage = 1;
    gra_actioncount = 0;
    inlist = optional = 0;
    type = UNKNOWN;
    for(;;)
    {
	/* skip leading blanks */
	if (type == UNKNOWN)
	{
	    do { type = gra_gettoken(&line); } while (type == SEP);
	    if (type == EOP) break;
	}

	/* handle beginning of aggregations */
	if (type == OPENPAR)
	{
	    if (optional != 0)
	    {
		gra_error("Cannot have parenthetical list inside of square brackets");
		return(-1);
	    }
	    if (inlist != 0)
	    {
		gra_error("Cannot have nested parenthetical lists");
		return(-1);
	    }
	    inlist = 1;
	    type = UNKNOWN;
	    continue;
	}
	if (type == OPENBRAC)
	{
	    if (inlist != 0)
	    {
		gra_error("Cannot have square brackets inside of parenthetical list");
		return(-1);
	    }
	    if (optional != 0)
	    {
		gra_error("Cannot have nested square brackets");
		return(-1);
	    }
	    optional = CONOPTION;
	    type = UNKNOWN;
	    continue;
	}

	/* handle end of aggregation */
	if (type == CLOSEPAR)
	{
	    if (inlist == 0)
	    {
		gra_error("No open bracket to match the close bracket");
		return(-1);
	    }
	    inlist = 0;
	    radiopackage++;
	    type = UNKNOWN;
	    continue;
	}
	if (type == CLOSEBRAC)
	{
	    if (optional == 0)
	    {
		gra_error("No open parenthesis to match the close parenthesis");
		return(-1);
	    }
	    optional = 0;
	    radiopackage++;
	    type = UNKNOWN;
	    continue;
	}

	/* handle lists */
	if (type == ORBAR)
	{
	    radiopackage--;
	    type = UNKNOWN;
	    continue;
	}

	/* handle parameter */
	if (type == QUOTE)
	{
	    if (inlist == 0 && optional == 0)
		gra_action[gra_actioncount].control = CONCOMMENT | CONOPTION; else
		    gra_action[gra_actioncount].control = CONCHECK | optional;
	    gra_action[gra_actioncount].checkit = 0;
	    gra_action[gra_actioncount].string = NewPtr(strlen(line)+1);
	    strcpy(gra_action[gra_actioncount].string, line);
	    macstring = gra_action[gra_actioncount].string;
	} else if (type == WORD)
	{
	    gra_action[gra_actioncount].control = CONCHECK | optional;
	    gra_action[gra_actioncount].checkit = 0;
	    if (strcmp(line, "INPUTFILE") == 0)
	    {
		macstring = "Input file";
		gra_action[gra_actioncount].control |= CONGETPAR | CONGETPARI | CONGETNS;
	    } else if (strcmp(line, "OUTPUTFILE") == 0)
	    {
		macstring = "Output file";
		gra_action[gra_actioncount].control |= CONGETPAR | CONGETPARO | CONGETNS;
	    } else
	    {
		gra_error("Use single quotes around keywords");
		return(-1);
	    }
	    gra_action[gra_actioncount].string = NewPtr(1);
	    strcpy(gra_action[gra_actioncount].string, "");
	} else
	{
	    gra_error("Expected INPUTFILE, OUTPUTFILE, or quoted string");
	    return(-1);
	}

	/* get the true Macintosh string if specified */
	do { type = gra_gettoken(&line); } while (type == SEP);
	if (type == COLON)
	{
	    do { type = gra_gettoken(&line); } while (type == SEP);
	    if (type != QUOTE)
	    {
		gra_error("Must have quoted string after ':'");
		return(-1);
	    }
	    macstring = line;
	    type = UNKNOWN;
	}
	gra_action[gra_actioncount].display = NewPtr(strlen(macstring)+1);
	strcpy(gra_action[gra_actioncount].display, macstring);

	/* get optional parameters (if in list) */
	if (inlist != 0 || optional != 0)
	{
	    /* first see if the optional "=" is specified */
	    if (type == UNKNOWN)
		do { type = gra_gettoken(&line); } while (type == SEP);
	    if (type == EQUAL)
	    {
		do { type = gra_gettoken(&line); } while (type == SEP);
		gra_action[gra_actioncount].control |= CONGETNS;
	    }

	    /* now get the parameter */
	    if (type == QUOTE)
	    {
		gra_action[gra_actioncount].control |= CONGETPAR;
		tempstring = line;
		type = UNKNOWN;
	    } else if (type == WORD)
	    {
		if (strcmp(line, "INPUTFILE") == 0)
		{
		    gra_action[gra_actioncount].control |= CONGETPAR | CONGETPARI;
		    tempstring = "Input file";
		} else if (strcmp(line, "OUTPUTFILE") == 0)
		{
		    gra_action[gra_actioncount].control |= CONGETPAR | CONGETPARO;
		    tempstring = "Output file";
		} else if (strcmp(line, "ON") == 0)
		{
		    gra_action[gra_actioncount].checkit = 1;
		} else
		{
		    gra_error("Use single quotes around parameter keyword");
		    return(-1);
		}
		type = UNKNOWN;
	    }
	} else tempstring = "";
	gra_action[gra_actioncount].defaultinput = NewPtr(strlen(tempstring)+1);
	strcpy(gra_action[gra_actioncount].defaultinput, tempstring);

	/* end of keyword specification */
	gra_action[gra_actioncount].radiogroup = radiopackage++;
	gra_actioncount++;
    }

    /* postprocess items in the same radio group to be radio buttons */
    for(i=1; i<gra_actioncount; i++)
    {
	if (gra_action[i-1].radiogroup == gra_action[i].radiogroup)
	{
	    gra_action[i-1].control = (gra_action[i-1].control & ~CONTYPE) | CONRADIO;
	    gra_action[i].control = (gra_action[i].control & ~CONTYPE) | CONRADIO;
	}
    }
    return(0);
}

gra_gettoken(line)
char **line;
{
    static char single[2] = " ";
    short c, firstc, wordpos, i;
    static char *word, *newword;
    static short wordlen = 0;

    /* get the next character */
    c = gra_getnxtchr();
    if (c == 0) return(EOP);

    /* if alpha, gather word */
    if (c == '\'' || gra_isalnum(c))
    {
	firstc = c;
	wordpos = 0;
	for(;;)
	{
	    if (wordpos >= wordlen-1)
	    {
		newword = NewPtr(wordlen+50);
		if (newword == 0) break;
		for(i=0; i<wordpos; i++) newword[i] = word[i];
		if (wordlen != 0) DisposPtr(word);
		wordlen += 50;
		word = newword;
	    }
	    word[wordpos++] = c;
	    c = gra_getnxtchr();
	    if (c == 0) break;
	    if (firstc == '\'')
	    {
		if (c == '\'') break;
	    } else
	    {
		if (!gra_isalnum(c))
		{
		    gra_backupchr();
		    break;
		}
	    }
	}
	word[wordpos] = 0;
	if (firstc == '\'')
	{
	    *line = &word[1];
	    return(QUOTE);
	} else
	{
	    *line = word;
	    return(WORD);
	}
    }

    /* single important character */
    single[0] = c;
    *line = single;

    /* recognize special characters */
    if (c == ' ' || c == '\t') return(SEP);
    if (c == '(') return(OPENPAR);
    if (c == ')') return(CLOSEPAR);
    if (c == '[') return(OPENBRAC);
    if (c == ']') return(CLOSEBRAC);
    if (c == '|') return(ORBAR);
    if (c == '\'') return(QUOTE);
    if (c == ':') return(COLON);
    if (c == '=') return(EQUAL);
    return(UNKNOWN);
}

gra_isalnum(c)
{
    if (c >= 'a' && c <= 'z') return(1);
    if (c >= 'A' && c <= 'Z') return(1);
    if (c >= '0' && c <= '9') return(1);
    return(0);
}

gra_getnxtchr()
{
    if (gra_parseline < 0 || *gra_parsepos == 0)
    {
	if (gra_parselist[gra_parseline+1] == 0) return(0);
	gra_parseline++;
	gra_parsepos = gra_parselist[gra_parseline];
	return(' ');
    }
    return(*gra_parsepos++);
}

gra_backupchr()
{
    if (gra_parselist[gra_parseline] == 0 ||
	gra_parsepos == gra_parselist[gra_parseline])
    {
	if (gra_parseline == 0) return;
	gra_parseline--;
	gra_parsepos = gra_parselist[gra_parseline];
	while (*gra_parsepos != 0) gra_parsepos++;
	return;
    }
    gra_parsepos--;
}

gra_error(msg)
char *msg;
{
    char whichline[100];

    sprintf(whichline, "On line %d: %s", gra_parseline+1, msg);
    MyAlert(whichline);
}

/*
 * Routine to see if all required parameters have been supplied.  Returns zero
 * if so.
 */
gra_gotitall()
{
    short i, j, itemType;
    Rect itemRect;
    Handle itemHdl;
    char sofar[256];

    for(i=0; i<gra_actioncount; i++)
    {
	if ((gra_action[i].control&CONOPTION) != 0) continue;
	if ((gra_action[i].control&CONTYPE) == CONRADIO)
	{
	    for(j=0; j<gra_actioncount; j++)
		if (gra_action[j].radiogroup == gra_action[i].radiogroup)
	    {
		GetDItem(gra_controldialog, gra_action[j].item, &itemType,
		    &itemHdl, &itemRect);
		if (GetCtlValue((ControlHandle)itemHdl) != 0) break;
	    }
	    if (j < gra_actioncount) continue;
	} else if ((gra_action[i].control&(CONGETPARI|CONGETPARO)) != 0)
	{
	    GetDItem(gra_controldialog, gra_action[i].teitem, &itemType,
		&itemHdl, &itemRect);
	    GetIText(itemHdl, sofar);
	    if (sofar[0] != 0) continue;
	} else
	{
	    GetDItem(gra_controldialog, gra_action[i].item, &itemType,
		&itemHdl, &itemRect);
	    if (GetCtlValue((ControlHandle)itemHdl) != 0) continue;
	}
	MyAlert("Must set options with arrows before running");
	gra_setextrainfo();
	return(0);
    }
    return(1);
}

/*
 * A resource-free Alert routine that displays a message
 */
MyAlert(msg)
char *msg;
{
    Rect r;
    WindowPtr w, theWindow;
    ControlHandle c, theControl;
    short oak, cntlCode, chr, wid, len, winwid, line;
    EventRecord theEvent;

    r.left = 42;
    r.right = 330;
    r.top = 44;
    r.bottom = 176;
    w = NewWindow(0L, &r, "\p", 1, dBoxProc, (WindowPtr)(-1L), 1, 0L);
    SetPort(w);
    EraseRect(&w->portRect);
    TextFont(systemFont);
    TextSize(12);
    winwid = r.right - r.left - 6;

    r.left = 202;
    r.right = 262;
    r.top = 102;
    r.bottom = 122;
    c = NewControl(w, &r, "\pOK", 1, 0, 0, 1, pushButProc, 0L);
    PenSize(3, 3);
    InsetRect(&r, -4, -4);
    FrameRoundRect(&r, 16, 16);

    for(line = 20; ; line += 20)
    {
	/* find longest string */
	for(len = strlen(msg); len > 0; len--)
	{
	    if (msg[len] != 0 && msg[len] != ' ') continue;
	    wid = TextWidth(msg, 0, len);
	    if (wid <= winwid) break;
	}
	if (len <= 0) len = strlen(msg);
	MoveTo(3, line);
	DrawText(msg, 0, len);
	if (msg[len] == 0) break;
	msg += len + 1;
    }

    /* now get options */
    for(;;)
    {
	SystemTask();	/* Handle desk accessories */
	oak = GetNextEvent(everyEvent, &theEvent);
	if (oak == 0) continue;

	/* handle RETURN and ENTER keys */
	if (theEvent.what == keyDown)
	{
	    if ((theEvent.modifiers & cmdKey) == 0)
	    {
		chr = theEvent.message & charCodeMask;
		if (chr == '\r' || chr == 03) break;
	    }
	    continue;
	}

	/* handle mouse clicks */
	if (theEvent.what != mouseDown) continue;
	if (FindWindow(theEvent.where, &theWindow) != inContent) continue;
	if (theWindow != w) continue;
	GlobalToLocal(&theEvent.where);
	cntlCode = FindControl(theEvent.where, theWindow, &theControl);
	if (cntlCode == 0) continue;
	if (theControl == c) break;
    }

    /* terminate the window */
    DisposeWindow(w);
}
!Funky!Stuff!
echo x - alloc.c
cat >alloc.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: alloc.c,v 1.1 90/12/17 17:56:21 malcolm Exp $
 *
 * $Log:	alloc.c,v $
 * Revision 1.1  90/12/17  17:56:21  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: alloc.c,v 1.1 90/12/17 17:56:21 malcolm Exp $";

#include	<stdio.h>
#ifdef	__STDC__
#include	<stdlib.h>
#endif	/* STDC */

#include	"ear.h"

float	*
NewFloatArray(size,usage)
int32	size;
char	*usage;
{
	float	*p;
	extern char *progname;

	p = (float *)calloc(sizeof(*p),size);
	if (!p){
		fprintf(stderr,"%s: Can't allocate %ld floats for %s.\n", 
				progname, size, usage);
		exit(1);
	}
	return p;
}

int	*
NewIntArray(size,usage)
int32	size;
char	*usage;
{
	int	*p;
	extern char *progname;

	p = (int *)calloc(sizeof(*p),size);
	if (!p){
		fprintf(stderr,"%s: Can't allocate %ld floats for %s.\n", 
			progname, size, usage);
		exit(1);
	}
	return p;
}

!Funky!Stuff!
echo x - animate.c
cat >animate.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: animate.c,v 2.3 90/11/06 20:42:27 malcolm Exp $
 *
 * $Log:	animate.c,v $
 * Revision 2.3  90/11/06  20:42:27  malcolm
 * Incremented SampleNumber.  Changed ifdefs from Cray to ULTRA.
 * 
 * Revision 2.2  90/01/28  15:38:00  malcolm
 * Removed reference to the pitch routines.  (This is now done by saving
 * the correlograms in files and running a seperate program.)
 * 
 * Revision 2.1  89/11/09  23:12:56  malcolm
 * Added calls to the pitch routines.
 * 
 * Revision 2.0.1.1  89/08/10  22:30:05  malcolm
 * Made double buffering an ifdef-able parameter.  Also fixed a few endif's
 * that had tokens at the end.
 * 
 * Revision 2.0  89/07/25  18:58:05  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.6  89/07/21  14:37:45  malcolm
 * Moved the ALIMIT call from the correlate code to UpdateDisplay so that
 * only the display values get clipped.
 * 
 * Revision 1.5  89/07/19  12:36:02  malcolm
 * Made annotation faster by precaching all the numbers.  Also we put up the
 * digits of the time with a fixed pitch to save the kerning calculations.
 * 
 * Revision 1.4  89/03/24  16:06:53  malcolm
 * Added code to annotate the display with a numeric sample number.
 * Also, added safeguard so that normalization didn't get too small.
 * 
 * Revision 1.3  88/12/06  21:10:28  malcolm
 * Cleaned up code and removed extraneous #ifdef's.
 * 
 * Revision 1.2  88/10/23  23:07:43  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:38:11  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: animate.c,v 2.3 90/11/06 20:42:27 malcolm Exp $";

/*
 *	Animate - A simple example showing the use of the Ultra Frame Buffer
 *	on the Cray at Apple.
 *
 *	By
 *		Malcolm Slaney (documentation and cleanup)
 *		Sam Dicker (programming and brains)
 *
 *	This example is made up of five files.  This file (animate.c) generates
 *	a large array of floating point data (a diagonal sine wave across the
 *	screen).  Various parts of this array are displayed on the Ultra Frame 
 *	Buffer as fast as possible to get the effect of animation.
 *
 *	A Fortran routine called ftopix converts the array of data into black
 *	and white pixels on the screen.  
 *	
 *	The Makefile for this example is included along with the include file
 *	ub.h and the directives to the segment loader (segdir)
 */
#include <stdio.h>
#include <math.h>			/* To get the sin defintion */
#include "ub.h"				/* To get the Frame Buffer size */
#include "timer.h"

#ifdef	MAIN

#define	XSIZE 512			/* Size of data array */
#define	YSIZE (2*XSIZE)			/* Size of data array */

float amp[YSIZE][XSIZE];		/* Array to hold test data */

int	SampleNumber = 0;
float	sample_rate = 1.0;

main()
{
    register int i, j;

					/* Create a diagonal sine wave */
    for (j = 0; j < YSIZE; j++)
	for (i = 0; i < XSIZE; i++)
	    amp[j][i] = sin((i+j)*2.0*3.1415926/XSIZE);

    InitDisplay();			/* Allocate incore frame buffers/CPUs */

    for (i = 0; ; i = (i+13)%XSIZE){	/* Loop forever displaying image */
	UpdateDisplay(amp[i],XSIZE,XSIZE,-1.0,1.0);
	SampleNumber++;
    }
}
#endif	/* MAIN */

int	*fb[2];				/* Pointers to incore screen buffers */
int	 buf = 0;			/* Which buffer is being filled(0 or 1*/

/* 
 *	InitDisplay - This routine allocates two full screen buffers that
 *	will hold the pixel data.  In addition it reserves 4 CPUs for later
 *	use by the ftopix routine (if it is compiled with microtasking enabled.)
 */
InitDisplay()
{
#ifdef	ULTRA

    fb[0] = UBAllocate();			/* Get a couple of buffers */
#ifdef	DOUBLEBUFFER
    fb[1] = UBAllocate();
#else
    fb[1] = fb[0];
#endif	/* DOUBLEBUFFER */
#endif	/* ULTRA */
}

/*	
 *	UpdateDisplay - Dump an array of data (amps) with dimensions given 
 *	by (width, height) to the Ultra Frame Buffer.  Min and max are the 
 *	minimum and maximum of the data.
 */

UpdateDisplay(amps, width, height, min, max)
float amps[];
int	width, height;
float	min, max;
{
#ifdef	ULTRA
    char Buffer[512];
    int	i;
    extern	int	SampleNumber;
    extern	float	sample_rate;

#if	SLOW || !DOUBLEBUFFER
    UBBusy(fb[buf]);				/* Wait till buffer done. */
#endif

    if (UBCheck(fb[buf]))
	return;

    i = width*height;
    ALIMIT(amps,&i,&min,&max);

    if (max - min < 1e-20)
	max = min + 1.0;

    SetDisplayValue(80 + 80*256 + 255*256*256);

						/* Convert float to pixels */
    FTOPIX(fb[buf], amps, &width, &height, &min, &max);

    starttimer(17);
    sprintf(Buffer,"%10.5f",SampleNumber/sample_rate);
    AnnotateDisplay(fb[buf],Buffer);
    endtimer(17);


    UBUpdate(fb[buf]);				/* Dump buffer to screen */
    buf = 1-buf;				/* Switch to other buffer */
#endif	/* ULTRA */
}

#ifdef	ULTRA
#include "../ub/text.h"
#include "../ub/DogLib.h"
UD_RColor white = { 1., 1., 1. };
UD_RColor black = { 0., 0., 0. };

struct textcache *CSet[128];
#endif	/* ULTRA */

AnnotateDisplay(ub,string)
int	*ub;
char	*string;
{
#ifdef	ULTRA
	int	ix = 50, iy = 80, iwidth = 1280;
	char	*p;
	float	opac = 1.0;

	for (ix = 700-strlen(string)*20, p = string;*p; p++, ix += 20){
		if (!CSet[*p]){
			char	Buffer[2];
			Buffer[0] = *p;
			Buffer[1] = NULL;
			CSet[*p] = buildtext(Buffer, "Times", 52, .5, 1.0, 
						1., 1280);
		}

	    	MIXTEXT(&ub, &ix, &iy, &black, &opac, CSet[*p], 
				&iwidth);
	}
#endif	/* ULTRA */
}
		

SetDisplayValue(value)
int	value;
{
#ifdef	ULTRA
	register int	i, *p;
	long	pixel;

	pixel = (long)value*((long)(1<<32) + 1);
	p = fb[buf];
#include	"ivdep.h"
	for (i=0;i<UB_HWIDTH*UB_HEIGHT;i++)
		p[i] = pixel;
#endif	/* ULTRA */
}
!Funky!Stuff!
echo x - catsound.c
cat >catsound.c <<'!Funky!Stuff!'
#ifdef	__STDC__
#include	<stdlib.h>
#endif	
#include	<stdio.h>
#include	<math.h>
#include	<ctype.h>

#define	PI		3.141592653589792434
#define	MAXSOUND	1000000			/* 1M should be enough */

int	CurrentSoundStart = 0, Length;
int	MaxSamples = -1;
float	InputGain = 1.0;
float	SamplingRate = 22254.5454545454;
float	Output[MAXSOUND];

main(argc, argv)
int	argc;
char	**argv;
{
	register int	i, j;
	float	*Buffer;

	for (i=1;i<argc;i++){
		if (strncmp(argv[i],"-bee",4) == 0){
			fprintf(stderr,"Adding a 0.25 second beep.\n");
			for (j=0;j<SamplingRate/4.0;j++)
				Output[CurrentSoundStart++] = 
					0.25*sin(j/SamplingRate*400*2*PI);
		}
		else if (strncmp(argv[i],"-sil",4) == 0){
			float	Length = 1.0;

			if (isdigit(argv[i+1][0])){
				Length = atof(argv[++i]);
			}
			fprintf(stderr, "Adding %g seconds of silence.\n",
						Length);
			CurrentSoundStart += Length*SamplingRate;
		}
		else {
			extern float	*ReadInputFile();
			fprintf(stderr,"Reading %s ", argv[i]);
			fflush(stderr);
			Buffer = ReadInputFile(argv[i], &SamplingRate, &Length);
			fprintf(stderr, "(%g seconds at %g samples/sec.)\n", 
				Length/SamplingRate, SamplingRate);
			for (j=0;j<Length;j++)
				Output[CurrentSoundStart++] = Buffer[j];
			free(Buffer);
		}
	}

	WriteAiffFile("-",SamplingRate, CurrentSoundStart, Output, 1);
/*
	WriteADCFile("-", SamplingRate, CurrentSoundStart, Output);
	WriteByteFile("-", CurrentSoundStart, Output);
*/
}

float	*
NewFloatArray(size,usage)
int	size;
char	*usage;
{
	float	*p;

	p = (float *)calloc(sizeof(*p),size);
	if (!p){
		fprintf(stderr,"%s: Can't allocate %ld floats.\n", size);
		exit(1);
	}
	return p;
}

!Funky!Stuff!
echo x - comm.c
cat >comm.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: comm.c,v 2.1 90/11/06 20:43:21 malcolm Exp $
 *
 * $Log:	comm.c,v $
 * Revision 2.1  90/11/06  20:43:21  malcolm
 * Changed copyright notice.
 * 
 * Revision 2.0  89/07/25  18:58:09  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.2  88/10/27  23:13:11  malcolm
 * Changed so that it was legal to specify a null value to a parameter.
 * An example of this is "if=".
 * 
 * Revision 1.1  88/10/23  22:38:49  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: comm.c,v 2.1 90/11/06 20:43:21 malcolm Exp $";

/*
 *	This routine provides a simple means for searching for an argument
 *	name in a table.argument parsing.
 */
#include	<stdio.h>

comm(s,table)
char	*s;
char	*table[];
{
	register	int	i,j,r;

	for(i=0;table[i];i++){
		for (j=0;(r=table[i][j]) == s[j] && r;j++);
		if (r == 0 && s[j] == '=' )
			return(i+1);
	}
	fprintf(stderr,"bad option: %s\n",s);
	syntax();
	exit(1);
}
!Funky!Stuff!
echo x - complex.c
cat >complex.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: complex.c,v 2.1 90/11/06 20:43:52 malcolm Exp $
 *
 * $Log:	complex.c,v $
 * Revision 2.1  90/11/06  20:43:52  malcolm
 * Changed copyright notice.
 * 
 * Revision 2.0  89/07/25  18:58:14  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.6  89/04/09  17:07:08  malcolm
 * Changed debugging code to make more robust.
 * 
 * Revision 1.5  89/03/15  10:16:24  malcolm
 * Fixed bad cexp test case.
 * 
 * Revision 1.4  89/02/24  22:56:17  malcolm
 * Added lots of debugging code.  Also wrote a main program.
 * 
 * Revision 1.3  88/10/27  23:12:33  malcolm
 * Added definition of printcomplex to make it easier to debug complex code.
 * 
 * Revision 1.2  88/10/23  23:08:04  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:38:59  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: complex.c,v 2.1 90/11/06 20:43:52 malcolm Exp $";

/*
 *	This file provides several routines to make it easier to work with
 *	complex numbers.  Complex numbers are only used to calculate the
 *	filter coefficients.  During the actual processing all numbers are
 *	real.
 */

#include	"complex.h"

#if	MAIN || DEBUG
#define	PrintResult2(func,a,b,c) printf("%s[(%g,%g),(%g,%g)] = (%g,%g)\n", \
					func, \
					a.real, a.im, b.real, b.im, \
					c.real, c.im);
#define	PrintResult1(func,a,c)	 printf("%s[(%g,%g)] = (%g,%g)\n", \
					func, \
					a.real, a.im, \
					c.real, c.im);
#define	PrintResult(func,a,c)	 printf("%s[(%g,%g)] = %g\n", \
					func, \
					a.real, a.im, c);
#else
#define	PrintResult2(func,a,b,c) ;
#define	PrintResult1(func,a,c) ;
#define	PrintResult(func,a,c) ;
#endif

complex	cmul(a,b)
complex	a,b;
{
	complex c;
	c.real = a.real*b.real - a.im*b.im;
	c.im = a.real*b.im + a.im*b.real;
	PrintResult2("cmul",a,b,c);
	return(c);
}

complex	cadd(a,b)
complex	a,b;
{
	complex	c;
	c.real = a.real+b.real;
	c.im = a.im+b.im;
	PrintResult2("cadd",a,b,c);
	return(c);
}

complex	csub(a,b)
complex	a,b;
{
	complex	c;
	c.real = a.real-b.real;
	c.im = a.im-b.im;
	PrintResult2("csub",a,b,c);
	return(c);
}

complex	cdiv(a,b)
complex	a,b;
{
	double	mag;
	complex	c;

	mag = b.real*b.real + b.im*b.im;
	c.real = (a.im*b.im + a.real*b.real)/mag;
	c.im = (a.im*b.real - a.real*b.im)/mag;

	PrintResult2("cdiv",a,b,c);
	return(c);
}

complex	cmplx(a,b)
float	a,b;
{
	complex	c;
	c.real = a;
	c.im = b;
	return(c);
}

double	real(a)
complex	a;
{
	return(a.real);
}

double	aimag(a)
complex	a;
{
	return(a.im);
}

double	cmag(c)
complex	c;
{
	return(sqrt(c.real*c.real + c.im*c.im));
}

double cmag2(c)
complex	c;
{
	return(c.real*c.real+c.im*c.im);
}

double	cphase(c)
complex	c;
{
	return(atan2(c.im,c.real));
}

/*
	Complex Square Root

	Use the polar representation since the quadractic solution 
	doesn't always work.
*/
complex	csqrt(x)
complex	x;
{
	register	double	angle, mag;

	angle = atan2(x.im,x.real);
	mag = sqrt(x.real*x.real + x.im*x.im);
	mag = sqrt(mag);
	angle /= 2.0;
	return(cmplx(mag*cos(angle),mag*sin(angle)));
}

complex conjugate(x)
complex	x;
{
	return(cmplx(x.real,-x.im));
}

complex iToPower(m)
int	m;
{
	switch (m%4) {
	case 0:
		return(cmplx(1.0,0.0));
	case 1:
		return(cmplx(0.0,1.0));
	case 2:
		return(cmplx(-1.0,0.0));
	case 3:
		return(cmplx(0.0,-1.0));
	}
}

complex	cexp(x)
complex	x;
{
	double	mag;

	mag = exp(x.real);

	return(cmplx(mag*cos(x.im),mag*sin(x.im)));
}

complex cis(theta)
float	theta;
{
	return(cmplx(cos(theta), sin(theta)));
}

printcomplex(c)
complex	c;
{
	printf("(%g,%g)",c.real,c.im);
}

#ifdef	MAIN

complex	a,b;

#define	testc2(func,string)	printf("%s[(%g,%g),(%g,%g)] = ", \
					string,a.real, a.im, b.real, b.im); \
				printcomplex(func(a,b)); \
				printf("\n");
#define	testc1(func,string)	printf("%s[(%g,%g)] = ", \
					string,a.real, a.im); \
				printcomplex(func(a)); \
				printf("\n");
#define	testc(func,string)	printf("%s[(%g,%g)] = %g\n", \
					string,a.real, a.im, func(a));


main(){

	a = cmplx(1.0,2.0);
	b = cmplx(-2.0,1.0);

#ifdef	FULL
	testc2(cadd,"cadd");
	testc2(cmul,"cmul");
	testc2(csub,"csub");
	testc2(cdiv,"cdiv");
	testc(real,"real");
	testc(aimag,"aimag");
	testc(cmag,"cmag")
	testc(cmag2,"cmag2");
	testc(cphase,"cphase");
	testc1(cexp,"cexp");
	testc1(csqrt,"csqrt");
	testc1(conjugate,"conjugate");
#endif	FULL
	printcomplex(cdiv(cadd(a,b),cmul(csub(b,a),cdiv(b,a))));
	printf("\n");
}

#endif	/* MAIN */
!Funky!Stuff!
echo x - complex.h
cat >complex.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *
 * $Header: complex.h,v 2.1 90/12/17 17:57:21 malcolm Exp $
 *
 * $Log:	complex.h,v $
 * Revision 2.1  90/12/17  17:57:21  malcolm
 * Added flags so that include file would only be included once.
 * 
 * Revision 2.0  89/07/25  18:58:16  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.2  88/10/27  23:12:14  malcolm
 * Moved definition of PI into this file.
 * 
 * Revision 1.1  88/10/23  22:39:10  malcolm
 * Initial revision
 * 
 *
 */

#ifndef	_COMPLEX_H
#define	_COMPLEX_H

#include	<math.h>

typedef struct {
	float real;
	float im;
} complex;

#ifndef PI
#define PI 3.141592653589792434
#endif  /* PI */


extern	double	fmax(), fmin();
extern	double	real(), aimag(), cmag(), cphase(), cmag2();
extern	complex	cadd(), csub(), cmul(), cdiv(), cmplx(), csqrt(), conjugate();
extern	complex	iToPower(), cexp(), cis();

#endif	/* _COMPLEX_H */
!Funky!Stuff!
echo x - correlate.c
cat >correlate.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: correlate.c,v 2.4 90/12/17 17:57:40 malcolm Exp $
 *
 * $Log:	correlate.c,v $
 * Revision 2.4  90/12/17  17:57:40  malcolm
 * Big cleanup for the version 2.1 MacEar release.
 * 
 * Revision 2.3  90/11/06  20:43:59  malcolm
 * Added definition of ULTRA.  Also added UltraHeadroom factor to the
 * calculation of the maximum output from the correlation.
 * 
 * Revision 2.2  90/01/28  15:31:32  malcolm
 * Fixed spelling of correlogram.  Also changed all externally called 
 * routines so that Lick(lider) was part of the name.  This was done so
 * that the Shamma and the Licklider routines have similar names and 
 * calling protocols.  Also incorporated calls to NewFloatArray routine.
 * 
 * Revision 2.1  89/11/09  23:08:05  malcolm
 * Added log (stretched) display option.  Cleaned up some code.
 * 
 * Revision 2.0.1.1  89/07/28  21:36:09  malcolm
 * Fixed the way that the maximum correlation output was computed.  Also 
 * added this calculation to the FFT, Simple and Hartley Correlation
 * routines.  Changed the EarCorrelation routine so it would return the
 * calculated maximum.  Added a few calls to SystemCursor so that other
 * programs on the Macintosh could get some CPU time.
 * 
 * Revision 2.0  89/07/25  18:58:17  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.7  89/07/21  14:38:41  malcolm
 * Cleaned up lots of code.  Changed check for zero (when looking for bad
 * data in correlations) to check for less than 1e-10.  Also changed call
 * to fracpower to call to the power function so that everything agreed
 * with the Fortran world.
 * 
 * Revision 1.6  89/07/19  12:37:37  malcolm
 * Added some timers to fine tune the correlation pieces.
 * Also added code so that Plot3d could be called on the output of each
 * step when making ultra animation.
 * 
 * Revision 1.5  89/06/20  22:46:43  malcolm
 * Added support for LightSpeed C.  This meant changing lots of ints to
 * be int32.  Also added routine to stretch the correlogram display.  This
 * allows the time (or pitch) axis to be logarithmic.
 * 
 * Revision 1.4  89/02/24  22:58:14  malcolm
 * Fixed non-ansi #else clause.
 * 
 * Revision 1.3  88/12/06  21:11:03  malcolm
 * Cleaned up code and added lots of comments.
 * 
 * Revision 1.2  88/10/23  23:08:10  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:39:24  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: correlate.c,v 2.4 90/12/17 17:57:40 malcolm Exp $";

/*
 *	This file calculates correlations of the signals produced by each 
 *	channel of the cochlea.  The output from these routines is called
 *	a correlogram.
 *
 *	Correlograms are computed by passing the output of the cochlear model
 *	to this module every sample time.  The vector (of length 
 *	CorrelogramHeight) of values is stored in an array for later 
 *	computation.  Periodically the routine EarCorrelation should be called
 *	to compute the autocorrelation of each channel and return an array
 *	of autocorrelations.
 *
 *	There are three types of routines in this file.  They are 
 *		Initialization
 *		Data Transmission
 *		Calculations
 *	The routine InitCorrelation must be called first so that space can
 *	be allocated to save the incoming data to be correlated.  A routine
 *	called SendInputToCorrelation is called for every sample output from
 *	the cochlear model to save the data for later correlation.  Finally
 *	several routines are provided to calculate the correlation.  The 
 *	different routines use algorithms with varying degrees of robustness
 *	and speed.
 */

#include	<stdio.h>
#include	<math.h>
#include	"ear.h"

#ifndef	PI
3.141592653589793234
#endif	/* PI */

int	CorrelogramHeight;
int	CorrelogramWidth;			/* 
						 * Size of the correlogram.  
						 * The Init routine looks
						 * at the request and sets 
						 * these global variables so 
						 * that other people know 
						 * the correct sizes.
						 *
						 * The actual correlogram 
						 * output routines store the
						 * data into an array of this 
						 * size.
						 */

static float	*CorrelationData = NULL;	/* Actual storage for 
						 * the correlation 
						 * input data.  Length
						 * x Channels
						 */
static int32	CorrelationIndex = 0;		/* Current index into data */
static int	CorrelationDataLength = 0;	/* Length of input data */
static int	CorrelationFFTLength = 0;	/* Length of FFT's */
static int	CorrelationLogLength = 0;	/* Log of FFT Length */

						/* How to access data 
						 * in the input data array 
						 */
#define	CorrelationDataArray(Channel, Index) \
	(CorrelationData[(int32)(Channel)*CorrelationDataLength + \
	((int32)(CorrelationIndex + (Index))%CorrelationDataLength)])
	
						/* How to access data in
						 * the output data array
						 */
#define	OutputDataArray(Channel, Lag) \
	(Output[(int32)(Channel)*CorrelogramWidth + (Lag)])

static float	*Real, *Im;			/* Pointer to FFT 
						 * Storage
						 */

/*
 *	InitCorrelation - This routine should be called once to define the
 *	number of channels in the cochlear model and to set the number of 
 *	samples that should be saved.  The resolution of the correlogram
 *	is determined by the number of samples saved.
 */
LickInitCorrelation(Channels, Length, Between)
int	Channels, Length, Between;		/* Actual number of channels
						 * and desired correlogram 
						 * length.  Between is the
						 * number of data points 
						 * between correlograms.
						 */
{
	extern	char	*progname;
	
							/* Make it even */
							/* Save the size for
							 * other people who
							 * might need it.
							 */
	CorrelogramHeight = (Channels+1)& -2;
	CorrelogramWidth = Length;

							/* Need to pick a
							 * data length that is
							 * twice as long as the
							 * desired output so 
							 * that everything 
							 * works when windowed.
							 */
	if (Length > Between)
		CorrelationDataLength = 2*Length;
	else
		CorrelationDataLength = 2*Between;
	CorrelationIndex = 0;

							/* Some parameters 
							 * needed for the FFT 
							 * based correlation.
							 */
	for (CorrelationLogLength = 0; 
		(1<<CorrelationLogLength) < CorrelationDataLength; 
		CorrelationLogLength++);
	CorrelationLogLength ++;			/* Twice as long to 
							 * prevent circular 
							 * convolutions 
							 */
	CorrelationFFTLength = 1 << CorrelationLogLength;
	
#ifdef	DEBUG
	printf("Channels is %d, Length is %d, CorrelationFFTLength is %d, \n",
		Channels, Length, CorrelationFFTLength);
	printf("CorrelationDataLength is %d.\n", CorrelationDataLength);
#endif	/* DEBUG */
							/* Allocate an Extra 
							 * channel's worth of 
							 * storage so that
							 * correlations two at 
							 * a time (with FFT)
							 * work ok.
							 */
	CorrelationData = (float *)calloc((CorrelogramHeight+1L)*
							CorrelationDataLength, 
						sizeof(*CorrelationData));
	if (!CorrelationData){
		fprintf(stderr, 
			"%s: Can't allocate %d bytes for correlation data.\n",
			progname, (Channels+1L)*Length*sizeof(*CorrelationData));
		exit(1);
	}
	Real = (float *)calloc(CorrelationFFTLength+1L,sizeof(*Real));
	Im = (float *)calloc(CorrelationFFTLength+1L,sizeof(*Im));
	if (!Real || !Im){
		fprintf(stderr, 
			"%s: Can't allocate %ld bytes for correlation FFTs.\n",
			progname, (CorrelationFFTLength+1L)*2*
					sizeof(*CorrelationData));
		exit(1);
	}
#ifndef	PLOT3D
	if (UseUltra){
		InitDisplay();
							/* Set both frame 
							 * buffers to blue.
							 */
		SetDisplayValue(80 + 80*256 + 255*256*256);
		UpdateDisplay(CorrelationData,0,0,0.0,1.0);
		SetDisplayValue(80 + 80*256 + 255*256*256);
		UpdateDisplay(CorrelationData,0,0,0.0,1.0);
	}
#endif	/* PLOT3D */
}

#ifdef	DEBUG
/*
 *	CheckCorrelation - This routine is used to verify that the output 
 *	of the correlation routines is normalized as it should be.  This is
 *	used only for debugging.
 */
CheckCorrelation(where)
char	*where;
{
	register int32 i, Count;

	Count = CorrelogramHeight*CorrelationDataLength;
	for (i=0;i<Count;i++) {
		if (CorrelationData[i] > 1.0 || CorrelationData[i] < -1.0){
			printf("%s: Got bad correlation data at %d (%g).\n",
				where, i, CorrelationData[i]);
			exit(0);
		}
	}
}
#endif	/* DEBUG */

/*
 *	SendInputToCorrelation - This routine is called to pass an array of
 *	data from the cochlear model to the correlation routines.  The input
 *	array represents the firing rate of each channel of the cochlear model.
 *	The routine InitCorrelation should be called first to set the 
 *	parameters of the ear model.
 */
LickSendInputToCorrelation(Data)
float	Data[];
{
	register int	Channel;
	register float	f;
	int	i, One = 1;

	VMOV(Data,&One,&CorrelogramHeight,
		CorrelationData+CorrelationIndex,&CorrelationDataLength);

	CorrelationIndex = (CorrelationIndex + 1) % CorrelationDataLength;
}


/*
 *	MakeHamming - This routine makes a hamming window of any desired 
 *	length.  This routine maintains a cache to remember the last Hamming
 *	window created.  If the requested size is td.  Otherwise it deallocates
 *	the old Hamming window and creates a new one.
 */
static float	*HammingWindow = NULL;
static int	HammingLength = 0;

float *
MakeHamming(Length)
int	Length;
{
	int	i;

	if (!HammingWindow || Length != HammingLength){
		if (HammingWindow)
			free(HammingWindow);
		HammingWindow = NewFloatArray((int32)Length,"MakeHamming");
		HammingLength = Length;
		printf("Making a hamming window of length %d.\n", Length);
		for (i=0;i<Length;i++)
			HammingWindow[i] = .54 + .46 * cos(PI*(i-Length/2.0)/
								(Length/2.0));
	}
	return(HammingWindow);
}

static float	*CompensatorWindow = NULL;
static float	CompensatorLength = 0;

float *
MakeCompensator(Length)
int	Length;
{
	register int	i, lag;
	float	*Hamming = MakeHamming(Length), sum;

	if (!CompensatorWindow || Length != CompensatorLength){
		if (CompensatorWindow)
			free(CompensatorWindow);
		CompensatorWindow = NewFloatArray((int32)Length,
							"MakeCompensator");
		CompensatorLength = Length;
		printf("Making a Compensator window of length %d.\n", Length);
		for (lag = 0;lag<Length;lag++){
			sum = 0.0;
			for (i=0;i+lag<Length;i++){
				sum += Hamming[i]*Hamming[i+lag];
			}
			CompensatorWindow[i] = sum / CompensatorWindow[0];
		}
	}
	picout("Compensator",CompensatorWindow,Length*8);
	exit(1);
	return(CompensatorWindow);
}

/*
 *	SimpleCorrelation - This routine calculates the autocorrelation of
 *	each ear channel by brute force.  The resulting "CorrelogramWidth" 
 *	outputs for each channel are placed into the Output array.
 */
SimpleCorrelation(Output)
float	*Output;
{
	int	Lag, i, Channel;
	float	Sum, Max=0, Scaling;
	
	for (Channel = 0; Channel < CorrelogramHeight; Channel++){
		SystemCursor();
		for (Lag = 0; Lag < CorrelogramWidth; Lag++){
			Sum = 0.0;
			for (i = Lag; i < CorrelationDataLength; i++){
				Sum += CorrelationDataArray(Channel, i) *
					CorrelationDataArray(Channel, i - Lag);
			}
			if (Lag == 0) { 
				if (Sum == 0.0)
					Scaling = 1.0;
				else
					Scaling = 1/pow(Sum,Normalization);
			}
			OutputDataArray(Channel, Lag) = Sum * Scaling; 
		}
	} 
}

/*
 *	FFTCorrelation - Use FFT to compute autocorrelation.
 *	To save time use the symettry of the real FFT and do two FFT's at once.
 *	Stick the first data in the real part and the second data in the 
 *	imaginary part of the input.  Remember for real valued inputs the 
 *	output of the FFT will have even reals and odd imaginary components.  
 *	To get the output values do
 *		Real of first	even of real
 *		Im of first	odd of im
 *		
 *		Real of second	even of imaginary
 *		Im of second	odd of real
 *
 *	This routine is the preferred way to calculate the autocorrelation
 *	on all machines except for the Cray.
 */
FFTCorrelation(Output)
float	*Output;
{
	int	Channel, i, j;
	float	FirstScale, SecondScale;
	float	FirstReal, FirstIm, SecondReal,SecondIm, FirstMag, SecondMag;
	float	*Hamming = MakeHamming(CorrelationDataLength);
	
	for (Channel=0;Channel < CorrelogramHeight; Channel += 2){
		SystemCursor();
							/* Fill the data into 
							 * the real and 
							 * imaginary parts
							 * of the FFT array 
							 */
		for (i=0; i<CorrelationDataLength; i++){
			Real[i] = CorrelationDataArray(Channel, i) * Hamming[i];
			Im[i] = CorrelationDataArray(Channel+1, i) * Hamming[i];
			Real[CorrelationFFTLength-i] = 0.0;
			Im[CorrelationFFTLength-i] = 0.0;
		}
							/* Zero pad the rest of
							 * the array.
							 */
		for (i=CorrelationDataLength;i<=CorrelationFFTLength/2;i++){
			Real[i] = Im[i] = 0.0;
			Real[CorrelationFFTLength-i] = 0.0;
			Im[CorrelationFFTLength-i] = 0.0;
		}
		
							/* Now do the FFT */
		SystemCursor();
		starttimer(1);
		fft(Real, Im, CorrelationLogLength, 0);
		endtimer(1);
		SystemCursor();

							/* Fill in an extra 
							 * point at the end so 
							 * when we use symettry
							 * to split the FFT 
							 * output into two
							 * we don't have to 
							 * deal with the [0] 
							 * case specially
							 */
		starttimer(2);
		Real[CorrelationFFTLength] = Real[0];
		Im[CorrelationFFTLength] = Im[0];

#if	CRAY
		FMAG(Real,Im,&CorrelationFFTLength);
#else	
#include	"ivdep.h"
		for (i=0;i<=CorrelationFFTLength/2;i++){
			j = CorrelationFFTLength - i;
			FirstReal =  (Real[i] + Real[j]) /2.0;
			FirstIm =    (Im[i]   - Im[j])   /2.0;
			SecondReal = (Im[i]   + Im[j])   /2.0;
			SecondIm =   (Real[i] - Real[j]) /2.0;
		
			FirstMag = FirstReal*FirstReal + FirstIm*FirstIm;
			SecondMag = SecondReal*SecondReal + SecondIm*SecondIm;
			
			Real[i] = Real[j] = FirstMag;
			Im[i] = Im[j] = SecondMag;
		}
#endif
		endtimer(2);
		
		SystemCursor();
		starttimer(3);
		fft(Real, Im, CorrelationLogLength, 1);
		endtimer(3);
		SystemCursor();
	
							/* Hack Alert
							 * The following code
							 * tries to normalize
							 * the autocorrelations
							 * by the zero lag 
							 * term. Normally this 
							 * is ok but when the 
							 * input is all zeros 
							 * then after
							 * fft'ing you are left
							 * with random bit 
							 * noise.  This check
							 * tries only does the
							 * scaling if the zero
							 * lag is really bigger
							 * than the rest.
							 */

		starttimer(4);
		if (Real[0] <= 0.0e-10 || Real[0] < Real[1] || 
		    Real[0] < Real[2]){
			FirstScale = 0.0;
		} else {
			FirstScale = 1/pow(Real[0],Normalization);
		}  

		if (Im[0] <= 0.0e-10 || Im[0] < Im[1] || Im[0] < Im[2]){
			SecondScale = 0.0;
		} else {
			SecondScale = 1/pow(Im[0],Normalization);
		}

		for (i=0;i<CorrelogramWidth; i++){
			OutputDataArray(Channel, i)  = Real[i]*FirstScale;
			OutputDataArray(Channel+1, i)  = Im[i]*SecondScale;
		}
		endtimer(4);
	}
}

/*
 *	HartleyCorrelation - This is the prototype of a routine that will
 *	eventually use the Hartley transform to do the correlation.  The 
 *	Bracewell/Hartley transform has all the nice properties of the FFT
 *	but it is real valued so we don't have to do the 2-in-one hack that
 *	was used to make the FFTCorrelation run fast.
 */
HartleyCorrelation(Output)
float	*Output;
{
	int	i, Channel, Lag;
	float	Sum, Max=0, Scaling, FirstReal, FirstIm;
	float	*Hamming = MakeHamming(CorrelationDataLength);
	
	for (Channel = 0; Channel < CorrelogramHeight; Channel++){
							/* Fill the data into 
							 * the real part
							 * of the FFT array 
							 */
		for (i=0; i<CorrelationDataLength; i++){
			Real[i] = CorrelationDataArray(Channel, i) * Hamming[i];
			Real[CorrelationFFTLength-i] = 0.0;
			Im[i] = Im[CorrelationFFTLength-i] = 0.0;
		}
							/* Zero pad the rest of
							 * the array.
							 */
		for (i=CorrelationDataLength;i<=CorrelationFFTLength/2;i++){
			Real[i] = Im[i] = 0.0;
			Real[CorrelationFFTLength-i] = 0.0;
			Im[CorrelationFFTLength-i] = 0.0;
		}
		
							/* Now do the FFT */
		starttimer(11);
		fft(Real, Im, CorrelationLogLength, 0);
		endtimer(11);

		starttimer(12);
		Real[CorrelationFFTLength] = Real[0];
		Im[CorrelationFFTLength] = Im[0];

#include	"ivdep.h"
		for (i=0;i<CorrelationFFTLength;i++){
			FirstReal =  Real[i];
			FirstIm =    Im[i];
			Real[i] = FirstReal*FirstReal + FirstIm*FirstIm;
			Im[i] = 0;
		}
		endtimer(12);
		
		starttimer(13);
		fft(Real, Im, CorrelationLogLength, 1);
		endtimer(13);

		if (Real[0] <= 0.0 || Real[0] < Real[1] || Real[0] < Real[2]){
			Scaling = 0.0;
		} else {
			Scaling = 1/pow(Real[0],Normalization);
		}  
		for (i=0;i<CorrelogramWidth; i++){
			OutputDataArray(Channel, i) = Real[i]*Scaling;
		}
	}
}


#ifdef	CRAY

/*
 *	CrayCorrelation - This routine calls a Fortran routine (that has been
 *	vectorized and parallelized) to really do the correlations fast on
 *	the Cray.  See the file fcor.f for the definition of the FCOR function.
 */
CrayCorrelation(Output)
float	*Output;
{
	int	i;
	float	*window = MakeHamming(CorrelationDataLength);
	float	*work;
	float	*initfft();
	extern float Normalization;

	work = initfft(CorrelationFFTLength);

#ifdef	TEST
	for (i=0;i<CorrelationDataLength;i++)
		CorrelationData[2*CorrelationDataLength + i] = 
				1+sin(i*3.141592/10.0);
	CorrelationIndex = 0;
#endif	/* TEST */

	starttimer(14);
	FCOR(CorrelationData, Output, window, work, &CorrelogramWidth,
		&CorrelogramHeight, &CorrelationDataLength, 
		&CorrelationFFTLength, &CorrelationIndex, &Normalization);
	endtimer(14);
}

#endif	CRAY
	
/*
 *	EarCorrelation - This routine is actually called from the main program
 *	to do the correlations.  It just starts up a timer, calls the 
 *	appropriate correlation code and optionally displays the result on 
 *	the Ultra Buffer (if you are running on a Cray.)
 */
double
LickEarCorrelation(Output)
float	*Output;
{
	float	Max;
	
	starttimer(0);
	
#ifdef	CRAY
	CrayCorrelation(Output);
#else
	FFTCorrelation(Output);
#endif
	
	if (LogDisplay)
		StretchDisplay(Output, CorrelogramWidth, CorrelogramHeight);

	Max = CorrelogramWidth * AgcStage4Target * AgcStage4Target * .125 * 
		UltraHeadroom;
	Max = Max / pow(Max,Normalization);

	if (UseUltra){
		char	PlotBuffer[BUFSIZ];
		int	i, Lag, Channel;

		starttimer(7);

#ifdef	PLOT3D
#define	TmpFile	"/tmp/correlogram"
#define	PlotCommand "/v/malcolm/bin/plot3d z=/tmp/correlogram xsize=%d ysize=%d xskip=1 zmax=%g -P yp=5 scfac=.5 tl=\"%10.5f\" phi1=-40 | oultraplot -a"
		sprintf(PlotBuffer, PlotCommand, CorrelogramWidth,
		    CorrelogramHeight,
		    AgcStage4Target*sqrt(2.0*CorrelogramWidth)*10*UltraHeadroom,
		    SampleNumber/sample_rate);
	        Output[CorrelogramWidth*(CorrelogramHeight-1)] = 
		    AgcStage4Target*sqrt(2.0*CorrelogramWidth)*10*UltraHeadroom;
		

		picout(TmpFile,Output,CorrelogramWidth*CorrelogramHeight);
		printf("%s\n", PlotBuffer);
		i = system(PlotBuffer);
		if (i < 0){
		     fprintf(stderr,"System() failed.  Try setenv NCPUS=1\n");
		     exit(1);
		}
#else	/* !PLOT3D */
		UpdateDisplay(Output,CorrelogramWidth,CorrelogramHeight,
					0.0, Max);
#endif	/* PLOT3D */
		endtimer(7);
	}
	endtimer(0);

	return(Max);
}

static	int	*index;
static	float	*warp, *frac, *frac1, *newd;
static	int	StretchStarted = 0;

StretchDisplay(data,lags,channels)
float	*data;
int	lags, channels;
{
	register int i,j;
	
	if (!StretchStarted){
		float	alpha, beta;

		index = (int *) malloc(sizeof(*index)*lags);
		warp = NewFloatArray((int32) lags, "StretchDisplay");
		frac = NewFloatArray((int32) lags, "StretchDisplay");
		frac1 = NewFloatArray((int32) lags, "StretchDisplay");
		newd = NewFloatArray((int32) lags, "StretchDisplay");

		if (!index || !warp || !frac || !frac1 || !newd){
			fprintf(stderr,
				"Can't allocate space for StretchDisplay.\n");
			exit(1);
		}
						/* 
						 * Want to solve
						 *  warp(x) = beta e^(alpha x)
						 * with warp(0) = 10 and
						 *      warp(lags) = lags.
						 */
		beta = 20.0;
		alpha = log(lags/beta)/lags;
		for (i=0;i<lags;i++){
			warp[i] = beta * pow(2.718,alpha*i);

			index[i] = floor(warp[i]);
			frac[i] = warp[i]-index[i];
			frac1[i] = 1-frac[i];
			picout("warp.d",warp,lags);
		}
		StretchStarted = 1;
	}

	for (j=0;j<channels;j++){
		float	*row;

		row = &data[j*lags];

#include	"ivdep.h"
		for (i=0;i<lags;i++)
			newd[i] = row[index[i+1]]*frac1[i+1] +
				  row[index[i+1]+1]*frac[i+1];
#include	"ivdep.h"
		for (i=0;i<lags;i++)
			row[i] = newd[i];
	}
}

#ifdef	MAIN

#define	NChannels	2
#define	NLength		32

char	*progname = "correlate test";

/*
 *	Main Program (Test Code) - This main program generates two channels
 *	of data and then calls FFTCorrelation to make sure the output is 
 *	correct.  One channel is a sine wave so the output should also be
 *	a sine wave.  The other channel has a square pulse so the output should
 *	be a triangle wave.
 */

int	UseUltra = 0, LogDisplay = 0;
float	AgcStage4Target = .0004;
float	Normalization = .75;
float	UltraHeadroom = 1.0;
float	sample_rate = 16000.0;
int	SampleNumber = 0;

main(){
	register int	i;

	float	Data[NChannels], *Output;

	LickInitCorrelation(NChannels, NLength, NLength);
	
	for (i=0;i<NLength; i++){
		Data[1] = sin(i*4.0/NLength*2*PI);
		Data[0] = (i < NLength/2)? 1.0 : 0.0;
		LickSendInputToCorrelation(Data);
	}
	
	Output = (float *)calloc(NLength*NChannels,sizeof(*Output));
	if (!Output){
		fprintf(stderr, 
		     "%s: Couldn't allocate %d bytes for output correlation.\n",
			progname, NLength*NChannels*sizeof(*Output));
		exit(1);
	}
	
	FFTCorrelation(Output);
	
	for (i=0;i<NLength; i++){
		printf("%4d:	%10g	%10g\n",i,Output[0*CorrelogramWidth+i], 
						Output[1*CorrelogramWidth+i]);
	}
}

#endif	/* MAIN */
!Funky!Stuff!
echo x - ear.c
cat >ear.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: ear.c,v 2.5 91/01/23 11:22:46 malcolm Exp $
 *
 * $Log:	ear.c,v $
 * Revision 2.5  91/01/23  11:22:46  malcolm
 * Added a couple of calls to SystemCursor so that the user can get access
 * to the menus and such when running on slow machines like Mac SE's.
 * 
 * Revision 2.4  90/12/17  17:59:38  malcolm
 * Mostly a cleanup, especially in the correlogram code.  Also added routine
 * to write out correlogram summary information.
 * 
 * Revision 2.3  90/11/06  20:44:51  malcolm
 * Added video recording capability (just affects the timing of correlations.)
 * Also made impulse height a function of the input gain.
 * 
 * Revision 2.2  90/01/28  15:33:33  malcolm
 * Fixed spellings of correlogram.  Also fixed the code that calls the 
 * correlogram code so that it can compute either the Licklider or Shamma
 * styles of correlogram.
 * 
 * Revision 2.1  89/11/09  23:11:40  malcolm
 * Removed the Calculate Response code.  Also added code to output correlograms
 * in sync with NTSC video tape.
 * 
 * Revision 2.0.1.1  89/07/28  21:35:12  malcolm
 * Changed the call to EarCorrelation so that it accepted the maximum
 * value returned.  Changed the ByteOutput code so that it used this maximum
 * when limiting the output level.
 * 
 * Revision 2.0  89/07/25  18:58:21  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.12  89/07/25  18:52:51  malcolm
 * Fixed up some defines for the BYTEOUTPUT option.
 * 
 * Revision 1.11  89/07/21  14:41:37  malcolm
 * Fixed up code that puts job in the real time queue.  It still doesn't
 * run at full speed but its getting better.  Perhaps all that is missing
 * is the plock call.
 * 
 * Revision 1.10  89/07/19  12:39:21  malcolm
 * Cleaned out some obsolete printfs.
 * Made some of the code a little prettier.
 * Made first attempt at a Cray RunRealTime function.
 * 
 * Revision 1.9  89/06/20  22:44:48  malcolm
 * Added support for LightSpeed C and added #ifdef so correlogram output
 * files could be byte format.
 * 
 * Revision 1.8  89/04/09  17:01:58  malcolm
 * Added ultra frame buffer recording stuff and allow DecimationFactor of
 * zero to indicate no decimation AND no filtering.
 * 
 * Revision 1.7  89/02/26  14:54:57  malcolm
 * Removed fixed length ear model code (used to be dependent on value of
 * EAR_LENGTH include variable).  Also moved ear design calls after reading
 * in the input file so the sample rate is correct.  Finally moved output
 * functions to output.c file.
 * 
 * Revision 1.6  89/02/25  12:11:48  malcolm
 * Moved most utility routines (like argument parsing and setting up
 * Fortran ear model) to the utilities.c file.  Also moved the definition
 * of most global variables to this file.  All that is left now is the
 * main program for calculating the ear model output and the correlograms.
 * 
 * Revision 1.5  89/02/24  22:53:46  malcolm
 * Changed impulse height and only get extra CPUs if we are using the
 * Ultra buffer or computing correlations.
 * 
 * Revision 1.4  88/12/04  17:36:09  malcolm
 * Added parameters for number of CPUs (cpus) and normalize factor.  Also
 * changed the default values of cstep to 128 and clag to 256.  Finally called
 * new routine that looks at the file suffix to determine the file type.
 * 
 * Revision 1.3  88/11/03  15:47:52  malcolm
 * Cleaned up the code that determines when the ultra buffer is used.  Added
 * second dummy channel to handle the preemphasis part of the model.  Defined
 * routine that can be called from Fortran to get the state of the global
 * variables into a common block.
 * 
 * Revision 1.2  88/10/23  23:08:14  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:39:37  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: ear.c,v 2.5 91/01/23 11:22:46 malcolm Exp $";

/*
 *	This is the main program for calculating cochleagrams and correlograms.
 *	This routine just does argument parsing and calls other routines to
 *	design the filters and perform the calculations.
 */

#include	<stdio.h>
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

main(argc,argv)
int	argc;
char	**argv;
{
	int32	i;
	float	*Data, *ReadInputFile();
	float	Output[MaxN];
	float	CorrelogramMax;

	InitParms();

	progname = *argv;
	while(argv++ , --argc){
		if (**argv == '?')
			syntax();
		if(( **argv=='-' || **argv=='+')&& argv[0][1]) {
			ProcessOption(*argv);
		}else {
			ProcessArgument(*argv);
		}
	}
	
	if (ffn){
		ffp = fopen(ffn,"w");
		if (!ffp) {
			fprintf(stderr, 
			    "%s: Can't open %s for writing filtered data.\n",
				progname);
			exit(1);
		}
	}

	CheckParms();

	if (printflag){
		PrintStats();
	}

	OpenOutputFile(ofn);

	if (ImpulseInput){
		DataLength = 512;
		Data = (float *)calloc(DataLength, sizeof(*Data));
		Data[0] = InputGain;
	} else {
		Data = ReadInputFile(ifn, &sample_rate, &DataLength);
	}

	SystemCursor();

	ChangeDecimationParameters();
	ChangeAgcParams();

	SystemCursor();
	DesignEarFilters();

#ifdef	MINUSG
	CPUs = 1;
#endif	/* MINUSG */

#ifdef CRAY
	if (CPUs > 1 && (UseUltra || cfn) ){	
		printf("Getting %d cpus.\n", CPUs);
		GETCPUS(&CPUs);

		/* RunRealTime();	 */

	}
#endif	/* CRAY */

	inittimers();

	if (1) {
		int	FrameCount, CorrelationPictureCount = 0;
		long	CorrelationOutputSize;
		float	*CorrelationOutput = NULL;
		float	SamplesPerFrame, NextMovieTime;
		
		SamplesPerFrame = sample_rate/NTSC_RATE;
		NextMovieTime = SamplesPerFrame;
		FrameCount = 0;

		if (cfn || UseUltra){
			if (!VideoRecord)
				InitCorrelation(EarLength-2, CorrelationLags,
						CorrelationStep);
			else
				InitCorrelation(EarLength-2, CorrelationLags,
						(int)SamplesPerFrame);
			CorrelationOutputSize = (long)CorrelogramWidth * 
						CorrelogramHeight;
			CorrelationOutput = NewFloatArray((int32)
							CorrelationOutputSize,
							"CorrelationOutput");
		}

		for (i=0;i<DataLength;i++){
			SystemCursor();
			SampleNumber = i;

			starttimer(10);
			EARSTEP(&Data[i], Output);
			endtimer(10);
			if (ffp)
				fwrite(Output+2,sizeof(*Output),EarLength-2,
					ffp);

			if (!VideoRecord && (!DecimationFactor || 
						(i % DecimationFactor) == 0) ||
			        (VideoRecord && i && i>NextMovieTime)){
				WriteOutputFile(Output+2,EarLength-2);
			}
			if (cfn || UseUltra){
				SendInputToCorrelation(Output+2);
			}

			if ((cfn || UseUltra)
			    && ((!VideoRecord && i && (i%CorrelationStep) == 0)
			        || (VideoRecord && i && i>NextMovieTime))){
				FrameCount++;
#if	THINK_C || BUILDAPP
			    	printf(
				     "Computing Correlogram for sample %ld.\n",
				     (long)i);
#endif	/* THINK_C */
				CorrelogramMax = 
					EarCorrelation(CorrelationOutput);
				if (cfn) {
					char Name[BUFSIZ];
					sprintf(Name,"%s%05ld(%dx%d)", cfn, 
							(long)FrameCount,
							CorrelogramWidth,
							CorrelogramHeight);
#ifdef	BYTEOUTPUT
					BytePicout(Name, CorrelationOutput,
						(int32)CorrelogramWidth*
							CorrelogramHeight,
						0.0, CorrelogramMax);
#else
					picout(Name, CorrelationOutput,
						(int32)CorrelogramWidth*
							CorrelogramHeight);
#endif	/* BYTEOUTPUT */
				}
				CorrelationPictureCount++;
			}
			if (VideoRecord && i && i>NextMovieTime){
				NextMovieTime += SamplesPerFrame;
			}
		}
		if (!UseUltra){
			if (cfn){
				printf(
				   "Correlogram (%s) is %dx%dx%d.\n",
					cfn, CorrelogramWidth, 
					CorrelogramHeight, 
					CorrelationPictureCount);
			}
		}
	}
	CloseOutputFile();

	if (cfn)
		WriteCorrelationInfo(CorrelogramMax);

	if (ffp) 
		fclose(ffp);
	printtimers();
}

RecordVideo(){
#ifdef	CRAY
	fprintf(stderr,"remsh dumbo \"setenv WF_RECDEV diaq;/usr/local/wave/bin/record\"");
	system("echo hello.");
	system("remsh dumbo \"setenv WF_RECDEV diaq;/usr/local/wave/bin/record\"");
/*
	char	Buffer[512];
	int	i;
	printf("Recording a frame.....");
	clearerr(stdin);
	i = fgets(Buffer,512,stdin);
	printf("fgets got *%d*\n",i);
 */
#endif	/* CRAY */
}

/*
 *	RunRealTime - This is a first attempt at putting the ear model
 *	into the Cray real time queue so it runs really fast.  It doesn't
 *	work yet.
 */

#ifdef	CRAY

#define	CPUFILE	"/dev/cpu/any"

#include	<errno.h>
#include	<sys/cpu.h>
#include	<sys/category.h>

#endif	/* CRAY */

RunRealTime(){
#ifdef	CRAY
	int		i, fd;
	struct cpudev	cpu;

	fd = open(CPUFILE,0);

	if (fd < 0) {
		fprintf(stderr, "Couldn't open %s for reading.\n", CPUFILE);
		return(0);
	}

	cpu.cat = C_PROC;
	cpu.id = 0;
	cpu.word = 0;

	i = ioctl(fd, CP_SETRT,(char *) &cpu);
	if (i < 0){
		fprintf(stderr, "CP_SETRT ioctl failed.\n");
		perror("ear: RunRealTime:");
	}
#endif	/* CRAY */
}


WriteCorrelationInfo(Max)
float	Max;
{
	FILE	*fp;
	char	InfoName[BUFSIZ], *p;

	if (!cfn)
		return;

	strcpy(InfoName, cfn);
	p = InfoName + strlen(InfoName) - 1;

	while (p > InfoName && *p != '/')
		p--;

	if (*p == '/')
		p++;
	*p = 0;

	strcat(InfoName, CorrelationInfoFile);

	printf("Putting information in %s.\n", InfoName);

	fp = fopen(InfoName, "w");

	fprintf(fp, "ImageMax=%g\n", Max);
	fprintf(fp, "ImageMin=0\n");

	fclose(fp);
}
!Funky!Stuff!
echo x - ear.h
cat >ear.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *
 * $Header: ear.h,v 2.3 90/12/17 18:00:28 malcolm Exp $
 *
 * $Log:	ear.h,v $
 * Revision 2.3  90/12/17  18:00:28  malcolm
 * Cleanup and added VMOV definition.
 * 
 * Revision 2.2  90/01/28  15:21:38  malcolm
 * Fixed spelling of correlogram.  Added definitions for new Licklider/
 * Shamma correlogram routines.  Also added definitions for NewFloatArray
 * and NewIntArray.
 * 
 * Revision 2.1  89/11/09  23:05:52  malcolm
 * Added NTSC defines (for making videos), added support for Steve Rubin's
 * UNIX shell.
 * 
 * Revision 2.0.1.2  89/08/10  22:18:55  malcolm
 * Added MaxSamples definition and fixed correlogram spelling.
 * 
 * Revision 2.0.1.1  89/07/28  21:34:07  malcolm
 * Added code for SystemCursor on the Macintosh so that other applications
 * can run.  Also added definition of EarCorrelation so that a float is 
 * returned.
 * 
 * Revision 2.0  89/07/25  18:58:24  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.5  89/07/25  18:53:35  malcolm
 * Cleaned up some of the comments and added a lot of stuff about file 
 * formats.
 * 
 * Revision 1.4  89/07/19  12:59:19  malcolm
 * Changed some printfs around for the Mac.  Changed printf to rubin_printf
 * when building a Macintosh application.
 * 
 * Revision 1.3  89/06/20  22:43:54  malcolm
 * Added support for LightSpeed C.
 * 
 * Revision 1.2  89/04/09  17:03:25  malcolm
 * Moved Macintosh includes into this file.  Also added an extern declarations
 * for all state variables.
 * 
 * Revision 1.1  88/10/23  22:39:48  malcolm
 * Initial revision
 * 
 *
 */

/*
 *	Output formats.
 *	This code supports a number of different output formats.  You should
 *	define one of the following formats and undef the rest.  These options
 *	determine the style of output for the cochleagram and the correlogram.
 *	
 *	Header Formats
 *	First determine whether there should be a header on the files.  The
 *	best supported is NOHEADER.  The OGC people wanted a different format
 *	based on the CMU syncrep format.
 *	
 *	In the NOHEADER format the data is output in the order which it is
 *	computed.  The cochleagram output is written 84 channels per time
 *	step with channels ordered from high frequency to low (base to
 *	apex of the cochlea.)  The correlogram output is one two dimensional
 *	time step per file.  Each file has the autocorrelation of each
 *	channel written in order from base to apex.  The output value is
 *	the zero lag for channel 0 (at the base),  the second value is the
 *	autocorrelation output for a time lag of one sample interval of the
 *	channel 0.
 *	
 */
#define	NOHEADER 		/* Define Simplest Output File Format */
#undef	OGC			/* Let's do it the OGC way */
#undef	SPHYNX			/* Let's put out data for Kai Fu Lee's Sphynx */

/*
 *	Data Formats
 *	There are three different styles of output data.  Which one you should
 *	use depends on what you are going to do with the data.  If you are
 *	going to read the data with custom written software than binary 
 *	floating point is fastest.  If you are going to look at the output
 *	using an editor than ASCII text output is best.  If you are going
 *	to use an image display program than 8 bit byte output will be the
 *	most natural.
 *	
 *	Both the cochleagram and the correlogram are output in the format
 *	specified below.
 *	FLOATOUTPUT - Output the data in the machine's native binary floating
 *		point format.  This is the fastest method of IO since the data
 *		is copied directly from the array to the output file.  This is
 *		the default action.
 *	TEXTOUTPUT - Convert the data into ASCII and output the results in 
 *		a readable format.  This format is useful for reading the
 *		data in editors and programs like spreadsheets that want the
 *		data in a human readable format.  This option is often nice
 *		when verifying the output of the program.
 *	BYTEOUTPUT - Convert the data into 8 bit unsigned bytes for display 
 *		by a B&W display program.  Both the cochleagram and the 
 *		correlogram outputs are always non negative so a zero byte
 *		is zero.  The maximum output value (255) is a function of
 *		the final AGC target value.
 */

#if	!defined(FLOATOUTPUT) && !defined(TEXTOUTPUT) && !defined(BYTEOUPUT)

#undef	FLOATOUTPUT			/* Binary Floating Point Output */
#undef	TEXTOUTPUT			/* Readable ASCII Text Output */
#define	BYTEOUTPUT			/* 8 Bit Unsigned Byte Output */

#endif

#define	CorrelationInfoFile	".info"	/* Name of information file for */
					/* correlation directory. */

/*
 *	The definitions that follow are not for user configuration.  You
 *	shouldn't change any of the following parameters unless you know
 *	what you are doing.
 */

#include	"timer.h"
#include	"complex.h"
#include	"filter.h"

#ifdef	THINK_C
#include	<unix.h>
#include	<stdlib.h>

#define	int32	long			/* Can't use 16 bit ints... */

#endif	/* THINK_C */

#ifndef	int32
#define	int32	int
#endif

					/* A few of the arrays in this program
					 * are allocated at compile time to
					 * improve the performance.  This means
					 * that they have fixed size that is
					 * a function of the maximum number
					 * of channels expected.  This number
					 * is set to 180 so that the arrays
					 * can fit on a Mac.  If you're not
					 * using a Mac then you can set this 
					 * as high as you want.
					 *
					 * Note, if you change this number you
					 * must also change this parameter at
					 * the beginning of fear.f
					 */
#define	MaxN 180

#define	EAR_LENGTH		88
#define	LOG_RESPONSE_LENGTH	8
#define	RESPONSE_LENGTH		(1<<LOG_RESPONSE_LENGTH)


#ifndef	PI
#define	PI 3.141592653589792434
#endif	/* PI */

#define	NTSC_RATE	29.985
#define	NTSC_INCREMENT	(1/NTSC_RATE)

#if	THINK_C || BUILDAPP

#define	printf	rubin_printf		/* Use Unix shell version */
#define	main	_main			/* Use Steve's main */
#define	exit	rubin_exit		/* Use Unix shell version */

#ifdef	BUILDAPP			/* Only defined in MPW */

#include	<traps.h>
#include	<desk.h>

#endif	/* BUILDAPP */

#define	SystemCursor()	{short chr; gra_nextevent(&chr);}

/* #define	SystemCursor()		SystemTask();	*/

#else	/* THINK_C || BUILDAPP */

#define	SystemCursor()	;

#endif	/* THINK_C || BUILDAPP */

extern	float	AMAX(), AMIN();

#define min(a,b) (((a) > (b)) ? (b) : (a))
#define max(a,b) (((a) < (b)) ? (b) : (a))

#ifndef	CRAY

#define	VMOV(input, input_incp, lengthp, output, output_incp) { \
	register int	i; 					\
	float	*pin = (input), *pout = (output);		\
								\
	for (i=0; i< *(lengthp); i++){				\
		*pout = *pin;					\
		pin += *(input_incp);				\
		pout += *(output_incp);				\
	}							\
}

#endif	/* CRAY */



					/* Global State
					 * Used by the rest of the programs 
					 * Mostly definited in utilities.c
					 */

extern	int	Debug;
extern	int	printflag;
extern	int	ImpulseInput;
extern	int	UseAgc;
extern	int	UseCascade;
extern	int	UseDifference;
extern	int	CalculateResponse;
extern	int	ComputeFiltered;
extern	int	UseUltra;
extern	int	CPUs;
extern	int	VideoRecord;
extern	int	LogDisplay;
extern	char	*progname;
extern	char	*ifn;			/* Input File Name */
extern	char	*ofn;			/* Output File for Cochleagram */
extern	char	*ffn;			/* Filtered Output */
extern	char	*cfn;			/* Correlogram Directory Name */

extern	float	sample_rate;
extern	int32	DataLength;
extern	int32	MaxSamples;

extern	float	AgcStage1Tau;
extern	float	AgcStage2Tau;
extern	float	AgcStage3Tau;
extern	float	AgcStage4Tau;
extern	float	AgcStage1Target;
extern	float	AgcStage2Target;
extern	float	AgcStage3Target;
extern	float	AgcStage4Target;
extern	int	DecimationFactor;
extern	int	CorrelationStep;
extern	int	CorrelationLags;
extern	int	CorrelogramWidth;
extern	int	CorrelogramHeight;
extern	float	TauFactor;
extern	float	Normalization;
extern	float	UltraHeadroom;
extern	float	InputGain;

extern	float	EarBreakFreq;
extern	float	EarQ;
extern	float	EarStepFactor;
extern	float	EarSharpness;
extern	float	EarZeroOffset;
extern	float	EarPreemphCorner;

extern	float	AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4;
extern	float	a0[], a1[], a2[], b1[], b2[];
extern	float	DecimationEpsilon;
extern	struct	filter	EarFilterArray[];

extern	float	Output[];
extern	int	EarLength;
extern	FILE	*ffp;

extern	int	SampleNumber;

extern	int	LickInitCorrelation();
extern	int	LickSendInputToCorrelation();
extern	double	LickEarCorrelation();

extern	int	ShammaInitCorrelation();
extern	int	ShammaSendInputToCorrelation();
extern	double	ShammaEarCorrelation();

extern	int	PattersonInitCorrelation();
extern	int	PattersonSendInputToCorrelation();
extern	double	PattersonEarCorrelation();

extern	char	*CorrelogramType;
extern	int	SharpResponse;
extern	int	TransformCorrelogram;

extern int	(*SendInputToCorrelation)();
extern int	(*InitCorrelation)();
extern double	(*EarCorrelation)();

extern float	*NewFloatArray();
extern int	*NewIntArray();

!Funky!Stuff!
echo x - eardesign.c
cat >eardesign.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: eardesign.c,v 2.1 90/11/06 20:45:34 malcolm Exp $
 *
 * $Log:	eardesign.c,v $
 * Revision 2.1  90/11/06  20:45:34  malcolm
 * Added calculation of the group delay.  Also moved center frequency
 * calculations into the filter specific files (sos or hydro).
 * 
 * Revision 2.0  89/07/25  18:58:26  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.7  89/07/19  12:41:46  malcolm
 * Changed MaxN to MaxChannels.  Also moved the ear filter bank parameter
 * storage to the utilities.c file.
 * 
 * Revision 1.6  89/04/09  17:06:47  malcolm
 * Added debugging code.
 * 
 * Revision 1.5  89/02/24  22:57:08  malcolm
 * Changed definition of atof() from float (wrong) to double.
 * 
 * Revision 1.4  88/12/06  21:11:56  malcolm
 * Fixed up declarations for the Macintosh.
 * 
 * Revision 1.3  88/10/27  23:15:08  malcolm
 * Changed most function names to agree with the Mathematica notebook.
 * Cleaned up some code, added lots of comments and made sure that results
 * agreed with Mathematica results.
 * 
 * Revision 1.2  88/10/23  23:08:19  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:39:59  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: eardesign.c,v 2.1 90/11/06 20:45:34 malcolm Exp $";

/*
 *	This file designs the filters used to model the cochlea.
 *	Compile with -DMAIN to test these functions.
 */

#include	<stdio.h>
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

/*
 *	AllocatePolynomial - Create a polynomial structure of the given order
 *	(leave room for order+1 coefficients.)
 */
struct polynomial *AllocatePolynomial(order)
int	order;
{
	struct polynomial *pp;

	pp = (struct polynomial *)calloc(1,sizeof(*pp));
	if (!pp){
		fprintf(stderr, 
		"AllocatePolynomial: Couldn't allocate polynomial structure.\n"
			);
		exit(1);
	}
	pp->order = order;
	pp->coeff = (float *)calloc(order+1, sizeof(float));
	if (!pp->coeff){
	    fprintf(stderr, 
	    "AllocatePolynomial: Couldn't allocate space for polynomial list.\n"
		);
	    exit(1);
	}
	pp->coeff[order] = 1.0;
	return(pp);
}

/*
 *	PrintPolynomial - Pretty print a polynomial structure.
 */
PrintPolynomial(pp)
struct polynomial *pp;
{
	register int	i;

	if (pp) {
		for (i=0;i<pp->order+1;i++){
			if (i == 0 || pp->coeff[i] != 1.0)
				printf("%g", pp->coeff[i]);
			if (i == 1)
				printf("z");
			else if (i > 1)
				printf("z**%d",i);
			if (i != pp->order)
				printf(" + ");
		}
	} else
		printf("1");
}

/*
 *	Evaluate a polynomial (in Z) for any complex value of z.  If the
 *	polynomial is null then return 1.0.
 */
complex PolyEval(pp, x)
struct polynomial *pp;
complex	x;
{
	register int	i;
	complex xpow, y;

	if (!pp)
		return (cmplx(1.0,0.0));

	xpow = cmplx(1.0,0.0);
	y = cmplx(0.0,0.0);

	for (i=0;i<pp->order+1;i++){
		y = cadd(y,cmul(xpow,cmplx(pp->coeff[i],0.0)));
		xpow = cmul(xpow,x);
	}
	return(y);
}

/*
 *	MakeFilter - Create a filter from feed forward (zeros) and feedback
 *	(poles) polynomials.  The user specifies the sampling rate (after all
 *	we are in the z domain) and a frequency and desired gain at that 
 *	frequency.  The coefficients of all numerator terms are adjusted so
 *	that the filter has the proper gain.
 */
struct filter *MakeFilter(forward, feedback, fsamp, freq, gain)
struct polynomial *forward, *feedback;
float	fsamp, freq, gain;
{
	struct filter *fp;
	int	i;


#ifdef  DEBUG
	printf("MakeFilter called with (");
	PrintPolynomial(forward);
	printf(", ");
	PrintPolynomial(feedback);
	printf(", %g, %g, %g\n", fsamp, freq, gain);
#endif  /* DEBUG */


	fp = (struct filter *)calloc(1,sizeof(*fp));
	if (!fp){
		fprintf(stderr, 
		"MakeFilter: Couldn't allocate coefficient structure.\n");
		exit(1);
	}
	if (forward)
		fp->forward = forward;
	else
		fp->forward = forward = AllocatePolynomial(0);
	if (feedback)
		fp->feedback = feedback;
	else
		fp->feedback = feedback = AllocatePolynomial(0);
	fp->sample_rate = fsamp;
	fp->gain = gain;
	fp->freq = freq;
	gain = gain / cmag(FilterGain(fp,fp->freq));
	for (i=0;i<forward->order+1;i++)
		forward->coeff[i] *= gain;
	return(fp);
}

/*
 *	FilterEval - Evaluate the value of a filter function (ratio of 
 *	polynomials) at a given z.
 *
 *	We use the temporary variables a and b to make it simpler on the
 *	compiler.  At least two compilers I have tried this on (Cray and
 *	Mac MPW) can't handle the more direct approach.
 */
complex FilterEval(fp, z)
struct filter *fp;
complex	z;
{
	complex a,b;
	a = PolyEval(fp->forward,z);
	b = PolyEval(fp->feedback,z);
	return(cdiv(a,b));
}

/*	FilterGain - Evaluate the gain of a filter function (ratio of 
 *	polynomials in z) at a given frequency.
 */
complex FilterGain(fp, freq)
struct filter *fp;
float	freq;
{
	return(FilterEval(fp, cis(2*PI*freq/fp->sample_rate)));
}

complex	EvalZPolyDerivative(polyp, freq, sample_rate)
struct	polynomial *polyp;
float	freq, sample_rate;
{
	int	i;
	complex 	z, ZtotheN, result;

	if (polyp->order == 0){
		return(cmplx(0.0,0.0));
	} else {

		ZtotheN = cmplx(1.0,0.0);
		z = cis(freq/sample_rate*2*PI);
		result = cmplx(0.0,0.0);
		for (i=1;i<=polyp->order; i++){
			result = cadd(result,
				      cmul(cmplx(polyp->coeff[i]*i,0.0),
					   ZtotheN));
			ZtotheN = cmul(ZtotheN,z);
		}
		return(result);
	}
}

/*
 * 	FilterGroupDelay - This function computes the group delay of a 
 *		digital filter using the following expression from
 *		page 210 of Rabiner and Gold.  See page 112 of my Apple 
 *		1989/1990 log book for a more complete derivation.
 *						 |
 *			          [ z dH(z)/dz ] |
 *			tau = - Re[------------] |
 *				  [    H(z)    ] |    jw
 *						 | z=e
 *		Remember that the derivative of u/v is given by
 *				v du - u dv
 *				-----------
 *				    v v
 */

float	FilterGroupDelay(fp, freq, sample_rate)
struct filter *fp;
float	freq, sample_rate;
{
	complex	u, v, du, dv, z, h, hprime;

	z = cis(freq/sample_rate*2*PI);
	u = PolyEval(fp->forward,z);
	v = PolyEval(fp->feedback,z);
	du = EvalZPolyDerivative(fp->forward,freq,sample_rate);
	dv = EvalZPolyDerivative(fp->feedback,freq,sample_rate);

	h = cdiv(u,v);
	hprime = cdiv(csub(cmul(v,du),
			   cmul(u,dv)),
		      cmul(v,v));
	return -real(cdiv(cmul(z,hprime),
			 h));
}

/*
 *	FilterNumeratorCoeff - Return the i'th coefficient of the numerator
 *	of a filter.
 */
float
FilterNumeratorCoeff(fp,i)
struct filter *fp;
int	i;
{
	struct polynomial *pp;

	pp = fp->forward;
	if (i <= pp->order)
		return(pp->coeff[i]);
	else
		return(0.0);
}

/*
 *	FilterDenominatorCoeff - Return the i'th coefficient of the denominator
 *	of a filter.
 */
float
FilterDenominatorCoeff(fp,i)
struct filter *fp;
int	i;
{
	struct polynomial *pp;

	pp = fp->feedback;
	if (i <= pp->order)
		return(pp->coeff[i]);
	else
		return(0.0);
}

/*
 *	PrintFilter - Pretty print a filter structure.
 */
PrintFilter(fp)
struct filter *fp;
{
	float gain;

	printf("\t");
	PrintPolynomial(fp->forward);
	printf(" / ");
	PrintPolynomial(fp->feedback);
	printf("\n");
	printf("\tSampling rate of %g, desired gain is %g at %g hz.\n",
		fp->sample_rate, fp->gain, fp->freq);
	gain = cmag(FilterGain(fp, fp->freq));
	printf("\tActual gain is %g at %g.\n", gain, fp->freq);
}

/*
 *	The following is a bunch of parameters that describe the ear model.
 *	See the technical report for details and explanations.
 */
extern float EarBreakFreq;
extern float EarQ;
extern float EarStepFactor;
extern float EarZeroOffset;
extern float EarSharpness;
extern float EarPreemphCorner;

/*
 *	EarBandwidth - How wide are the poles of a stage in the ear filter.
 *	The result is in Hz.
 */
float EarBandwidth(cf)
float	cf;
{
	return(sqrt(cf*cf + EarBreakFreq*EarBreakFreq)/EarQ);
}
	
/*
 *	CascadeZeroCF - What frequency are the zeros at in a stage of the
 *	ear filter.  The result is a small factor of the step size between 
 *	channels (EarBandwidth * EarStepFactor)
 */
float CascadeZeroCF(cf)
float	cf;
{
	return( cf + EarBandwidth(cf) * EarStepFactor * EarZeroOffset);
}

/*
 *	CascadeZeroQ - What is the quality factor of a zero in a stage
 *	of the ear filter.
 */
float CascadeZeroQ(cf)
float	cf;
{
	return(EarSharpness * CascadeZeroCF(cf) / EarBandwidth(cf));
}

/*
 *	CascadePoleCF - What is the center frequency of the poles of each
 *	stage of the cascade filter bank?
 */
float CascadePoleCF(cf)
float	cf;
{
	return(cf);
}

/*
 *	CascadePoleQ - What is the quality factor of the poles?
 */
float CascadePoleQ(cf)
float	cf;
{
	return(cf / EarBandwidth(cf));
}

/* EpsilonFromTauFS
 *	Compute coefficient in follower-integrator filter (one minus pole)
 */

float EpsilonFromTauFS(tau, fs)
float	tau, fs;
{
	return (1.0 - exp(-1.0/tau/fs));
}

/* 
 *	FirstOrderFromTau - Polynomial coefficient list for first-order 
 *	pole or zero with time constant tau.
 */
struct polynomial *FirstOrderFromTau(tau, fs)
float	tau, fs;
{
	struct polynomial *pp = AllocatePolynomial(1);

	pp->coeff[0] = EpsilonFromTauFS(tau, fs) - 1.0;
	pp->coeff[1] = 1.0;
	return pp;
}

/* 
 *	FirstOrderFromCorner - Polynomial coefficient list for first-order 
 *	pole or zero with corner frequency fc.
 */
struct polynomial *FirstOrderFromCorner(fc, fs)
float	fc, fs;
{
	float fct, rho;
	struct polynomial *pp = AllocatePolynomial(1);

	fct = fc / fs;
	rho = exp(-2.0*PI*fct);
	pp->coeff[0] = - rho;
	pp->coeff[1] = 1.0;
	return(pp);
}

/* 
 *	SecondOrderFromCenterQ - Polynomail coefficient list for second-order 
 *	complex poles or zeros
 */
struct polynomial *SecondOrderFromCenterQ(NatFreq, q, fs)
float	NatFreq, q, fs;
{
	float cft, rho, theta;
	struct polynomial *pp = AllocatePolynomial(2);

	cft = NatFreq/fs;
	rho = exp(-PI * cft / q);
	theta = 2 * PI * cft * sqrt(1 - 0.25/q/q);
	pp->coeff[0] = rho*rho;
	pp->coeff[1] = -2.0 * rho * cos(theta);
	pp->coeff[2] = 1.0;
	return(pp);
}

/* 
 *	OuterMiddleEar - Create a filter that roughly models the effect of the
 *	outer and middle ears.  In this case it is just a simple high pass
 *	filter with a corner frequency given by EarPreemphCorner.
 */
struct filter *OuterMiddleEarFilter(fs)
float	fs;
{
	struct filter *fp;

	fp = MakeFilter(FirstOrderFromCorner(EarPreemphCorner, fs),
		        NULL,
		        fs,
		        fs/4.0,
		        1.0);
	return(fp);
}

/*
 *	EarFrontFilter - Create a filter to handle the initial processing
 *	before the cascade of filters.  This filter has the following terms
 *	1)	A zero at DC (differentiator) to model the conversion of 
 *		acoustic pressure into basilar membrane motion.
 *	2)	A zero at the Nyquist rate to compensate for the narrow
 *		spacing of channels at the high frequencies.
 *	3)	The first pair of poles from the cascade of ear filters.
 */
struct filter *EarFrontFilter(fs)
float	fs;
{
	struct filter *fp;
	struct polynomial *pp;

	pp = AllocatePolynomial(2);	/* Differentiator and Compensator */
	pp->coeff[0] = -1.0;
	pp->coeff[1] = 0.0;
	pp->coeff[2] = 1.0;

	fp = MakeFilter(pp,
			SecondOrderFromCenterQ(MaximumEarCF(fs),
					CascadePoleQ(MaximumEarCF(fs)),
					fs),
			fs,
			fs/4.0,
			1.0);
	return(fp);
}

/*
 *	EarStageFilter - OK, here it is....the definition of each stage of 
 *	the cascade-only filter bank.  Each stage is just a pair of poles
 *	and a pair of zeros.
 */
struct filter *EarStageFilter(cf,fs,DCGain)
float	fs, cf, DCGain;
{
	struct filter *fp;

	fp = MakeFilter(SecondOrderFromCenterQ(CascadeZeroCF(cf),
					CascadeZeroQ(cf),
					fs),
			SecondOrderFromCenterQ(CascadePoleCF(cf),
					CascadePoleQ(cf),
					fs),
		        fs,
		        0.0,
		        DCGain);
	return(fp);
}

!Funky!Stuff!
echo x - earfilters.c
cat >earfilters.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: earfilters.c,v 2.1 90/11/06 20:49:14 malcolm Exp $
 *
 * $Log:	earfilters.c,v $
 * Revision 2.1  90/11/06  20:49:14  malcolm
 * Removed all the type (sos or hydro) specific code from this file and
 * moved elsewhere.  Now all that remains are the calculations that
 * are independent of model type.
 * 
 * Revision 2.0  89/07/25  18:58:29  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.4  89/07/21  14:39:58  malcolm
 * Changed decimation filter code so that it creates a filter when the
 * decimation factor is greater than 0 (instead of 1.)  Thus df=1 gives
 * no decimation but do use a low pass decimation filter (with cutoff
 * given by taufactor) and df=0 means no decimation AND no filter.
 * 
 * Revision 1.3  88/11/04  16:57:19  malcolm
 * Took out extra arguments to the EARSTEP call.  Now everything is passwd
 * in external globals.
 * 
 * Revision 1.2  88/10/23  23:08:21  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:40:21  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: earfilters.c,v 2.1 90/11/06 20:49:14 malcolm Exp $";

/*
 *	The routines in this file implement the parts of the ear model cascade.
 *	These functions are used by both the second order section and the
 *	hydrodynamics models.  These are the common routines.
 */

#include	<stdio.h>
#include	<math.h>
#include	"ear.h"

/* SOS - Calculate a bunch of second order sections.
 *	y(n) = a0*x(n) + a1*x(n-1) + a2*x(n-2) - b1*y(n-1) - b2*y(n-2)
 *
 *	Both input and output can be the same vector of numbers.
 */
sos(input, state1, state2, a0, a1, a2, b1, b2, output, n)
float	input[], state1[], state2[], a0[], a1[], a2[], b1[], b2[], output[];
int	n;
{
	register int i;
	register float tempin;

#include	"ivdep.h"
	for (i=0;i<n;i++){
		tempin = input[i];
		output[i] = a0[i] * tempin                     + state1[i];
		state1[i] = a1[i] * tempin - b1[i] * output[i] + state2[i];
		state2[i] = a2[i] * tempin - b2[i] * output[i];
	}
}

hwr(input, output, n)
float input[], output[];
int	n;
{
	register int i;
	register float temp;

#include	"ivdep.h"
	for (i=0;i<n;i++){
		temp = input[i];
		if (temp < 0.0)
			output[i] = 0.0;
		else
			output[i] = temp;
	}
}

difference(input, output, n)
float	input[], output[];
int	n;
{
	register int i;

	for (i=n-1;i>0;i--){
		output[i] = input[i-1] - input[i];
	}
	output[0] = output[1];
}

fos(input, state, output, gain, n)
float	input[], state[], output[], gain;
int	n;
{
	register int i;
	register float OneMinusGain = 1.0 - gain;

#include	"ivdep.h"
	for (i=0;i<n;i++)
		state[i] = output[i] = gain*input[i] + OneMinusGain*state[i];
}

!Funky!Stuff!
echo x - fcor.f
cat >fcor.f <<'!Funky!Stuff!'
C 
C 			Lyon's Cochlear Model, The Program
C 	   			   Malcolm Slaney
C 			     Advanced Technology Group
C 				Apple Computer, Inc.
C 				 malcolm@apple.com
C 				   November 1988
C 
C 	This program implements a model of acoustic propagation and detection
C 	in the human cochlea.  This model was first described by Richard F.
C 	Lyon.  Please see 
C 		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
C 		Notebook," Apple Technical Report #13, 1988
C 	for more information.  This report is available from the Apple 
C 	Corporate Library.
C 
C 	Warranty Information
C 	Even though Apple has reviewed this software, Apple makes no warranty
C 	or representation, either express or implied, with respect to this
C 	software, its quality, accuracy, merchantability, or fitness for a 
C 	particular purpose.  As a result, this software is provided "as is,"
C 	and you, its user, are assuming the entire risk as to its quality
C 	and accuracy.
C 
C 	Copyright (c) 1988-1989 by Apple Computer, Inc
C 
C  $Header: fcor.f,v 2.2 90/12/17 18:01:01 malcolm Exp $
C 
C  $Log:	fcor.f,v $
c Revision 2.2  90/12/17  18:01:01  malcolm
c Removed ALIMIT subroutine definition.
c 
c Revision 2.1  89/11/09  23:15:37  malcolm
c Fixed minor problem in the test for zero data in the correlation output.
c 
c Revision 2.0  89/07/25  18:58:32  malcolm
c Completely debugged and tested version on the following machines (roughly
c in order of performance):
c Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
c both MPW and LightSpeed C.
c 
c Revision 1.4  89/07/19  17:01:49  malcolm
c Put autotasking code into comment.  Added alimit routine.  Also changed
c check for 0 to check for less than 1e-10.
c 
c Revision 1.1  88/10/23  22:40:39  malcolm
c Initial revision
c 
C 
C 
      subroutine fcor(input, output, window, work, lags, channels,
     1          datalength, fftlength, index, normalize)
      integer lags, datalength, fftlength, channels
      real input(datalength,channels), output(lags, channels)
      real window(datalength), normalize
      complex work(3*fftlength)
       
      complex fftdata(fftlength+1)
      integer channel, i, j
      real temp, firstreal, secondreal, firstim, secondim
      real firstscale, secondscale
      complex workx(3*fftlength)

      do 1 i=1,3*fftlength
    1   workx(i) = work(i)

c     do 5 i=1,datalength
c       input(i,21) = 1+sin(i*3.14159265/10.0)
c       input(i,22) = 0.0
c       input(i,23) = 1+sin(i*3.14159265/20.0)
c       input(i,24) = 0.0
c   5 continue

C	The CMIC$ directives enable microtasking of the loop.
C CMIC$ DO ALL PRIVATE(workx, fftdata, channel, i, j, temp, firstreal,
C      1               secondreal, firstim, secondim, firstscale,
C      2               secondscale)
CMIC$ DO GLOBAL
      do 100 channel = 1,channels,2
C                                       Fill the data into the fft arrrays
          do 5 i=index+1,datalength
              fftdata(i-index) = cmplx(input(i,channel),
     1                             input(i,channel+1))
    5     continue
          do 10 i=1,index
              fftdata(datalength-index+i) = cmplx(input(i,channel), 
     1                            input(i,channel+1))
   10     continue
C                                       Multiply by the window
          do 15 i=1,datalength
              fftdata(i) = fftdata(i) * window(i)
   15     continue
C                                       Zero pad the data
          do 20 i = datalength+1,fftlength
              fftdata(i) = cmplx(0.0,0.0)
   20     continue

          call cfft2(0,1,fftlength,fftdata,workx,fftdata)

          fftdata(fftlength+1) = fftdata(1)

CDIR$ IVDEP
          do 30, i=1,fftlength/2+1
              j = fftlength - i + 2
              firstreal = (real(fftdata(i))+real(fftdata(j)))/2.0
              firstim = (aimag(fftdata(i))-aimag(fftdata(j)))/2.0
              secondreal = (aimag(fftdata(i))+aimag(fftdata(j)))/2.0
              secondim = (real(fftdata(i))-real(fftdata(j)))/2.0

              firstmag = firstreal*firstreal + firstim*firstim
              secondmag = secondreal*secondreal + secondim*secondim

              fftdata(i) = cmplx(firstmag,secondmag)
              fftdata(j) = cmplx(firstmag,secondmag)
  30      continue

          call cfft2(0,-1,fftlength,fftdata,workx,fftdata)

C
C	The extra factor of fftlength is necessary to compensate for the
C	extra factors of N that are in the FFT.  We want to divide it out
C	before we do the normalize.
C
	  do 35 i=1,fftlength
	      fftdata(i) = fftdata(i)/fftlength
  35	  continue
        
C
C	Now figure out the scaling factor to use.  If the zero lag case is
C	too small or if it is less than the lag=1 and lag=2 case than we
C	we were probably correlating noise so we scale by zero.  Otherwise
C	we divide all terms of the correlation output by the zero lag term
C	raised to the normalize parameter.  The default value of this parameter
C	is .75 so there is some small compression going on.
C
          temp = real(fftdata(1))
          if (temp .le. 1.0e-10 .or.
     1        temp .lt. real(fftdata(2)) .or.
     2        temp .lt. real(fftdata(3))) then
              firstscale = 0.0
          else
	      firstscale = 1.0/(temp**normalize)
          endif

          temp = aimag(fftdata(1))
          if (temp .le. 1.0e-10 .or.
     1        temp .lt. aimag(fftdata(2)) .or.
     2        temp .lt. aimag(fftdata(3))) then
              secondscale = 0.0
          else
	      secondscale = 1.0/(temp**normalize)
          endif

C	Just for testing....
C         firstscale = 1.0
C         secondscale = 1.0
C
          do 40 i=1,lags
              output(i,channel) = real(fftdata(i)) * firstscale
              output(i,channel+1) = aimag(fftdata(i)) * secondscale
   40     continue
  100 continue

      return
      end

      function amax(array,n)
      integer i, n
      real array(n), amax
      i = ismax(n,array,1)
      amax = array(i)
      return
      end

      function amin(array,n)
      integer i, n
      real array(n), amin
      i = ismin(n,array,1)
      amin = array(i)
      return
      end

C
C	Simple vector move subroutine in fortran so that it will vectorize
C	on the Cray.
C
      subroutine vmov(source,sstride,n,dest,dstride)
      real source(*), dest(*)
      integer sstride, n, dstride
      integer i

      do 10 i=0,n-1
	 dest(i*dstride+1) = source(i*sstride+1)
   10 continue

      return
      end


!Funky!Stuff!
echo x - fear.f
cat >fear.f <<'!Funky!Stuff!'
C 
C 			Lyon's Cochlear Model, The Program
C 	   			   Malcolm Slaney
C 			     Advanced Technology Group
C 				Apple Computer, Inc.
C 				 malcolm@apple.com
C 				   November 1988
C 
C 	This program implements a model of acoustic propagation and detection
C 	in the human cochlea.  This model was first described by Richard F.
C 	Lyon.  Please see 
C 		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
C 		Notebook," Apple Technical Report #13, 1988
C 	for more information.  This report is available from the Apple 
C 	Corporate Library.
C 
C 	Warranty Information
C 	Even though Apple has reviewed this software, Apple makes no warranty
C 	or representation, either express or implied, with respect to this
C 	software, its quality, accuracy, merchantability, or fitness for a 
C 	particular purpose.  As a result, this software is provided "as is,"
C 	and you, its user, are assuming the entire risk as to its quality
C 	and accuracy.
C 
C 	Copyright (c) 1988-1990 by Apple Computer, Inc
C 
C  $Header: fear.f,v 2.2 90/12/17 18:01:20 malcolm Exp $
C 
C  $Log:	fear.f,v $
c Revision 2.2  90/12/17  18:01:20  malcolm
c Named the block data initialization so it wouldn't conflict with other
c block datas.
c 
c Revision 2.1  90/01/28  15:26:45  malcolm
c Moved the initialization of the "inited" flag into a Block Data
c subprogram so the Fortran is now legal.  Also increased the size
c of all the parameter arrays so that lower Q's and Stepfactor's can
c be used.
c 
c Revision 2.0  89/07/25  18:58:33  malcolm
c Completely debugged and tested version on the following machines (roughly
c in order of performance):
c Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
c both MPW and LightSpeed C.
c 
c Revision 1.6  89/04/09  17:00:51  malcolm
c Added function to return the normally hidden AGC state.  Also added
c support for decimation factor of 0 indicating no decimation and no
c filtering.
c 
c Revision 1.5  89/02/26  14:56:21  malcolm
c Fixed bugs at beginning and end of ear model.  Also made all ear 
c parameters saved variables.  Also added test if ear length is longer than
c the compiled constant.
c 
c Revision 1.4  88/12/06  21:13:22  malcolm
c Moved the vmov routine to the fcor.f file.
c 
c Revision 1.3  88/11/03  15:46:05  malcolm
c Speed hacks.  Moved all of the parameters to earstep into a common block.
c Moved the AGC parameter initialization code into the initialization 
c section of this routine.  Coalesced some loops to get the main loop down
c to 48us per iteration.
c 
c Revision 1.2  88/11/02  11:18:32  malcolm
c Added comments.  Note this version still has a constant size for the
c number of channels.  This is for efficiency but will fail if the 
c parameters of the ear model change.
c Also, added declarations for Sos3State and Sos4State.
c 
c Revision 1.1  88/10/23  22:40:48  malcolm
c Initial revision
c 
C 
C	This is a fortran version of the inner loop of the ear model.
C	This routine takes a single input value and produces an output
C	vector of length n.  
C	
C	The following flags are defined:
C	UseCascade - When non zero take the output of each stage and
C		use it as input to the next stage (i.e. make a cascade).
C		Otherwise each filter stage is independent and the same 
C		input value is applied to each stage in parallel.
C	UseAgc - When nonzero the normal AGC is used to adjust the gain
C		of each stage independently.  When zero there is no AGC
C		in the model.
C	ComputeFiltered - When non zero output the filtered version of the 
C		sound.  This is useful when trying to resynthesize the 
C		original sound based on what the output of the cochlea is.  
C		This flag is not available in the Fortran version of the ear 
C		model.
C	UseDifference - The response of this cochlea model is can be
C		sharpened by differentiating the output with respect to
C		cochlear position.  This is implemented by subtracting
C		adjacent channels when this flag is non zero.
C	DecimationFactor - This variable indicates the factor by which the
C		sample rate of the output of the cochlea model will be less
C		the sample rate of the incoming audio.  The EarStep routine 
C		uses this information to decide whether the output should be 
C		low pass filtered by a pair of first order filters.
C	a0, a1, a2, b1, b2 - These are arrays of parameter values for the
C		cascade of second order stages.  Each array contains a single
C		value of the appropriate parameter for each section of the 
C		cascade.  The use of each variable is shown in the figure
C		describing the implementation of a second order section in the
C		Mathematica notebook.
C	AgcEpsilon1-AgcEpsilon4 - Represent the decay times for each of the 
C		four AGC stages.
C	AgcStage1Target-AgcStage4Target - Are the target values for each of 
C		the four AGC stages.
C	DecimationEpsilon - This is the first order filter parameter used
C		to low pass filter the input before decimation.  Note this
C		routine doesn't actually perform the decimation.  This routine
C		low pass filters its output (if DecimationFactor is greater
C		than 1) and other code must select (sample) the output at the
C		appropriate times.
C 
      subroutine earstep(input, output)
C     parameter (n=88)
      parameter (n=120)
C	
C	The value of MaxN must be the same in this routine and again in
C	ear.h.  This sets up the definition of a common block that is shared
C	by C and Fortran.  If this number is wrong then data will be stuffed
C	into the wrong location.
C
      parameter (MaxN=180)
      integer UseCascade, UseAgc, ComputeFiltered, UseDifference
      integer DecimationFactor
      real input, output(MaxN)
      real a0(MaxN), a1(MaxN), a2(MaxN), b1(MaxN), b2(MaxN)
      real AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4
      real AgcStage1Target, AgcStage2Target
      real AgcStage3Target, AgcStage4Target
      real DecimationEpsilon

C
C	This common block must not change unless the corresponding
C	structure in utilities.c also changes.  We use this common
C	block to pass the global variables between C and Fortran
C	without doing it in a big function call or passing them with
C	every filter step.
C
      common /CBLOCK/ in, UseAgc, UseDifference, UseCascade, 
     1  ComputeFiltered, DecimationFactor, DecimationEpsilon,
     2  AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4,
     3  AgcStage1Target, AgcStage2Target, 
     4	AgcStage3Target, AgcStage4Target,
     5  a0, a1, a2, b1, b2


      integer i, inited
      real Sos1State(MaxN), Sos2State(MaxN)
      real Sos3State(MaxN), Sos4State(MaxN)
      real Agc1State(MaxN+2), Agc2State(MaxN+2), Agc3State(MaxN+2)
      real Agc4State(MaxN+2)
      real InputState(MaxN), DecimateState1(MaxN), DecimateState2(MaxN)
      real AgcTemp(n+2), oldinput(MaxN), temp(n+2)
      real OneMinusEpsOverThree1, EpsOverTarget1
      real OneMinusEpsOverThree2, EpsOverTarget2
      real OneMinusEpsOverThree3, EpsOverTarget3
      real OneMinusEpsOverThree4, EpsOverTarget4

      common /FSTATE/ inited, Sos1State, Sos2State, Agc1State, 
     1	Agc2State, Agc3State, Agc4State, InputState, DecimateState1, 
     2	DecimateState2, oldinput, OneMinusEpsOverThree1, EpsOverTarget1,
     3	OneMinusEpsOverThree2, EpsOverTarget2, OneMinusEpsOverThree3, 
     4	EpsOverTarget3, OneMinusEpsOverThree4, EpsOverTarget4

C
C	Vector Fortran Initializations.
C
      if (inited .eq. 0) then
	  Sos1State = 0.0
	  Sos2State = 0.0
	  Sos3State = 0.0
	  Sos4State = 0.0
	  Agc1State = 0.0
	  Agc2State = 0.0
	  Agc3State = 0.0
	  Agc4State = 0.0
	  DecimateState1 = 0.0
	  DecimateState2 = 0.0
	  InputState = 0.0
	  oldinput = 0.0
	  call INITCOM(in)

          if (in .gt. n) then
	    print *, 
     1       "Fortran routine can only compute ear model of length ", n
	    print *, "Need length ",in," to retain full accuracy."
	    endif

          OneMinusEpsOverThree1 = (1.0 - AgcEpsilon1)/3.0
          EpsOverTarget1 = AgcEpsilon1/AgcStage1Target
          OneMinusEpsOverThree2 = (1.0 - AgcEpsilon2)/3.0
          EpsOverTarget2 = AgcEpsilon2/AgcStage2Target
          OneMinusEpsOverThree3 = (1.0 - AgcEpsilon3)/3.0
          EpsOverTarget3 = AgcEpsilon3/AgcStage3Target
          OneMinusEpsOverThree4 = (1.0 - AgcEpsilon4)/3.0
          EpsOverTarget4 = AgcEpsilon4/AgcStage4Target

C         print *, in
C         print *, UseCascade, UseAgc, ComputeFiltered, UseDifference
C     	  print *, DecimationFactor
C     	  print *, input, output(1)
C     	  print *, "filters(1)", a0(1), a1(1), a2(1), b1(1), b2(1)
C     	  print *, "filters(2)", a0(2), a1(2), a2(2), b1(2), b2(2)
C     	  print *, AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4
C     	  print *, AgcStage1Target, AgcStage2Target
C     	  print *, AgcStage3Target, AgcStage4Target
C     	  print *, DecimationEpsilon
      endif
      inited = inited+1

      if (UseCascade .ne. 0) then
          do 10 i=n,2,-1
   10         InputState(i) = InputState(i-1)
          InputState(1) = input
      else
          do 20 i=1,n
   20         InputState(i) = input
      endif

      do 30 i=1,n
          t = InputState(i)
          InputState(i) = a0(i)*t                       + Sos1State(i)
          Sos1State(i) =  a1(i)*t - b1(i)*InputState(i) + Sos2State(i)
          Sos2State(i) =  a2(i)*t - b2(i)*InputState(i)
   30 continue

      if (UseAgc .ne. 0) then
          do 40 i=1,n
               output(i) = max(0.0,InputState(i))
   40     continue

C 	print *,inited,": output of sos ", output(42)

C	Note each AGC stage consists of three steps.  First we multiply
C	(attenuate) the signal by one minus the current state.  Then we
C	compute a new state by applying a first order filter to the weighted
C	average of the nearby states, then we limit the state to 1.  Note that
C	the actual limit step is done in a seperate loop (in the next stage)
C	because we don't want to overwrite the previous values until we have
C	done all of its neighbors.
C
C		AGC Stage 1
C
          Agc1State(1) = Agc1State(2)
          Agc1State(n+2) = Agc1State(n+1)
          do 150 i=1,n
              output(i) = (1.0 - Agc1State(i+1)) * output(i)
              temp(i+1) = output(i) * EpsOverTarget1 + 
     1                OneMinusEpsOverThree1 * 
     2                (Agc1State(i)+Agc1State(i+1)+Agc1State(i+2))
  150     continue

C 	print *,"output of first agc ", output(42)
C 	print *,"state of first agc ", temp(43)
C
C		AGC Stage 2
C
          Agc2State(1) = Agc2State(2)
          Agc2State(n+2) = Agc2State(n+1)
          do 250 i=1,n
              Agc1State(i+1) = min(1.0,temp(i+1))
              output(i) = (1.0 - Agc2State(i+1)) * output(i)
              temp(i+1) = output(i) * EpsOverTarget2 + 
     1                OneMinusEpsOverThree2 * 
     2                (Agc2State(i)+Agc2State(i+1)+Agc2State(i+2))
  250     continue

C 	print *,"second target2 is ",EpsOverTarget2
C 	print *,"second oneminuseps/3 is ", OneMinusEpsOverThree2
C 	print *,"output of second agc ", output(42)
C 	print *,"state of second agc ", temp(43)

C
C		AGC Stage 3
C
          Agc3State(1) = Agc3State(2)
          Agc3State(n+2) = Agc3State(n+1)
          do 350 i=1,n
              Agc2State(i+1) = min(1.0,temp(i+1))
              output(i) = (1.0 - Agc3State(i+1)) * output(i)
              temp(i+1) = output(i) * EpsOverTarget3 + 
     1                OneMinusEpsOverThree3 * 
     2                (Agc3State(i)+Agc3State(i+1)+Agc3State(i+2))
  350     continue

C 	print *,"output of third agc ", output(42)
C 	print *,"state of third agc ", temp(43)

C
C		AGC Stage 4
C
          Agc4State(1) = Agc4State(2)
          Agc4State(n+2) = Agc4State(n+1)
          do 450 i=1,n
              Agc3State(i+1) = min(1.0,temp(i+1))
              output(i) = (1.0 - Agc4State(i+1)) * output(i)
              temp(i+1) = output(i) * EpsOverTarget4 + 
     1                OneMinusEpsOverThree4 * 
     2                (Agc4State(i)+Agc4State(i+1)+Agc4State(i+2))
  450     continue

C 	print *,"output of fourth agc ", output(42)
C 	print *,"state of fourth agc ", temp(43)

          do 460 i=2,n+1
             Agc4State(i) = min(1.0,temp(i))
  460     continue
      else
          do 70 i=1,n
   70        output(i) = InputState(i)
      endif

      if (UseDifference .ne. 0) then
          do 80 i=2,n
             temp(i) = max(0.0,output(i-1) - output(i))
   80     continue
	  do 85 i=2,n
C	     oldinput(i) = output(i)
	     output(i) = temp(i)
   85     continue
          output(1) = output(2)
      endif

C
C	Low pass filter output before decimation.  This is implemented as two
C	first order filters.
C
      if (DecimationFactor .gt. 0) then
          OneMinusGain = 1.0 - DecimationEpsilon
          do 100 i=1,n+2
              output(i) = DecimationEpsilon*output(i) + 
     1                    OneMinusGain*DecimateState1(i)
              DecimateState1(i) = output(i)
              output(i) = DecimationEpsilon*output(i) + 
     1                    OneMinusGain*DecimateState2(i)
              DecimateState2(i) = output(i)
  100     continue
      endif

      return
      end

      function getagc(agc,channel)
      integer agc, channel

      parameter (MaxN=128)
      integer inited
      real Sos1State(MaxN), Sos2State(MaxN)
      real Sos3State(MaxN), Sos4State(MaxN)
      real Agc1State(MaxN+2), Agc2State(MaxN+2), Agc3State(MaxN+2)
      real Agc4State(MaxN+2)
      real InputState(MaxN), DecimateState1(MaxN), DecimateState2(MaxN)
      real oldinput(MaxN)
      real OneMinusEpsOverThree1, EpsOverTarget1
      real OneMinusEpsOverThree2, EpsOverTarget2
      real OneMinusEpsOverThree3, EpsOverTarget3
      real OneMinusEpsOverThree4, EpsOverTarget4

      common /FSTATE/ inited, Sos1State, Sos2State, Agc1State, 
     1	Agc2State, Agc3State, Agc4State, InputState, DecimateState1, 
     2	DecimateState2, oldinput, OneMinusEpsOverThree1, EpsOverTarget1,
     3	OneMinusEpsOverThree2, EpsOverTarget2, OneMinusEpsOverThree3, 
     4	EpsOverTarget3, OneMinusEpsOverThree4, EpsOverTarget4

      if (agc .eq. 1) then
	  getagc = Agc1State(channel+2)
      else if (agc .eq. 2) then
	  getagc = Agc2State(channel+2)
      else if (agc .eq. 3) then
	  getagc = Agc3State(channel+2)
      else if (agc .eq. 4) then
	  getagc = Agc4State(channel+2)
      else
	  getagc = 0
      endif
      return
      end

      block data EarState
      common /FSTATE/ inited, Sos1State, Sos2State, Agc1State, 
     1	Agc2State, Agc3State, Agc4State, InputState, DecimateState1, 
     2	DecimateState2, oldinput, OneMinusEpsOverThree1, EpsOverTarget1,
     3	OneMinusEpsOverThree2, EpsOverTarget2, OneMinusEpsOverThree3, 
     4	EpsOverTarget3, OneMinusEpsOverThree4, EpsOverTarget4

      data inited/0/
      end
!Funky!Stuff!
echo x - fft.c
cat >fft.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: fft.c,v 2.3 90/12/17 18:01:40 malcolm Exp $
 *
 * $Log:	fft.c,v $
 * Revision 2.3  90/12/17  18:01:40  malcolm
 * Added PowerOfTwoGreaterThan function and cleaned up the test program.
 * 
 * Revision 2.2  90/11/06  20:50:09  malcolm
 * Changed copyright message.
 * 
 * Revision 2.1  90/01/28  15:38:43  malcolm
 * Changed storage allocation functions to use NewFloatArray().
 * 
 * Revision 2.0  89/07/25  18:58:35  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.4  89/07/19  12:42:40  malcolm
 * Cleaned up line breaks in the code.
 * 
 * Revision 1.3  88/12/06  21:13:40  malcolm
 * Added test code.
 * 
 * Revision 1.2  88/10/23  23:08:28  malcolm
 * Made compatible with ANSI C (removed pragma's and endif comments).
 * 
 * Revision 1.1  88/10/23  22:41:02  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: fft.c,v 2.3 90/12/17 18:01:40 malcolm Exp $";

#include	<math.h>
#include	"timer.h"

PowerOfTwoGreaterThan(i)
int	i;
{
	int	j;

	for (j=0;(1<<j) < i;j++)
		;

	return j;
}

#ifndef	CRAY

float *
initfft(size)
int	size;
{
	return((float *) 0);
}

/*
	fft - calculate FFT

	Carl Crawford
	Purdue University
	W. Lafayette, IN. 47907

	Calling Sequence....fft(real,im,m,iopt)
	Where real and im are the real and imaginary
	parts of the input data.  The result is
	returned in place.  M is the log base 2
	of the number of elements in the array.
	Iopt is equal to 0 for the forward
	transform and 1 for the inverse transform.
*/
fft(a,b,m,iopt)
	float	a[];	/* real part of data */
	float	b[];	/* imaginary part of data */
	int	m;	/* size of data = 2**m */
	int	iopt;	/* 0=dft, 1=idft */
{
	int	nv2,nm1,n,le,le1,ip;
	float   pi,pile1,tmp;
	float	ua,ub,wa,wb,ta,tb,*ap,*bp;
	register	i,j,l;

	n = 1<<m;
	if(iopt){
		for(i=0,ap=a,bp=b;i<n;i++){
			*ap++ /= n;
			*bp++ /= -n;
		}
	}
	nv2 = n/2;
	nm1 = n - 1;
	j = 0;
	for(i=0;i<nm1;i++){
		if(i<j){
			ta = a[j];	tb = b[j];
			a[j] = a[i];	b[j] = b[i];
			a[i] = ta;	b[i] = tb;
		}
		l = nv2;
		while(l < (j+1) ){
			j = j - l;
			l = l / 2;
		}
		j = j + l;
	}
	pi = 3.1415926535;
	for(l=1;l<=m;l++){
		le = 1<<l;
		le1 = le>>1;
		ua = 1.0;	ub = 0.0;
		pile1 = pi / le1;
		wa = cos(pile1);	wb = -sin(pile1);
		for(j=0;j<le1;j++){
			for(i=j;i<n;i += le){
				ip = i + le1;
				ta = a[ip] * ua - b[ip] * ub;
				tb = a[ip] * ub + b[ip] * ua;
				a[ip] = a[i] - ta;
				b[ip] = b[i] - tb;
				a[i] += ta;
				b[i] += tb;
			}
			ua = (tmp = ua) * wa - ub * wb;
			ub = tmp * wb + ub * wa;
		}
	}
						/* For the inverse transform
						 * scale the result by N
						 */
	if(iopt != 0){
		for(i=0;i<n;i++)
			b[i] = -b[i];
	}
}

#else CRAY


static	LastSize = 0;
static	float	*LastWork = 0, *LastInput = 0;

float	*initfft(Size)
int	Size;
{
	int	Init;
	float	*NewFloatArray();

	if (Size > LastSize){
		if (LastWork)
			free(LastWork);
		LastWork = NewFloatArray((long)3*Size*2,"initfft");

		if (LastInput)
			free(LastInput);
		LastInput = NewFloatArray((long)Size*2,"initfft");

		LastSize = Size;
		Init = 1;
		printf("Initing the FFT for size %d.\n", Size);
		CFFT2(&Init, &Init, &Size, LastInput, LastWork, LastInput);
	}

	return(LastWork);
}


fft(a,b,m,iopt)
	float	a[];	/* real part of data */
	float	b[];	/* imaginary part of data */
	int	m;	/* size of data = 2**m */
	int	iopt;	/* 0=dft, 1=idft */
{
	int	Size, Init, i;

	Size = 1<<m;
	initfft(Size);

	if (iopt){
#include	"ivdep.h"
		for (i=0;i<Size;i++) {
			LastInput[2*i] = a[i]/Size;
			LastInput[2*i+1] = b[i]/Size;
		}
	} else {
#include	"ivdep.h"
		for (i=0;i<Size;i++) {
			LastInput[2*i] = a[i];
			LastInput[2*i+1] = b[i];
		}
	}

	if (iopt)
		iopt = -1;
	else
		iopt = 1;

	Init = 0;
	starttimer(5);
	CFFT2(&Init, &iopt, &Size, LastInput, LastWork, LastInput);
	endtimer(5);

#include	"ivdep.h"
	for (i=0;i<Size;i++) {
		a[i] = LastInput[2*i];
		b[i] = LastInput[2*i+1];
	}
}
#endif

#ifdef	MAIN

#define	N	16
#define	logN	4

float	a[N], b[N];
char	*progname = "FFT Test Program";

main(){
	int	i;

	a[1] = 1.0;
	a[N-1] = 1.0;

	printf("First the input data (real, imaginary)\n");
	for (i=0;i<N;i++)
		printf("%d:	%g	%g\n", i, a[i], b[i]);
	fft(a,b,logN,1);

	printf("Here's the FFT of it (real, imaginary)\n");
	for (i=0;i<N;i++)
		printf("%d:	%g	%g\n", i, a[i], b[i]);

	fft(a,b,logN,0);
	printf("Finally, here's the inverse FFT (hould  be same as first)\n");
	for (i=0;i<N;i++)
		printf("%d:	%g	%g\n", i, a[i], b[i]);
}
#endif	/* MAIN */
!Funky!Stuff!
echo x - file.c
cat >file.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1991 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: file.c,v 2.8 91/02/20 17:32:14 malcolm Exp $
 *
 * $Log:	file.c,v $
 * Revision 2.8  91/02/20  17:32:14  malcolm
 * ARRRGGGHHH.....D*mn Lightspeed C compiler was converting 0x80 into
 * unsigned integers which then broke the ReadByteFile routine.  Changed
 * Hex constants to Decimal and now code works on LightSpeed (Macintosh).
 * 
 * Revision 2.7  91/01/09  15:44:38  malcolm
 * Added support (untested though) for GW Instruments MacSpeech format.
 * 
 * Revision 2.6  90/11/08  08:26:03  malcolm
 * Fixed code for ConvertToIeeeExtended and WriteAiffFile.  Neither routine
 * was anywhere close to being correct.
 * 
 * Revision 2.5  90/11/07  08:53:28  malcolm
 * Added IRCAM file support.  This is a machine dependent file format (ick).
 * Also changed fileAbort to take more arguments.
 * 
 * Revision 2.4  90/11/06  20:50:38  malcolm
 * Added binary float and IEEE floating point support.  Also added support
 * for the Entropic and the AIFF file formats.
 * 
 * Revision 2.3  90/08/25  15:39:28  malcolm
 * Added first attempt at supporting the Entropic/Waves file format.  This
 * code isn't working yet.
 * 
 * Also added better support of Ieee floating point format.  This code
 * should work for all numbers but those that are close to the minimum
 * and maximum that can be expressed with IEEE.
 * 
 * Revision 2.2  90/01/28  15:28:57  malcolm
 * Fixed some printfs.   Also use the new NewFloatArray routine to allocate
 * all array storage.  Fixed call to ReadWavFile to remove extra parameter
 * (Thanks to Robert E. Novak at MIPs/SPEC.)
 * 
 * Revision 2.1  89/11/09  23:10:50  malcolm
 * Fixed some error messages so they referenced the correct routine.
 * 
 * Revision 2.0.1.2  89/08/10  22:14:11  malcolm
 * David Mellinger's (CCRMA@Stanford) fixes.  Added support for Dyaxis and
 * NeXT input formats.  Also added MaxSamples parameter to limit input
 * data.
 * 
 * Revision 2.0.1.1  89/07/28  21:33:02  malcolm
 * Added a missing fclose after reading in an ADC file.
 * 
 * Revision 2.0  89/07/25  18:58:36  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.8  89/07/19  12:48:00  malcolm
 * Fixed infinite loop bug in the code that finishes reading the header
 * words.
 * 
 * Revision 1.7  89/06/21  11:08:09  malcolm
 * Just a couple of small bug fixes for ADC files and LightSpeed C.
 * 
 * Revision 1.6  89/06/20  22:45:28  malcolm
 * Added support (int32 type) for LightSpeed C.
 * 
 * Revision 1.5  89/04/09  16:59:47  malcolm
 * Added support for writing ADC files (used by other programs) and reading
 * data files (.fl suffix) with native floating point format.  Also changed
 * MacRecorder sample rate to be 22254.545454...as per the Macintosh spec.
 * 
 * Revision 1.4  89/02/24  22:57:40  malcolm
 * Made compatible with Lightspeed C for the Macintosh.
 * 
 * Revision 1.3  88/12/04  17:38:25  malcolm
 * Added support for ADC files and choosing the input style based on the 
 * file suffix.
 * 
 * Revision 1.2  88/11/29  00:42:48  malcolm
 * Added support for Macintosh MacRecorder 8 bit files.
 * 
 * Revision 1.1  88/10/23  22:41:12  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: file.c,v 2.8 91/02/20 17:32:14 malcolm Exp $";


/*
 *	This file reads the input speech data in a number of different formats.
 *	
 *	Note: Motorola processors (Macintosh, Sun, Sparc, etc) places the
 *		bytes in the word from high to low (they are big-endian).
 *		Use the HighLow routines to match the native format of these
 *		machines.
 *	
 *	Note: Intel-like machines (PCs, Sequent) use little-endian format.
 *		Use the LowHigh routines for these machines.
 */

#include	<stdio.h>
#include	<math.h>
#ifdef	PLAY

int     MaxSamples = -1;
float   InputGain = 1;

#ifdef  LSC
typedef long int32;
#else
typedef int int32;
#endif

float	*
NewFloatArray(size,usage)
int32	size;
char	*usage;
{
	float	*p;

	p = (float *)calloc(sizeof(*p),size);
	if (!p){
		fprintf(stderr,"NewFloatArray: Can't allocate %ld floats.\n", 
			size);
		exit(1);
	}
	return p;
}

#else
#include	"ear.h"
#endif	/* PLAY */


ReadByte(fp)
FILE	*fp;
{
	int	result;
	
	result = getc(fp) & 0xff;
	if (result & 0x80)
		result = result - 0x100;
	return result;
}

Read16BitsLowHigh(fp)
FILE	*fp;
{
	int	first, second, result;

	first = 0xff & getc(fp);
	second = 0xff & getc(fp);

	result = (second << 8) + first;
#ifndef	THINK_C
	if (result & 0x8000)
		result = result - 0x10000;
#endif
	return(result);
}

Read16BitsHighLow(fp)
FILE	*fp;
{
	int	first, second, result;

	first = 0xff & getc(fp);
	second = 0xff & getc(fp);

	result = (first << 8) + second;
#ifndef	THINK_C
	if (result & 0x8000)
		result = result - 0x10000;
#endif
	return(result);
}

Write8Bits(fp,i)
FILE	*fp;
int	i;
{
	putc(i&0xff,fp);
}

Write16BitsLowHigh(fp,i)
FILE	*fp;
int	i;
{
	putc(i&0xff,fp);
	putc((i>>8)&0xff,fp);
}

Write16BitsHighLow(fp,i)
FILE	*fp;
int	i;
{
	putc((i>>8)&0xff,fp);
	putc(i&0xff,fp);
}

int32 Read24BitsHighLow(fp)
FILE	*fp;
{
	int	first, second, third;
	int32	result;

	first = 0xff & getc(fp);
	second = 0xff & getc(fp);
	third = 0xff & getc(fp);

	result = (first << 16) + (second << 8) + third;
	if (result & 0x800000)
		result = result - 0x1000000;
	return(result);
}

#define	Read32BitsLowHigh(f)	Read32Bits(f)

int32
Read32Bits(fp)
FILE	*fp;
{
	int32	first, second, result;

	first = 0xffff & Read16BitsLowHigh(fp);
	second = 0xffff & Read16BitsLowHigh(fp);

	result = (second << 16) + first;
#ifdef	CRAY
	if (result & 0x80000000)
		result = result - 0x100000000;
#endif
	return(result);
}
	
int32
Read32BitsHighLow(fp)
FILE	*fp;
{
	int32	first, second, result;

	first = 0xffff & Read16BitsHighLow(fp);
	second = 0xffff & Read16BitsHighLow(fp);

	result = (first << 16) + second;
#ifdef	CRAY
	if (result & 0x80000000)
		result = result - 0x100000000;
#endif
	return(result);
}
	
Write32Bits(fp,i)
long	i;
FILE	*fp;
{
	Write16BitsLowHigh(fp,(int)(i&0xffffL));
	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
}

Write32BitsLowHigh(fp,i)
long	i;
FILE	*fp;
{
	Write16BitsLowHigh(fp,(int32)(i&0xffffL));
	Write16BitsLowHigh(fp,(int32)((i>>16)&0xffffL));
}

Write32BitsHighLow(fp,i)
long	i;
FILE	*fp;
{
	Write16BitsHighLow(fp,(int32)((i>>16)&0xffffL));
	Write16BitsHighLow(fp,(int32)(i&0xffffL));
}

float *
ReadADCFile(FileName, SamplingRate, Length)
char	*FileName;
float	*SamplingRate;
int32	*Length;
{
	register int32	i, SampleTime, n, HeaderSize;
	float	*Data;
	FILE	*fp;

	fp = fopen(FileName, "r");
	if (!fp){
		fprintf(stderr, "ReadADCFile: Couldn't open %s for reading.\n",
			FileName);
		exit(1);
	}

	HeaderSize = Read16BitsLowHigh(fp);
	HeaderSize--;
	Read16BitsLowHigh(fp);				/* Version Number */
	HeaderSize--;
	Read16BitsLowHigh(fp);				/* Channels */
	HeaderSize--;
	SampleTime = Read16BitsLowHigh(fp);
	HeaderSize--;
	n = Read32Bits(fp);
	if (MaxSamples >= 0 && n > MaxSamples) n = MaxSamples;
	HeaderSize -= 2;
	while (HeaderSize > 0){
		Read16BitsLowHigh(fp);
		HeaderSize--;
	}
	*SamplingRate = 4.0e6 / SampleTime;

	fprintf(stderr,
		"Reading %ld samples from %s with sampling rate of %g.\n", 
		(long)n, FileName, *SamplingRate);
	Data = NewFloatArray((int32) n, "ReadADCFile");
			
	for (i=0;i<n;i++)
		Data[i] = Read16BitsLowHigh(fp)/65536.0*16*InputGain;
	
	*Length = i;
	fclose(fp);
	
	return(Data);
}

WriteADCFile(FileName, SamplingRate, Length, Data)
char	*FileName;
float	SamplingRate;
int32	Length;
float	*Data;
{
	register int32	i;
	FILE	*fp;
	float	Max;

	if (FileName[0] == '-' && FileName[1] == '\0')
		fp = stdout;
	else
		fp = fopen(FileName, "w");

	if (!fp){
		fprintf(stderr, "WriteADCFile: Couldn't open %s for writing.\n",
			FileName);
		exit(1);
	}

	Write16BitsLowHigh(fp,6);
	Write16BitsLowHigh(fp,0);
	Write16BitsLowHigh(fp,1);
	Write16BitsLowHigh(fp,(int) (4.0e6/SamplingRate));
	Write32Bits(fp,(long) Length);

	Max = Data[0];
	for (i=1;i<Length;i++)
		if (Data[i] > Max)
			Max = Data[i];
	Max *= 10.0;

	fprintf(stderr,"Writing %s with sample rate %f and length %ld.\n",
		FileName, SamplingRate, Length);
	fprintf(stderr," Maximum value of file is %g.\n", Max);

	Max = ((1<<12)-1)/Max;
	for (i=0;i<Length;i++)
		Write16BitsLowHigh(fp,(int)(Data[i]*Max));
	
	fclose(fp);
}

float *
ReadDACFile(FileName, SamplingRate, Length)
char	*FileName;
float	*SamplingRate;
int32	*Length;
{
	register int32	i, SampleTime, n, HeaderSize;
	float	*Data;
	FILE	*fp;

	fp = fopen(FileName, "r");
	if (!fp){
		fprintf(stderr, "ReadADCFile: Couldn't open %s for reading.\n",
			FileName);
		exit(1);
	}

	HeaderSize = Read16BitsHighLow(fp);
	HeaderSize--;
	Read16BitsHighLow(fp);				/* Version Number */
	HeaderSize--;
	Read16BitsHighLow(fp);				/* Channels */
	HeaderSize--;
	SampleTime = Read16BitsHighLow(fp);
	HeaderSize--;
	n = Read32BitsHighLow(fp);
	if (MaxSamples >= 0 && n > MaxSamples) n = MaxSamples;
	HeaderSize -= 2;
	while (HeaderSize > 0){
		Read16BitsHighLow(fp);
		HeaderSize--;
	}
	*SamplingRate = 4.0e6 / SampleTime;

	fprintf(stderr,
		"Reading %ld samples from %s with sampling rate of %g.\n", 
		(long)n, FileName, *SamplingRate);
	Data = NewFloatArray((int32) n, "ReadADCFile");
			
	for (i=0;i<n;i++)
		Data[i] = Read16BitsHighLow(fp)/65536.0*16*InputGain;
	
	*Length = i;
	fclose(fp);
	
	return(Data);
}

int32
FileLength(fp)
FILE	*fp;
{
	int	pos, end;

	pos = ftell(fp);
	fseek(fp, 0L, 2);
	end = ftell(fp);
	fseek(fp,pos,0);
	return(end);
}

float *
ReadWavFile(FileName, Length)
char	*FileName;
int32	*Length;
{
	register int32	i;
	float	*Data;
	FILE	*fp;

	fp = fopen(FileName, "r");
	if (!fp){
		fprintf(stderr, "ReadWavFile: Couldn't open %s for reading.\n",
			FileName);
		exit(1);
	}

	*Length = FileLength(fp)/2;
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;

	Data = NewFloatArray((int32) *Length, "ReadWavFile");
	
	for (i=0;i<*Length;i++)
		Data[i] = Read16BitsLowHigh(fp)/32768.0*InputGain;
	
	return(Data);
}


float *
ReadByteFile(FileName, Length)
char	*FileName;
int32	*Length;
{
	register int	i;
	float	*Data;
	FILE	*fp;

	fp = fopen(FileName, "r");
	if (!fp){
		fprintf(stderr, "ReadByteFile: Couldn't open %s for reading.\n",
			FileName);
		exit(1);
	}

	*Length = FileLength(fp);
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;

	Data = NewFloatArray((int32) *Length, "ReadByteFile");
	
	for (i=0;i<*Length;i++){
		Data[i] = (((int)getc(fp) & 255) - 128)/128.0*InputGain;
	}
	
	return(Data);
}

WriteByteFile(FileName, Length, Data)
char	*FileName;
int32	Length;
float	*Data;
{
	register int32	i;
	FILE	*fp;
	float	Max;

	fp = fopen(FileName, "w");
	if (!fp){
		fprintf(stderr, "WriteByteFile: Couldn't open %s for writing.\n",
			FileName);
		exit(1);
	}

	Max = Data[0];
	for (i=1;i<Length;i++)
		if (Data[i] > Max)
			Max = Data[i];

	fprintf(stderr,"Writing byte file %s with length %ld.\n",
		FileName, Length);
	fprintf(stderr," Maximum value of file is %g.\n", Max);

	Max = 127/Max;
	for (i=0;i<Length;i++)
		putc((int)(Data[i]*Max)+128,fp);
	
	fclose(fp);
}

/* Dyaxis file: 512-byte header, 16-bit stereo interleaved samples
 * with left channel first.  Each sample has high byte first.
 */
float *ReadDyaxisFile(FileName, Length)
char	*FileName;
int	*Length;
{
	register int	i;
	float	*Data;
	FILE	*fp;
	long len;

	fp = fopen(FileName, "r");
	if (!fp){
	    fprintf(stderr, "ReadDyaxisFile: Couldn't open %s for reading.\n",
		    FileName);
	    exit(1);
	}

	len = FileLength(fp);		/* length in bytes */
	*Length = (len ) / 2;		/* left-channel samples in file */
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;
	
	Data = NewFloatArray((int32) *Length, "ReadDyaxisFile");
	
	for (i=0;i<*Length;i++) {
	    Data[i] = Read16BitsHighLow(fp)/32768.0*InputGain;	/* left */
/*	    Read16BitsHighLow(fp);			   right (ignored) */
	}
	
	return(Data);
}

/* NeXT file: Variable-length header, then 16-bit samples (interleaved
 * if stereo).
 */
float *ReadNeXTFile(FileName, Length, SamplingRate)
char *FileName;
int *Length;
float *SamplingRate;
{
	register int	i, stereo;
	float	*Data;
	FILE	*fp;
	struct {
		char suffix[4];		/* ".snd" */
		long hdr_len,		/* header length following ".snd" */
			data_len,		/* data len, in bytes */
			mode,			/* 3 ==> 16-bit linear */
			srate,
			nChannels;		/* 1 for mono, 2 for stereo */
	} header;

	fp = fopen(FileName, "r");
	if (!fp) 
		fileAbort("Couldn't open %s for reading.\n", FileName);
	if (fread(&header, sizeof(header), 1, fp) != 1)
		fileAbort("Can't read header of %s.\n", FileName);
	if (header.mode != 3) 
		    fileAbort("Sound file %s is not 16-bit linear (mode 3).\n", 
			FileName);
	fseek(fp, header.hdr_len + 4, 0);	/* skip comment */

	*SamplingRate = header.srate;
	stereo = (header.nChannels == 2);
	*Length = header.data_len / 2;	
	if (stereo) *Length /= 2;
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;
	
	Data = NewFloatArray((int32) *Length, "ReadNeXTFile");
	
	for (i = 0; i < *Length; i++) {
	    Data[i] = Read16BitsHighLow(fp) / 32768.0*InputGain;/* left */
	    if (stereo) Read16BitsHighLow(fp);		/* right (ignored) */
	}
	
	return Data;
}

/* IRCAM file: 1024-byte  header, then 16-bit samples (interleaved
 * if stereo).
 */

#define IRCAM_HEADER_SIZE	1024
#define IRCAM_MAGIC_NUMBER	0x0001A364L

float *ReadIRCAMFile(FileName, Length, SamplingRate)
char *FileName;
int *Length;
float *SamplingRate;
{
        register int    i, stereo;
        float   *Data;
        FILE    *fp;
        struct {
                int32	sf_magic;     /* = 107364L */
                float	sf_srate;     /* float samrate in Hz */
                int32	sf_chans;     /* 1=mono, 2=stereo */
                int32	sf_packmode;  /* 2 = 16 bit, 4 = float */
        /*	char	sf_codes;     /* ignore */
        } header;

        fp = fopen(FileName, "r");
        if (!fp) 
	  fileAbort("Couldn't open %s for reading.\n", FileName);
	
	if (fread(&header, sizeof(header), 1, fp) != 1)
	  fileAbort("Could not read header bytes of file %s.", FileName);

	
	/* Check some parameters */

/*
	printf("magic = %lX\nrate = %f\nchans = %lu\npackmode = %lu\n",
	       header.sf_magic,
	       header.sf_srate,
	       header.sf_chans,
	       header.sf_packmode);
 */
	

	if (header.sf_magic != IRCAM_MAGIC_NUMBER)
	  fileAbort("Sound file %s has a magic number of %lX, but expected %lX\n",
		    FileName,
		    header.sf_magic,
		    IRCAM_MAGIC_NUMBER);
	if ((header.sf_srate < 4500) || (header.sf_srate > 100000))
	  fileAbort("Sound file %s has an unreasonable sample rate (%fHz).\n",
		    FileName,
		    header.sf_srate);
	if ((header.sf_chans != 1) && (header.sf_chans != 2))
	  fileAbort("Sound file %s does not have 1 channel (channels=%lu).\n",
		    FileName,
		    header.sf_chans);
        if ((header.sf_packmode != 2) && (header.sf_packmode != 4)) 
	  fileAbort("Sound file %s has an unexpected packmode (%ld).\n", 
                        FileName);


	/* skip header block */

        fseek(fp, IRCAM_HEADER_SIZE, 0);

	/* Set return values */

        *SamplingRate = header.sf_srate;

        *Length = FileLength(fp) / header.sf_packmode / header.sf_chans;   

        if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;
        
        Data = NewFloatArray((int32) *Length * header.sf_chans, "ReadIRCAMFile");
        
	if (header.sf_packmode == 2)
	  {
	    register float factor;
	    int result;

	    factor = InputGain / 32768.0;

	    result = fread(&Data[0],
			   sizeof(short),
			   *Length * header.sf_chans,
			   fp);

	    for (i = (*Length * header.sf_chans) - 1; i >= 0; i--)
	      {
		Data[i] = ((short*)Data)[i] * factor;
	      }
	  }
	else
	  {
	    register float factor;
	    int result;

	    factor = InputGain / 32768.0;

	    result = fread(&Data[0],
			   sizeof(float),
			   *Length * header.sf_chans,
			   fp);
 
	    for (i = result-1; i >= 0; i--)
	      {
		Data[i] *= factor;
	      }
	  }
	    
        
        return Data;
}


fileAbort(str, arg1, arg2, arg3, arg4)
char *str, *arg1, *arg2, *arg3, *arg4;
{
	fprintf(stderr, "Reading data file: ");
	fprintf(stderr, str, arg1, arg2, arg3, arg4);
	exit(1);
}
	
float *
ReadNativeFloatFile(FileName, Length)
char	*FileName;
int32	*Length;
{
	float	*Data;
	FILE	*fp;

	fp = fopen(FileName, "r");
	if (!fp){
		fprintf(stderr, "ReadNativeFloatFile: Couldn't open %s for reading.\n",
			FileName);
		exit(1);
	}

	*Length = FileLength(fp)/sizeof(float);
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;

	Data = NewFloatArray((int32) *Length, "ReadNativeFloatFile");
	
	fread(Data,sizeof(float),*Length,fp);
	
	return(Data);
}

float	ReadIeeeFloatLowHigh(fp)
FILE	*fp;
{
	int32	bits;
	float	ConvertIeeeToFloat();

	bits = Read32BitsLowHigh(fp);
	return ConvertIeeeToFloat(bits);
}

float	ReadIeeeFloatHighLow(fp)
FILE	*fp;
{
	int32	bits;
	float	ConvertIeeeToFloat();

	bits = Read32BitsHighLow(fp);
	return ConvertIeeeToFloat(bits);
}

float	ConvertIeeeToFloat(bits)
int32	bits;
{
	float	f;
	int32	mantissa, expon;

	if (bits == 0)
		return 0.0;

	mantissa = (bits & 0x7fffff) + 0x800000;
	expon = (bits & 0x7f800000) >> 23;
	expon -= 127;

	f = (float)mantissa/(float)0x8000000 * exp(expon*log(2.0));
	if (bits & 0x80000000)
		return -f;
	else
		return f;
}

float	ReadIeeeExtendedHighLow(fp)
FILE	*fp;
{
	unsigned int	first, second, third, fourth, fifth;
	float	ConvertIeeeExtendedToFloat();

	first = Read16BitsHighLow(fp);
	second = Read16BitsHighLow(fp);
	third = Read16BitsHighLow(fp);
	fourth = Read16BitsHighLow(fp);
	fifth = Read16BitsHighLow(fp);

	return ConvertIeeeExtendedToFloat(first, second, third, fourth, fifth);
}

float	ConvertIeeeExtendedToFloat(first, second, third, fourth, fifth)
unsigned int	first, second, third, fourth, fifth;
{
	float	f, expfactor;
	int32	expon;

	first &= 0xffff;
	second &= 0xffff;
	third &= 0xffff;
	fourth &= 0xffff;
	fifth &= 0xffff;

	if (!first && !second && !third && !fourth && !fifth)
		return 0.0;

	expon = (first & 0x7fff);
	expon -= 16383;

	expfactor = exp(expon*log(2.0));
	f = (float)second/(float)0x8000 * expfactor;
	f += (float)third/(float)0x10000 * (expfactor /= 0x10000);
	f += (float)fourth/(float)0x10000 * (expfactor /= 0x10000);
	f += (float)fifth/(float)0x10000 * (expfactor /= 0x10000);

	if (first & 0x8000)
		return -f;
	else
		return f;
}

int32 ConvertToIeee(num)
float	num;
{
	int32	sign, bits, mantissa, expon;

	if (num < 0) {
		sign = 0x80000000;
		num *= -1;
	} else {
		sign = 0;
	}

	if (num == 0){
		bits = 0;
	} else {
		expon = floor(log(num)/log(2.0));
		if (expon < -126) {
			expon = 1;
			mantissa = 0;
		} else if (expon > 128){
			expon = 255;
			mantissa = 0x7fffff;
		} else {
			mantissa = floor((num/pow(2.0,(float)expon)-1)
					*0x800000+.5);
			expon += 127;
		}
	}

	bits = sign | (expon << 23) | mantissa;
	return bits;
}

float	WriteIeeeFloatLowHigh(fp, num)
FILE	*fp;
float	num;
{
	int32	bits;
	
	bits = ConvertToIeee(num);
	Write32BitsLowHigh(fp,bits);
}

float	WriteIeeeFloatHighLow(fp, num)
FILE	*fp;
float	num;
{
	int32	bits;
	
	bits = ConvertToIeee(num);
	Write32BitsHighLow(fp,bits);
}

/*
 *	ConvertToIeeeExtended - It's really hard to do the multiple word
 *	conversion without knowing how many bits the machine has.  Thus
 *	this routine will only get the first 24 bits right.
 */

ConvertToIeeeExtended(num, first, second, third, fourth, fifth)
float	num;
int	*first, *second, *third, *fourth, *fifth;
{
	int32	sign, mantissa, expon;

	if (num < 0) {
		sign = 0x8000;
		num *= -1;
	} else {
		sign = 0;
	}

	if (num == 0){
		mantissa = 0;
	} else {
		expon = floor(log(num)/log(2.0));
		if (expon < -16383) {
			expon = 1;
			mantissa = 0;
		} else if (expon > 16383){
			expon = 32767;
			mantissa = 0x7fffff;
		} else {
			mantissa = floor(num/pow(2.0,(float)expon)*0x400000+.5);
			expon += 16383;
		}
	}
	if (expon < 0 || expon > 32767){
		fprintf(stderr,
		"ConvertToIeeeExtended Program Error: Illegal Exponent (%d).\n",
			expon);
		return;
	}

#ifdef	TESTEXTENDED
	printf("Partial result is expon is %d and mantissa is 0x%x.\n",
		expon, mantissa);
#endif
	*first = expon | sign;
	*second = (mantissa>>7)&0xffff;
	*third = (mantissa<<1)&0xffff;
	*fourth = 0;
	*fifth = 0;
}

float	WriteIeeeExtendedLowHigh(fp, num)
FILE	*fp;
float	num;
{
	int	first, second, third, fourth, fifth;
	
	ConvertToIeeeExtended(num, &first, &second, &third, &fourth, &fifth);
	Write16BitsLowHigh(fp,fifth);
	Write16BitsLowHigh(fp,fourth);
	Write16BitsLowHigh(fp,third);
	Write16BitsLowHigh(fp,second);
	Write16BitsLowHigh(fp,first);
}

float	WriteIeeeExtendedHighLow(fp, num)
FILE	*fp;
float	num;
{
	int	first, second, third, fourth, fifth;
	
	ConvertToIeeeExtended(num, &first, &second, &third, &fourth, &fifth);
	Write16BitsHighLow(fp,first);
	Write16BitsHighLow(fp,second);
	Write16BitsHighLow(fp,third);
	Write16BitsHighLow(fp,fourth);
	Write16BitsHighLow(fp,fifth);
}

#define	AiffFORM	0x464f524d		/* "FORM" */
#define	AiffAIFF	0x41494646		/* "AIFF" */
#define	AiffCOMM	0x434f4d4d		/* "COMM" */
#define	AiffSSND	0x53534e44		/* "SSND" */

float	*ReadAiffFile(FileName, Length, SampleRate)
char	*FileName;
int32	*Length;
float	*SampleRate;
{
	int32	i, ChunkSize, SubSize, SoundPosition, numSampleFrames, offset;
	int	sampleSize, numChannels, blockSize;
	float	*Data;
	FILE	*fp;

	fp = fopen(FileName, "r");
	if (!fp){
		fprintf(stderr, 
			"ReadAiffDataFile: Couldn't open %s for reading.\n",
			FileName);
		exit(1);
	}

	*SampleRate = 0;
	*Length = 0;

	if (Read32BitsHighLow(fp) != AiffFORM){
		fprintf(stderr,
			"ReadAiffDataFile: Couldn't find initial chunk.\n");
		exit(1);
	}

	ChunkSize = Read32BitsHighLow(fp);

	if (Read32BitsHighLow(fp) != AiffAIFF){
		fprintf(stderr,
			"ReadAiffDataFile: Couldn't find AIFF chunk.\n");
		exit(1);
	}

	while (ChunkSize > 0){
		ChunkSize -= 4;
		switch(Read32BitsHighLow(fp)){
		case	AiffCOMM:
			ChunkSize -= SubSize = Read32BitsHighLow(fp);
			numChannels = Read16BitsHighLow(fp);	SubSize -= 2;
			numSampleFrames = Read32BitsHighLow(fp);SubSize -= 4;
			sampleSize = Read16BitsHighLow(fp);	SubSize -= 2;
			*SampleRate = ReadIeeeExtendedHighLow(fp); SubSize-=10;
			while (SubSize > 0){
				getc(fp);
				SubSize--;
			}
			break;
		case	AiffSSND:
			ChunkSize -= SubSize = Read32BitsHighLow(fp);
			offset = Read32BitsHighLow(fp);		SubSize -= 4;
			blockSize = Read32BitsHighLow(fp);	SubSize -= 4;
			SoundPosition = ftell(fp) + offset;
			
			while (SubSize > 0){
				getc(fp);
				SubSize--;
			}
			break;
		default:
			ChunkSize -= SubSize = Read32BitsHighLow(fp);
			while (SubSize > 0){
				getc(fp);
				SubSize--;
			}
			break;
		}
	}

	if (!SoundPosition){
		fprintf(stderr,
			"ReadAiffDataFile: Didn't find a SSND chunk.\n"
			);
		exit(1);
	}

	fseek(fp, SoundPosition, 0);
	*Length = numSampleFrames*numChannels;

	if (MaxSamples >= 0 && *Length > MaxSamples) 
		*Length = MaxSamples;

	fprintf(stderr,
		"Reading %ld samples from %s with sampling rate of %g.\n", 
		(long)*Length, FileName, *SampleRate);
	Data = NewFloatArray((int32) *Length, "ReadAiffDataFile");
	
	switch ((sampleSize+7)/8){
	case 1:
		for (i=0;i<*Length;i++){
			Data[i] = ReadByte(fp)/127.0;
		}
		break;
	case 2:
		for (i=0;i<*Length;i++){
			Data[i] = Read16BitsHighLow(fp)/32768.0;
		}
		break;
	case 3:
		for (i=0;i<*Length;i++){
			Data[i] = Read24BitsHighLow(fp)/32768.0/255.0;
		}
		break;
	case 4:
		for (i=0;i<*Length;i++){
			Data[i] = Read32BitsHighLow(fp)/32768.0/65536.0;
		}
		break;
	}
	return Data;
}

#define	AiffWordSize	1

WriteAiffFile(FileName, SampleRate, Length, Data, Channels)
char	*FileName;
int32	Length;
int	Channels;
float	*Data;
float	SampleRate;
{
	register int32	i;
	int	ChunkSize = 0;
	FILE	*fp;
	float	Max;

	if (strcmp(FileName,"-") != 0) {
		fp = fopen(FileName, "w");
		if (!fp){
			fprintf(stderr, 
			"WriteAiffFile: Couldn't open %s for writing.\n",
				FileName);
			exit(1);
		}
	} else {
		fp = stdout;
	}

	Max = Data[0];
	for (i=1;i<Length * Channels;i++)
		if (Data[i] > Max)
			Max = Data[i];

	fprintf(stderr,"Writing AIFF file %s with %ld frames.\n",
		FileName, Length);
	fprintf(stderr," Maximum value of file is %g.\n", Max);

	ChunkSize = 30 + Length*Channels*AiffWordSize;

	Write32BitsHighLow(fp, AiffFORM);	/* Magic Number */
	Write32BitsHighLow(fp, ChunkSize);	/* Chunk Size */
	Write32BitsHighLow(fp, AiffAIFF);	/* Type of Chunk */

						/* AIFF Common Chunk */
	Write32BitsHighLow(fp, AiffCOMM);
	Write32BitsHighLow(fp, 18);		/* Chunk Size */
	Write16BitsHighLow(fp, Channels);
	Write32BitsHighLow(fp, Length);	
	Write16BitsHighLow(fp, 8*AiffWordSize);	/* Sample Size */
	WriteIeeeExtendedHighLow(fp, SampleRate);

	ChunkSize = 8 + Length*Channels*AiffWordSize;
	Write32BitsHighLow(fp, AiffSSND);
	Write32BitsHighLow(fp, ChunkSize);	/* Chunk Size */
	Write32BitsHighLow(fp, 0);		/* Offset */
	Write32BitsHighLow(fp, 0);		/* Block Size*/

#if	AiffWordSize == 1
	Max = 127/Max;
#endif
	Max = 32767/Max;
	for (i=0;i<Length*Channels;i++)
#if	AiffWordSize == 1
		Write8Bits(fp,(int)(Data[i]*Max));
#else
		Write16BitsHighLow(fp,(int)(Data[i]*Max));
#endif

	if (fp != stdin)
		fclose(fp);
}

#ifdef	ESPS

/*
 *	ReadSignalStoreFile - First attempt to read the Entropic (Waves)
 *	Signal Processing format.
 */
	
#include	<esps/esps.h>
#include	<esps/fea.h>
#include	<esps/feasd.h>

float	*ReadEntropicFile(FileName, Length, SampleRate)
char	*FileName;
int32	*Length;
float	*SampleRate;
{
	float	*Data = 0;
	int	Channels;
	FILE	*inputsd_strm;
	long	i, HeaderLength = 0;
	struct	header	*sd_ihd;
	struct	feasd	*sd_feasd;


	*SampleRate = 0;
	*Length = 0;

	(void)eopen("play", FileName, "r", FT_FEA, FEA_SD, &sd_ihd,
			&inputsd_strm);
	
	*SampleRate = get_genhd_val("record_freq", sd_ihd, -1.0);
	if (*SampleRate < 0){
		fprintf(stderr, "ReadEntropicFile: Sample rate (%g) < 0.\n",
			*SampleRate);
		free(sd_ihd);
		return (float *) 0;
	}

	Channels = get_fea_siz("samples", sd_ihd, (short *)0, (long **)0);
	if (Channels > 1){
		fprintf(stderr, 
	    "ReadEntropicFile: Number of channels (%d) > 0 not supported.\n",
			Channels);
		free(sd_ihd);
		return (float *) 0;
	}

	*Length = sd_ihd->common.ndrec;
	
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;

	Data = NewFloatArray((int32) *Length, "ReadEntropicFile");

	sd_feasd = allo_feasd_recs(sd_ihd, FLOAT, *Length, Data, NO);
	
	get_feasd_recs(sd_feasd, 0, *Length, sd_ihd, inputsd_strm);

	free(sd_feasd);
	free(sd_ihd);
	return Data;
}
	
#else

float	*ReadEntropicFile(FileName, Length, SampleRate)
char	*FileName;
int32	*Length;
float	*SampleRate;
{
	fprintf(stderr, "ReadEntropicFile not supported on this machine.\n");
	*SampleRate = *Length = 0;
	return (float *)0;
}

#endif	/* ESPS	 */

/*
 *	Attempt to read the GW Instruments MacSpeech file format.
 *
 *	The data is stored as 12 bit unsigned numbers.  Appendix D of
 *	the MacSpeech Lab II manual states that 0 corresponds to -10V,
 *	2048 is DC and 4095 is 10V.  Since it is a Macintosh format
 *	then the bytes are stored HighLow (big endian).
 *
 *	The first word contains an integer that represents the sample 
 *	rate.  The "normal" sample rate is 5.208Khz.  Other sample rates
 *	are given by this first integer multiplied by 5.208Khz.
 */
float	*ReadMacSpeechFile(FileName, Length, SampleRate)
char	*FileName;
int32	*Length;
float	*SampleRate;
{
	register int32	i;
	float	*Data;
	FILE	*fp;
	long len;

	fp = fopen(FileName, "r");
	if (!fp){
	    fprintf(stderr,"ReadMacSpeechFile: Couldn't open %s for reading.\n",
		    FileName);
	    exit(1);
	}

	len = FileLength(fp);		/* length in bytes */
	*Length = len/2 - 1;		/* Subtract first word from length */
	if (MaxSamples >= 0 && *Length > MaxSamples) *Length = MaxSamples;
	
	Data = NewFloatArray((int32) *Length, "ReadMacSpeechFile");
	
	*SampleRate = 5208 * Read16BitsHighLow(fp);
	
	for (i=0;i<*Length;i++) {
	    Data[i] = (Read16BitsHighLow(fp)-2048.0)/2048.0*InputGain;
	}
	
	return(Data);
}

char	*
GetFileSuffix(FileName)
char	*FileName;
{
	char *p;

	for (p=FileName;*p;p++);

	for (;*p != '.' && p >= FileName;p--);

	if (*p == '.')
		return(p+1);
	else 
		return(FileName);
}

float *
ReadInputFile(FileName, SamplingRate, Length)
char	*FileName;
float	*SamplingRate;
int32	*Length;
{
	char	*Suffix;
	float	*Data = NULL;

	Suffix = GetFileSuffix(FileName);
	if (strncmp(Suffix,"adc",3) == 0 || strncmp(Suffix,"ADC",3) == 0)
		Data = ReadADCFile(FileName,SamplingRate,Length);
	else if (strncmp(Suffix,"dac",3) == 0 || strncmp(Suffix,"DAC",3) == 0)
		Data = ReadDACFile(FileName,SamplingRate,Length);
	else if (strncmp(Suffix,"wav",3) == 0 || strncmp(Suffix,"WAV",3) == 0){
		Data = ReadWavFile(FileName,Length);
		*SamplingRate = 16000;
	} else if (strncmp(Suffix,"m22",3) == 0||strncmp(Suffix,"M22",3) == 0){
		*SamplingRate = 22254.5454545454545454;
		Data = ReadByteFile(FileName,Length);
	} else if (strncmp(Suffix,"m11",3) == 0||strncmp(Suffix,"M11",3) == 0){
		*SamplingRate = 22254.5454545454545454/2;
		Data = ReadByteFile(FileName,Length);
	} else if (strncmp(Suffix,"m7",2) == 0 || strncmp(Suffix,"M7",2) == 0){
		*SamplingRate = 22254.5454545454545454/3;
		Data = ReadByteFile(FileName,Length);
	} else if (strncmp(Suffix,"dy22",4)==0||strncmp(Suffix,"DY22",4)==0){
		*SamplingRate = 22050;
		Data = ReadDyaxisFile(FileName,Length);
	} else if (strncmp(Suffix,"dy44",4)==0||strncmp(Suffix,"DY44",4)==0){
		*SamplingRate = 44100;
		Data = ReadDyaxisFile(FileName,Length);
	} else if (strncmp(Suffix,"snd",3) == 0) {
		/* sampling rate comes from the file */
		Data = ReadNeXTFile(FileName,Length,SamplingRate);
	} else if ((strncmp(Suffix,"irc",3) == 0) ||
		   (strncmp(Suffix,"IRC",3) == 0)) {
		/* sampling rate comes from the file */
		Data = ReadIRCAMFile(FileName,Length,SamplingRate);
	} else if (strncmp(Suffix,"fl",2) == 0 || strncmp(Suffix,"FL",2) == 0){
		*SamplingRate = 16000;
		Data = ReadNativeFloatFile(FileName, Length);
	} else if (strncmp(Suffix,"aif",3) == 0||strncmp(Suffix,"AIF",3) == 0){
		Data = ReadAiffFile(FileName, Length, SamplingRate);
	} else if (strncmp(Suffix,"sd",2) == 0 || strncmp(Suffix,"SD",2) == 0){
		Data = ReadEntropicFile(FileName, Length, 
			SamplingRate);
	} else if (strncmp(Suffix,"macspeech",9) == 0 || 
					strncmp(Suffix,"MACSPEECH",9) == 0){
		Data = ReadMacSpeechFile(FileName, Length, 
			SamplingRate);
	} else {
		fprintf(stderr, "Don't know format for input file '%s'\n", 
			FileName);
		exit(1);
	}
#ifdef	VERBOSE
	picout("Input.output",Data,sizeof(*Data)* *Length);
#endif	/* VERBOSE */
	return(Data);
}


#ifdef	TESTEXTENDED

float	InputGain;
int32	MaxSamples;

float	*NewFloatArray(size, message)
int	size;
char	*message;
{
	return 0;
}

main(){
	float	f, ConvertIeeeExtendedToFloat();
	int	a, b, c, d, e;
	
	while (1){
		printf("Please Enter a Number to Convert: ");
		scanf("%g", &f);

		ConvertToIeeeExtended(f, &a, &b, &c, &d, &e);
		printf("%g is 0x%04x, %04x, %04x, %04x, %04x,", 
			f, a, b, c, d, e);
		fflush(stdout);
		f = ConvertIeeeExtendedToFloat(a, b, c, d, e);
		printf(" and back to %g.\n", f);
	}
}

#endif	TESTEXTENDED

!Funky!Stuff!
echo x - filter.h
cat >filter.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *
 * $Header: filter.h,v 2.2 90/12/17 18:02:08 malcolm Exp $
 *
 * $Log:	filter.h,v $
 * Revision 2.2  90/12/17  18:02:08  malcolm
 * Added preprocessor check to make sure include file was only included once.
 * 
 * Revision 2.1  90/01/28  15:20:24  malcolm
 * Added definitions for new Group Delay functions.
 * 
 * Revision 2.0  89/07/25  18:58:39  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.2  88/12/06  21:14:10  malcolm
 * Added comments and cleaned up declarations.
 * 
 * Revision 1.1  88/10/23  22:41:26  malcolm
 * Initial revision
 * 
 *
 */

#ifndef	_FILTER_H
#define	_FILTER_H

/*
 *	A polynomial structure is used to store the coefficients to a 
 *	polynomial in the z variable.  A second degree polynomial will have
 *	the number 2 stored for the order and have an array of three (1,z,z^2)
 *	coefficients stored in the coeff array.
 */
struct polynomial {
	int	order;
	float	*coeff;
};

/*
 *	A filter is defined as the ratio of two polynomials.  In addition
 *	there is a scalar gain term.
 *
 *	The MakeFilter function allows the user to specify a target gain at
 *	any frequency.  The function MakeFilter multiplies the gain into all
 *	terms in the numerator.  Finally, the original sample_rate is kept 
 *	around to make it easier to evaluate the gain at any frequency.
 */
struct filter {
	struct polynomial *forward, *feedback;
	float	freq, gain;		/* Desired gain and frequency */
	float	sample_rate;		/* Sampling rate of filter */
};

float	FilterNumeratorCoeff(), FilterDenominatorCoeff();
float	EarBandwidth(), CascadeZeroCF(), CascadeZeroQ(), CascadePoleCF();
float	CascadePoleQ(), MaximumEarCF(), EarChannelCF();
float	EpsilonFromTauFS(), FilterGroupDelay(), PolyGroupDelay();

struct polynomial *AllocatePolynomial(), *CoeffsFromTauFS();
struct polynomial *CoeffsFromFCFS(), *CoeffsFromCFQFS();
complex	PolyEval(), RationalTransferFunction(), FilterEval(), FilterGain();

struct filter *MakeFilter(), *OuterMiddleEarFilter();
struct filter *EarFrontFilter(), *EarStageFilter();

#endif	/* _FILTER_H */
!Funky!Stuff!
echo x - fmag.f
cat >fmag.f <<'!Funky!Stuff!'
C 
C 			Lyon's Cochlear Model, The Program
C 	   			   Malcolm Slaney
C 			     Advanced Technology Group
C 				Apple Computer, Inc.
C 				 malcolm@apple.com
C 				   November 1988
C 
C 	This program implements a model of acoustic propagation and detection
C 	in the human cochlea.  This model was first described by Richard F.
C 	Lyon.  Please see 
C 		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
C 		Notebook," Apple Technical Report #13, 1988
C 	for more information.  This report is available from the Apple 
C 	Corporate Library.
C 
C 	Warranty Information
C 	Even though Apple has reviewed this software, Apple makes no warranty
C 	or representation, either express or implied, with respect to this
C 	software, its quality, accuracy, merchantability, or fitness for a 
C 	particular purpose.  As a result, this software is provided "as is,"
C 	and you, its user, are assuming the entire risk as to its quality
C 	and accuracy.
C 
C 	Copyright (c) 1988-1989 by Apple Computer, Inc
C 
C  $Header: fmag.f,v 2.0 89/07/25 18:58:40 malcolm Exp $
C 
C  $Log:	fmag.f,v $
c Revision 2.0  89/07/25  18:58:40  malcolm
c Completely debugged and tested version on the following machines (roughly
c in order of performance):
c Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
c both MPW and LightSpeed C.
c 
c Revision 1.1  88/10/23  22:42:00  malcolm
c Initial revision
c 
C 
C 
       subroutine fmag(real,im,n)
       integer n
       real real(0:n), im(0:n)

CDIR$ IVDEP
       do 10, i=0,n/2
		j = n - i
		firstreal =  ( real(i) + real(j) ) / 2.0
		firstim =    ( im(i)   - im(j)   ) / 2.0
		secondreal = ( im(i)   + im(j)   ) / 2.0
		secondim =   ( real(i) - real(j) ) / 2.0

		firstmag = firstreal*firstreal + firstim*firstim
		secondmag = secondreal*secondreal + secondim*secondim

		real(i) = firstmag
		real(j) = firstmag
		im(i) = secondmag
		im(j) = secondmag
  10   continue
       return
       end
!Funky!Stuff!
echo x - ftopix.f
cat >ftopix.f <<'!Funky!Stuff!'
C 
C 			Lyon's Cochlear Model, The Program
C 	   			   Malcolm Slaney
C 			     Advanced Technology Group
C 				Apple Computer, Inc.
C 				 malcolm@apple.com
C 				   November 1988
C 
C 	This program implements a model of acoustic propagation and detection
C 	in the human cochlea.  This model was first described by Richard F.
C 	Lyon.  Please see 
C 		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
C 		Notebook," Apple Technical Report #13, 1988
C 	for more information.  This report is available from the Apple 
C 	Corporate Library.
C 
C 	Warranty Information
C 	Even though Apple has reviewed this software, Apple makes no warranty
C 	or representation, either express or implied, with respect to this
C 	software, its quality, accuracy, merchantability, or fitness for a 
C 	particular purpose.  As a result, this software is provided "as is,"
C 	and you, its user, are assuming the entire risk as to its quality
C 	and accuracy.
C 
C 	Copyright (c) 1988-1990 by Apple Computer, Inc
C 
C  $Header: ftopix.f,v 2.2 90/12/17 18:02:27 malcolm Exp $
C 
C  $Log:	ftopix.f,v $
c Revision 2.2  90/12/17  18:02:27  malcolm
c Cleaned up and moved ALIMIT subroutine to this file.
c 
c Revision 2.1  90/01/28  15:37:01  malcolm
c Added capability (MRKPXL subroutine) so that an arbitrary pixel in the
c image can be marked with red.
c 
c Revision 2.0  89/07/25  18:58:42  malcolm
c Completely debugged and tested version on the following machines (roughly
c in order of performance):
c Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
c both MPW and LightSpeed C.
c 
c Revision 1.4  89/07/19  17:04:47  malcolm
c Added code to expand picture by different amounts in x and y.
c 
c Revision 1.3  89/03/24  15:02:39  malcolm
c Everything turned upside down.  Top and bottom of the picture were
c flipped so that high frequencies (low channel numbers) are at the top.
c Also, high energy points in the picture are now black like they are in
c a conventional spectrogram.
c 
c Revision 1.2  88/12/06  21:14:54  malcolm
c Added comments and rearranged declarations
c 
c Revision 1.1  88/10/23  22:42:47  malcolm
c Initial revision
c 
C 
C 
C***********************************************************************
C	FTOPIX - Routine to convert an array of floats into pixels for 
C	the ultra frame buffer.  This routine takes as arguments an
C	incore frame buffer (dest), an array of floating point numbers
C	(source), the width and height of the data and the min and max
C	of the data.  No checks are made that the data doesn't exceed
C	the limits passed as arguments.
C
C	The incore frame buffer is an array of integers (64 bits each).
C	Each word of the frame buffer holds two pixels.  The format of the
C	data in the word is as follows
C		|			64 bit word			     |
C		| Left Pixel (32 bits)	    |   Right Pixel (32 bits)	     |
C		| Empty|Blue |  Green | Red |	Empty | Blue |  Green | Red  |
C	Each of the RGB values is one byte.  The magic number 0x10101 is 
C	used to take a single gray scale level (between 0 and 255) and to
C	fill in the Red, Green and Blue values in the word.
C
C	Finally, one more performance hack.  It is necessary to shift the
C	left pixel into place instead of incorporating the shift into the
C	multiplication by 0x10101 because Cray integer arithmetic is only
C	48 bits long.
C
C	The UltraBuffer is represented in memory as a array of words in TV
C	raster order (top left pixel first).  This routine puts the image
C	centered on the screen with the first byte of the input array at the
C	lower left of the screen.
C
C	The CMIC$ directives enable microtasking of the loop.
C
C	The magic numbers that are used here are:
C	255 - Maximum value for a pixel
C	1280 - Width in pixels of the ultra display
C	1024 - Height in pixels of the ultra display
C	65793 - Equal to 0x10101 - Needed to convert gray scale level into RGB
C

CMIC$ MICRO
      subroutine FTOPIX(dest, source, width, height, minimum, maximum)
      integer dest(1280/2,*), i, j, width, height, expand
      integer xexpand, yexpand, oldpixel, mask, newpixel
      real source(width,height), minimum, maximum, scale, minvalue
      common /PIXEL/ markedx, markedy

C	For high resolution monitor
C     parameter (nwidth=1280, nheight=1024)	
C	For NTSC resolution monitor
C     parameter (nwidth=750, nheight=484)

      parameter (nwidth=780, nheight=480)
C     parameter (nwidth=1280, nheight=1024)	

C
C	There is a special hack installed in this version of ftopix that
C	allows the user to mark a pixel in the image with a bright color.
C	This color is specified by the following parameter.  (It is just
C	jammed into the pixel after putting everything else in place.)
      parameter (color=255)

c     scale = maximum
c     maximum = minimum
c     minimum = scale
c     print *,maximum, minimum, scale

      scale = 255.0/(maximum - minimum)

      minvalue = maximum
      scale = 255.0/(minimum - maximum)

      xexpand = 1
      if (width*2 .lt. nwidth) xexpand = 2
      if (width*4 .lt. nwidth) xexpand = 4

      yexpand = 1
      if (height*2 .lt. nheight) yexpand = 2
      if (height*4 .lt. nheight) yexpand = 4

      expand = yexpand
      if (xexpand .lt. yexpand) expand = xexpand

      if (expand .eq. 1) then
        if (xexpand .eq. 1 .and. yexpand .ge. 2) then
CMIC$ DO GLOBAL
          do 300 j = 1, height
CDIR$ IVDEP
             do 400 i = 1, width, 2
              dest(nwidth/2/2-width/2/2+i/2, nheight/2-height+2*j) =
     +         SHIFTL(INT((source(i+1,j)-minvalue)*scale)*65793, 32).OR.
     +                INT((source(i  ,j)-minvalue)*scale)*65793
              dest(nwidth/2/2-width/2/2+i/2, nheight/2-height+2*j+1) =
     +         SHIFTL(INT((source(i+1,j)-minvalue)*scale)*65793, 32).OR.
     +                INT((source(i  ,j)-minvalue)*scale)*65793
  400        continue
  300      continue
	   if (markedx .gt. 0 .and. markedx .le. width .and. 
     +         markedy .gt. 0 .and. markedy .le. height) then
	     if (mod(markedx,2) .eq. 1) then
	       newpixel = SHIFTL(color,32)
	       mask = 16777215
	     else
	       newpixel = color
	       mask = SHIFTL(16777215,32)
	     endif

	     oldpixel = dest(nwidth/2/2-width/2/2+markedx/2,
     +                       nheight/2-height+2*markedy)
	     dest(nwidth/2/2-width/2/2+markedx/2, 
     +            nheight/2-height+2*markedy) = 
     +                  (mask .and. oldpixel) + color
	     oldpixel = dest(nwidth/2/2-width/2/2+markedx/2,
     +                       nheight/2-height+2*markedy+1)
	     dest(nwidth/2/2-width/2/2+markedx/2, 
     +            nheight/2-height+2*markedy+1) = 
     +                  (mask .and. oldpixel) + color
	   endif
         else
	   
CMIC$ DO GLOBAL
           do 1100 j = 1, height
CDIR$ IVDEP
            do 1200 i = 1, width, 2
              dest(nwidth/2/2-width/2/2+i/2, nheight/2-height/2+j) =
     +         SHIFTL(INT((source(i+1,j)-minvalue)*scale)*65793,32).OR.
     +                INT((source(i  ,j)-minvalue)*scale)*65793
 1200       continue
 1100      continue
	   if (markedx .gt. 0 .and. markedx .le. width .and. 
     +         markedy .gt. 0 .and. markedy .le. height) then
	     if (mod(markedx,2) .eq. 1) then
	       newpixel = SHIFTL(color,32)
	       mask = 16777215
	     else
	       newpixel = color
	       mask = SHIFTL(16777215,32)
	     endif

	     oldpixel = dest(nwidth/2/2-width/2/2+markedx/2,
     +                       nheight/2-height/2+markedy)
	     dest(nwidth/2/2-width/2/2+markedx/2, 
     +            nheight/2-height/2+markedy) = 
     +                  (mask .and. oldpixel) + color
	   endif
	 endif
       endif

       if (expand .eq. 2) then
CMIC$ DO GLOBAL
         do 2100 j = 1, height
CDIR$ IVDEP
            do 2200 i = 1, width
             dest(nwidth/2/2-width/2+i, nheight/2-height+2*j) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width/2+i, nheight/2-height+2*j+1) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
 2200       continue
 2100    continue
	 if (markedx .gt. 0 .and. markedx .le. width .and. 
     +       markedy .gt. 0 .and. markedy .le. height) then
	   dest(nwidth/2/2-width/2+markedx,
     +          nheight/2-height+2*markedy) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width/2+markedx,
     +          nheight/2-height+2*markedy+1) =
     +         SHIFTL(color,32) + color
	 endif
       endif

       if (expand .eq. 4) then
CMIC$ DO GLOBAL
         do 4100 j = 1, height
CDIR$ IVDEP
            do 4200 i = 1, width
             dest(nwidth/2/2-width+2*i, nheight/2-2*height+4*j) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i, nheight/2-2*height+4*j+1) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i, nheight/2-2*height+4*j+2) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i, nheight/2-2*height+4*j+3) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i+1, nheight/2-2*height+4*j) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i+1, nheight/2-2*height+4*j+1) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i+1, nheight/2-2*height+4*j+2) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
             dest(nwidth/2/2-width+2*i+1, nheight/2-2*height+4*j+3) =
     +          SHIFTL(INT((source(i,j)-minvalue)*scale)*65793, 32).OR.
     +                 INT((source(i,j)-minvalue)*scale)*65793
 4200       continue
 4100    continue
	 if (markedx .gt. 0 .and. markedx .le. width .and. 
     +       markedy .gt. 0 .and. markedy .le. height) then
	   dest(nwidth/2/2-width+2*markedx,
     +          nheight/2-2*height+4*markedy) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx+1,
     +          nheight/2-2*height+4*markedy) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx,
     +          nheight/2-2*height+4*markedy+1) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx+1,
     +          nheight/2-2*height+4*markedy+1) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx,
     +          nheight/2-2*height+4*markedy+2) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx+1,
     +          nheight/2-2*height+4*markedy+2) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx,
     +          nheight/2-2*height+4*markedy+3) =
     +         SHIFTL(color,32) + color
	   dest(nwidth/2/2-width+2*markedx+1,
     +          nheight/2-2*height+4*markedy+3) =
     +         SHIFTL(color,32) + color
	 endif
       endif

      return
      end

      subroutine MRKPXL(x,y)
      common /PIXEL/ markedx, markedy
      integer x, y

      markedx = x
      markedy = y

      return
      end

      block data PixState
      common /PIXEL/ markedx, markedy
      data markedx/-1/, markedy/-1/
      end

      subroutine alimit(array,n,fmin,fmax)
      integer n, i
      real array(n), fmin, fmax

c     write *, "n is ",n,", fmin is ",fmin,", fmax is ",fmax
      do 10 i=1,n
	 array(i) = amax1(amin1(array(i),fmax),fmin)
c	 array(i) = array(i)*.5
   10 continue
      return
      end

!Funky!Stuff!
echo x - hydesign.c
cat >hydesign.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: hydesign.c,v 1.2 90/12/17 18:02:49 malcolm Exp $
 *
 * $Log:	hydesign.c,v $
 * Revision 1.2  90/12/17  18:02:49  malcolm
 * Added references to the Patterson correlogram code to the test main program.
 * 
 * Revision 1.1  90/11/06  21:00:12  malcolm
 * Initial revision
 * 
 */

static char	*RCSid = "$Header: hydesign.c,v 1.2 90/12/17 18:02:49 malcolm Exp $";

/*
 *	This file designs the second order filters used to model the cochlea.
 *	Compile with -DMAIN to test these functions.
 */

#include	<stdio.h>
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

/*
 *	DesignEarFilters - This routine designs all of the filters needed for
 *	the ear model.  Most of the real work is done in the file eardesign.c.
 *	Mostly this routine is responsible for calling the filter design 
 *	functions and filling in the arrays that the actual ear model code
 *	needs to function.
 *
 *	The first stage is the ear filter bank models the outer and middle 
 *	ears and is a simple high pass filter.  The second stage has a zero
 *	at DC to model the conversion of acoustic pressure into basilar
 *	membrane motion, a zero at the Nyquist rate to compensate for the
 *	narrow spacing of channels and finally the first pair of poles from
 *	the cascade of ear filters.
 */

DesignEarFilters(){
	int	i;
	float	cf, prevcf;
	struct filter *fp;

	fp = OuterMiddleEarFilter(sample_rate);
	a2[0] = FilterNumeratorCoeff(fp,0);
	a1[0] = FilterNumeratorCoeff(fp,1);
	a0[0] = FilterNumeratorCoeff(fp,2);
	b2[0] = 0.0;
	b1[0] = 0.0;
	EarFilterArray[0] = *fp;

	fp = EarFrontFilter(sample_rate);
	a2[1] = FilterNumeratorCoeff(fp,0);
	a1[1] = FilterNumeratorCoeff(fp,1);
	a0[1] = FilterNumeratorCoeff(fp,2);
	b2[1] = FilterDenominatorCoeff(fp,0);
	b1[1] = FilterDenominatorCoeff(fp,1);
	EarFilterArray[1] = *fp;

	for (i=2;i<MaxN;i++){
		cf = EarChannelCF(i-1, sample_rate);

		if (cf < 20){
			a0[0] = a1[0] = b1[i] = 0.0;
			EarLength = min(i,EarLength);
		} else {
			float	ot = cf/sample_rate*2*PI;
			float	nomq = 1/(0.15*2.0); /* to agree with agc */
			float	minq = 1/(2.0-ot);
			float	maxdamping = 1/minq;
			float	dampscaling = nomq/(nomq+(minq-0.5));
			b2[i] = 1.0-exp(-ot); /* epsilon for the real pole */
			b1[i] = ot;		/* bb = omega*T */
			a0[i] = dampscaling; /* scale to real poles at .5 */
			a1[i] = (1/nomq)*dampscaling; /* damping, init min */
			a2[i] = maxdamping; /* used to limit a1 */
		}
	}

	if (Debug) {
		FILE *fp;
		fp = fopen("coeffs.list","w");
		if (!fp){
		    fprintf(stderr,
		    "ear: Couldn't open coeffs.list for coefficient list.\n");
		    return;
		}
		for (i=0;i<EarLength;i++){
			fprintf(fp,"((%g %g %g)\n", a2[i], a1[i], a0[i]);
			fprintf(fp," (%g %g %g))\n", b2[i], b1[i], 1.0);
		}
		fclose(fp);
	}
}

/*
 *	MaximumEarCF - The maximum filter center frequency in this model is
 *	limited by the behaviour of the digital filters.  At high frequencies
 *	(relative to the sampling rate) the poles of the filter become real
 *	when the Q isn't very high.
 */
float MaximumEarCF(fs)
float	fs;
{
	return( fs / 5.0 );
}

/*
 *	EarChannelCF - Compute the center frequency of each channel of the
 *	ear filter bank.  We use the EarChannel array to cache the results
 *	so that we don't need to recompute them everytime.
 */
#define	MaxChannels	256
static	float	EarChannelCFResults[MaxChannels];

float EarChannelCF(index, fs)
int	index;
float	fs;
{
	if (index >= 0 && index < MaxChannels && 
	    EarChannelCFResults[index] != 0.0)
		return EarChannelCFResults[index];
	if (index == 0)
		return EarChannelCFResults[index] = MaximumEarCF(fs);
	else {
		float	cf, result;
		cf = EarChannelCF(index-1, fs);
		result = cf - EarStepFactor * 
				sqrt(cf*cf+EarBreakFreq*EarBreakFreq)/EarQ;

		if (result < 1)			/* Arbitrary Lower Limit */
			result = 1;

		if (index >= 0 && index < MaxChannels)
			EarChannelCFResults[index] = result;
		return(result);
	}
}

ChannelIndex(Freq)
float	Freq;
{
	register int	i;

	for (i=0;EarChannelCFResults[i] > 0;i++){
		if (EarChannelCFResults[i] < Freq)
			return i-1;			/* Back up one */
	}

	return i-2;
}

InitParms()
{
	Debug = 0;
	printflag = 1;
	ImpulseInput = 0;
	UseAgc = 1;
	UseCascade = 1;
	UseDifference = 1;
	ComputeFiltered = 0;
	UseUltra = 0;
	CPUs = 4;
	VideoRecord = 0;
	LogDisplay = 0;			/* Stretch Correlation on Log Display */
	ifn = "data.adc";		/* Input File Name */
	ofn = "cochlea.pic";		/* Output File for Cochleagram */
	ffn = NULL;			/* Filtered Output */
	cfn = NULL;			/* Correlogram Directory Name */

	sample_rate = 16000.0;
	MaxSamples = -1;

	AgcStage1Tau = 0.010;
	AgcStage2Tau = 0.020;
	AgcStage4Tau = 0.040;
	AgcStage3Tau = 0.080;
	AgcStage1Target = 0.0022;
	AgcStage2Target = 0.0016;
	AgcStage4Target = 0.0011;
	AgcStage3Target = 0.0008;
	DecimationFactor = 20;
	CorrelationStep = 128;
	CorrelationLags = 256;
	TauFactor = 3.0;
	Normalization = .75;
	UltraHeadroom = 10.0;
	SharpResponse = 1;
	TransformCorrelogram = 1;

	EarBreakFreq = 650.0;
	EarQ = 8.0;
	EarStepFactor = .25;
	EarSharpness = 5.0;
	EarZeroOffset = 1.5;
	EarPreemphCorner = 300.0;
	InputGain = 1e-3;
}

CheckParms()
{
}

#ifdef	MAIN

main(argc, argv)
int	argc;
char	**argv;
{
	int	index;
	float	sampling_rate;
	float	cf;
	double	atof();

	InitParms();

	if (argc < 3){
		printf("syntax: %s index sampling_rate\n",
			argv[0]);
		exit(1);
	}
	index = atoi(argv[1]);
	sampling_rate = atof(argv[2]);

	EarQ = 4;
	EarStepFactor=.125;

	CheckParms();

	cf = EarChannelCF(index, sampling_rate);
	printf("The center frequency of the %d'th filter (%g sampling rate)",
		index, sampling_rate);
	printf(" is %g.\n", cf);

	printf("EpsilonFromTauFS(5.0/cf,%g) is %g.\n",sampling_rate,
		EpsilonFromTauFS(5.0/cf, sampling_rate));

	printf("FirstOrderFromTau(5.0/cf,%g) are ", sampling_rate);
	PrintPolynomial(FirstOrderFromTau(5.0/cf, sampling_rate));
	printf("\n");

	printf("FirstOrderFromCorner(.25*cf,%g) are ", sampling_rate);
	PrintPolynomial(FirstOrderFromCorner(.25*cf, sampling_rate));
	printf("\n");

	printf("SecondOrderFromCenterQ(.25*cf,2,%g) are ", sampling_rate);
	PrintPolynomial(SecondOrderFromCenterQ(.25*cf, 2.0, sampling_rate));
	printf("\n");

	printf("OuterMiddleEarFilter(%g) is: \n",sampling_rate);
	PrintFilter(OuterMiddleEarFilter(sampling_rate));

	printf("EarFrontFilter(%g) is: \n", sampling_rate);
	PrintFilter(EarFrontFilter(sampling_rate));

	printf("EarStageFilter(%g,%g,1.032525595) is: \n", cf, sampling_rate);
	PrintFilter(EarStageFilter(cf, sampling_rate, 1.032525595));
	printf("\tGroup delay of this filter at CF is %g.\n",
		FilterGroupDelay(EarStageFilter(cf,sampling_rate,1.032525595),
				 cf, sampling_rate));
}

double LickEarCorrelation(){}			/* Just to make loader happy */
LickInitCorrelation(){}
LickSendInputToCorrelation(){}
double ShammaEarCorrelation(){}
ShammaInitCorrelation(){}
ShammaSendInputToCorrelation(){}
double PattersonEarCorrelation(){}
PattersonInitCorrelation(){}
PattersonSendInputToCorrelation(){}
#endif	/* MAIN */
		
!Funky!Stuff!
echo x - hyfilters.c
cat >hyfilters.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: hyfilters.c,v 1.3 91/02/27 12:36:17 malcolm Exp $
 *
 * $Log:	hyfilters.c,v $
 * Revision 1.3  91/02/27  12:36:17  malcolm
 * A bunch of bug fixes by Dick.  "Final" version.
 * 
 * Revision 1.2  90/12/17  18:03:25  malcolm
 * Added references to the Patterson correlogram code to the test main program.
 * 
 * Revision 1.1  90/11/06  21:00:39  malcolm
 * Initial revision
 * 
 */

static char	*RCSid = "$Header: hyfilters.c,v 1.3 91/02/27 12:36:17 malcolm Exp $";

/*
 *	This file designs the second order filters used to model the cochlea.
 *	Compile with -DMAIN to test these functions.
 */

#include	<stdio.h>
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

float Sos1State[MaxN], Sos2State[MaxN], FosState[MaxN];
float Agc1State[MaxN+2], Agc2State[MaxN+2], Agc3State[MaxN+2],
	Agc4State[MaxN+2];
float InputState[MaxN], DecimateState1[MaxN], DecimateState2[MaxN];

EARSTEP(input, output)
float	*input;
float	output[];
{
	register int i;
	register float tempin;

	if (UseCascade){
		for (i= EarLength-1; i>0 ; i--)		/* Don't do preemph 
							 * channel
							 */
			InputState[i] = InputState[i-1];
		InputState[0] = *input;			/* Now fill in the 
							 * preemph
							 */
	} else {
#include	"ivdep.h"
		for (i=0;i<EarLength;i++){		/* Copy input to all 
							 * channels
							 */
			InputState[i] = *input;
		}
	}

	tempin = InputState[0];
	InputState[0] = a0[0] * tempin                         + Sos1State[0];
	Sos1State[0] =  a1[0] * tempin - b1[0] * InputState[0] + Sos2State[0];
	Sos2State[0] =  a2[0] * tempin - b2[0] * InputState[0];
	tempin = InputState[1];
	InputState[1] = a0[1] * tempin                         + Sos1State[1];
	Sos1State[1] =  a1[1] * tempin - b1[1] * InputState[1] + Sos2State[1];
	Sos2State[1] =  a2[1] * tempin - b2[1] * InputState[1];

	for (i=2;i<EarLength;i++){
		register float	ytm1, ytm2, aa, bb, diff, inp, out;

		bb = b1[i];
		aa = a1[i];
		ytm1 = Sos1State[i];		/* y(t-1) */
		ytm2 = Sos2State[i];		/* y(t-2) */
		diff = ytm2 - ytm1;
		out = ((InputState[i] - ytm1)*bb + diff*aa) * bb - 
			      ytm2 + ytm1 + ytm1;

		Sos2State[i] = Sos1State[i];
		Sos1State[i] = out;
						/* zeroes */
		inp = 0.25*(out + 2.0*ytm1 + ytm2); 
						/* now do the real pole */
		ytm1 = FosState[i];
						/* b2 is epsilon */
		FosState[i] = InputState[i] = ytm1 + b2[i]*(inp - ytm1);
	}

					/* spacediff filter, not optional: */
	difference(InputState, output, EarLength); 
	if (ComputeFiltered){
		fwrite(output, EarLength, sizeof(InputState[0]), ffp);
	      }
	hwr(output, output, EarLength);


	if (UseAgc ){
		agc(output, Agc1State, AgcEpsilon1, 
		AgcStage1Target, EarLength);
		agc(output, Agc2State, AgcEpsilon2, 
		AgcStage2Target, EarLength);
		agc(output, Agc3State, AgcEpsilon3, 
		AgcStage3Target, EarLength);
		agc(output, Agc4State, AgcEpsilon4, 
		AgcStage4Target, EarLength);
		for (i=2;i<EarLength;i++){
		  register float newa1;
					/* scale by dampscaling */
		  newa1 = a0[i]* 0.2 * (2.0 + 
					Agc1State[i] + Agc2State[i] + 
					Agc3State[i] + Agc4State[i] );
		  /* now limit to maxdamping (guard against huge transient)*/
		  a1[i] = min(newa1,a2[i]);
		}		
	}

					/* 
					 * Optional difference & HWR after 
					 * first HWR 
					 */
	if (UseDifference){ 		
		difference(output, output, EarLength);
		hwr(output, output, EarLength);
	}

	if (DecimationFactor > 0) {
		fos(output, DecimateState1, output, DecimationEpsilon, 
			EarLength);
		fos(output, DecimateState2, output, DecimationEpsilon, 
			EarLength);
	}
}

agc(input, state, epsilon, target, n)
float	input[], state[];
float	epsilon, target;
int	n;
{
	register int i;
	float	temp[MaxN+2];
#ifdef	NOCROSSTALK
	float	OneMinusEpsOverThree = (1.0 - epsilon);
#else	/* CROSSTALK */
	float	OneMinusEpsOverThree = (1.0 - epsilon)/3.0;
#endif	/* NOCROSSTALK */
	float	EpsOverTarget = epsilon/target;

						/* now use elements 2 through 
						 * n-1, aligned with input 
						 * rather than off by one
						 */
	state[1] = state[2];			/* Take care of end effects */
	state[n] = state[n-1];			/* Take care of end effects */ 

#include	"ivdep.h"
	for (i=2;i<n;i++){
#ifdef	NOCROSSTALK
		temp[i] = input[i] * EpsOverTarget + 
			      OneMinusEpsOverThree * state[i];
#else	/* CROSSTALK */
		temp[i] = input[i] * EpsOverTarget + 
			      OneMinusEpsOverThree * 
			      (state[i-1]+state[i]+state[i+1]);
#endif	/* NOCROSSTALK */
	}

#include	"ivdep.h"
	for (i=2;i<n;i++){
		register float f;
		
		f = temp[i];
		/* this limit is optional */
		/* if (f > 2.0) f = 2.0; */
		state[i] = f;
	}
}

#ifdef	MAIN

float AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4;
float AgcStage1Target, AgcStage2Target, AgcStage3Target, AgcStage4Target;
float DecimationEpsilon;

float	a0[MaxN], a1[MaxN], a2[MaxN], b1[MaxN], b2[MaxN];
float	state1[MaxN], state2[MaxN];

#define	LENGTH		500
#define	CHANNELS	100

int	UseAgc;
int	ComputeFiltered;
int	DecimationFactor;
int	EarLength;
int	UseCascade;
int	UseDifference;
FILE	*ffp = NULL;

main(){
	register int i, j;
	float	period, input;
	float	Output[MaxN];
	
	InitParms();
	UseCascade = 0;
	UseAgc = 0;
	UseDifference = 0;
	Debug = 1;
	DecimationFactor = 0;

	DesignEarFilters();
	ChangeDecimationParameters();

	fprintf(stderr, "Impulse Response of ear filters (%d x %d).\n",
		CHANNELS, LENGTH);

	for (i=0;i<LENGTH;i++){
		if (i == 0)
			input = 1.0;
		else
			input = 0.0;
		EARSTEP(&input,Output);
		for (j=0;j<CHANNELS;j++)
			printf("%g\n", Output[j]);
		printf("\n");
	}
}

double LickEarCorrelation(){}			/* Just to make loader happy */
LickInitCorrelation(){}
LickSendInputToCorrelation(){}
double ShammaEarCorrelation(){}
ShammaInitCorrelation(){}
ShammaSendInputToCorrelation(){}
double PattersonEarCorrelation(){}
PattersonInitCorrelation(){}
PattersonSendInputToCorrelation(){}

#endif	/* MAIN */
!Funky!Stuff!
echo x - icos.c
cat >icos.c <<'!Funky!Stuff!'
#include	<stdio.h>
#include	<math.h>

#ifndef	M_PI
#define	M_PI	3.141592653589792434
#endif

FILE	*ifp;				/* Input File Name */

#define	COS_LENGTH	13
#define	OUTPUT_LENGTH	85

float	CosTransform[OUTPUT_LENGTH][COS_LENGTH];
float	InputGain;
int	MaxSamples;
char	**progname;

main(argc, argv)
int	argc;
char	**argv;
{
	int	f, j, ByteCount, i, FrameCount;
	float	Data[COS_LENGTH], ReadIeeeFloatHighLow();
	float	*Output, max, min, scale, result;

	if (argc < 2){
		fprintf(stderr, "Syntax: %s input > output\n", 
			argv[0]);
		exit(1);
	}

	ifp = fopen(argv[1], "r");

	if (!ifp){
		fprintf(stderr, "Can't open %s for reading input.\n", argv[1]);
		exit(1);
	}

	for (f=0;f<COS_LENGTH;f++){
		float	gain = 1.0;
		if (f != 0)
			gain = 2.0;
		for (j=0;j<OUTPUT_LENGTH;j++)
			CosTransform[j][f] = gain*cos(M_PI*f*j/OUTPUT_LENGTH);
	}

	ByteCount = Read32BitsHighLow(ifp);

	Output = (float *)malloc(ByteCount/4/COS_LENGTH*OUTPUT_LENGTH*
					sizeof(*Output));

	FrameCount = 0;
	while (ByteCount > 0){
		for (i=0;i<COS_LENGTH;i++)
			Data[i] = ReadIeeeFloatHighLow(ifp);

		for (j=0;j<OUTPUT_LENGTH;j++){
			result = 0.0;
			for (i=0;i<COS_LENGTH;i++)
				result += Data[i] * CosTransform[j][i];
			
			Output[FrameCount*OUTPUT_LENGTH+j] = result;
		}
		ByteCount -= 4 * COS_LENGTH;
		FrameCount++;
	}

	max = min = Output[i];
	for (i=0;i<FrameCount*OUTPUT_LENGTH;i++){
		if (Output[i] > max)
			max = Output[i];
		if (Output[i] < min)
			min = Output[i];
	}

	scale = 255/(max-min);
	for (i=0;i<FrameCount*OUTPUT_LENGTH;i++){		
		putchar((int)floor((Output[i]-min)*scale));
	}
}

!Funky!Stuff!
echo x - ivdep.cray.h
cat >ivdep.cray.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *
 * $Header: ivdep.cray.h,v 2.0 89/07/25 18:58:45 malcolm Exp $
 *
 * $Log:	ivdep.cray.h,v $
 * Revision 2.0  89/07/25  18:58:45  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.1  88/10/23  23:08:36  malcolm
 * Initial revision
 * 
 *
 */

/*
 *	Note the following hack is necessary so that pre-ANSI C compilers
 *	won't get upset by the #pragma directive.  Only if the compiler is
 *	capable of handling the directive (go ahead and vectorize the loop
 *	the vectors are independent) is it included.
 */

#pragma	ivdep

!Funky!Stuff!
echo x - ivdep.h
cat >ivdep.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *
 * $Header: ivdep.h,v 2.0 89/07/25 18:58:46 malcolm Exp $
 *
 * $Log:	ivdep.h,v $
 * Revision 2.0  89/07/25  18:58:46  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.2  89/04/09  17:04:13  malcolm
 * Added missing double quote in include file specification.
 * 
 * Revision 1.1  88/10/23  23:08:53  malcolm
 * Initial revision
 * 
 *
 */


/*
 *	Note the following hack is necessary so that pre-ANSI C compilers
 *	won't get upset by the #pragma directive.  Only if the compiler is
 *	capable of handling the directive (go ahead and vectorize the loop
 *	the vectors are independent) is it included.
 */

#if	ANSI || CRAY
#include	"ivdep.cray.h"
#endif	/* ANSI */

!Funky!Stuff!
echo x - ivq.c
cat >ivq.c <<'!Funky!Stuff!'
#include	<stdio.h>
#include	<math.h>

#ifndef	M_PI
#define	M_PI	3.141592653589792434
#endif

FILE	*ifp;				/* Input File Name */

#define	COS_LENGTH	13
#define	OUTPUT_LENGTH	85

#define	VQ_SIZE		256

float	CosTransform[OUTPUT_LENGTH][COS_LENGTH];
float	InputGain;
int	MaxSamples;
char	*progname;

float	CodeBook[VQ_SIZE][COS_LENGTH];

main(argc, argv)
int	argc;
char	**argv;
{
	int	f, j, ByteCount, i, FrameCount;
	float	*Data, ReadIeeeFloatHighLow();
	float	*Output, max, min, scale, result;

	if (argc < 2){
		fprintf(stderr, "Syntax: %s input codebook > output\n", 
			argv[0]);
		exit(1);
	}

	progname = argv[0];
	ifp = fopen(argv[1], "r");
	ReadCodeBook(argv[2]);

	for (f=0;f<COS_LENGTH;f++){
		for (j=0;j<OUTPUT_LENGTH;j++){
			CosTransform[j][f] = cos(M_PI*f*j/OUTPUT_LENGTH);
		}
	}

	ByteCount = Read32BitsHighLow(ifp);

	Output = (float *)malloc(ByteCount*OUTPUT_LENGTH*sizeof(*Output));

	FrameCount = 0;
	while (ByteCount > 0){
		int	code;

		code = ReadByte(ifp) & 0xff;
		if (code < 0 || code >= VQ_SIZE){
			fprintf(stderr, 
			    "%s: Got a code (%d) out of the codebook (0->%d)\n",
			    progname, code, VQ_SIZE);
			exit(1);
		}

		Data = CodeBook[code];

		for (j=0;j<OUTPUT_LENGTH;j++){
			result = 0.0;
			for (i=0;i<COS_LENGTH;i++)
				result += Data[i] * CosTransform[j][i];
			
			Output[FrameCount*OUTPUT_LENGTH+j] = result;
		}
		ByteCount--;
		FrameCount++;
	}

	max = min = Output[0];
	for (i=0;i<FrameCount*OUTPUT_LENGTH;i++){
		if (Output[i] > max)
			max = Output[i];
		if (Output[i] < min)
			min = Output[i];
	}
	fprintf(stderr, "Min is %g, Max is %g.\n", min, max);

	scale = 255/(max-min);
	for (i=0;i<FrameCount*OUTPUT_LENGTH;i++){		
		putchar((int)floor((Output[i]-min)*scale));
	}
}

ReadCodeBook(name)
char	*name;
{
	int	i;
	FILE	*fp;

	fp = fopen(name, "r");
	if (!fp) {
		fprintf(stderr, "%s: Can't open codebook (%s).\n",
			progname, name);
		exit(1);
	}

					/* Note, unlike the ceptral files,
					 * the codebook files have a float
					 * count (instead of a byte count.)
					 */
	i = Read32BitsHighLow(fp);

	if (i != COS_LENGTH*VQ_SIZE){
		fprintf(stderr, "%s: Code is wrong size (%d), expected %d.\n",
			progname, i, COS_LENGTH*VQ_SIZE);
		exit(1);
	}

	for (i=0;i<VQ_SIZE;i++){
		int	j;
		for (j=0;j<COS_LENGTH;j++){
			CodeBook[i][j] = ReadIeeeFloatHighLow(fp);
		}
	}

	fclose(fp);
}

!Funky!Stuff!
echo x - oneframe.c
cat >oneframe.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: oneframe.c,v 2.2 90/11/06 20:52:51 malcolm Exp $
 *
 * $Log:	oneframe.c,v $
 * Revision 2.2  90/11/06  20:52:51  malcolm
 * Changed copyright message.
 * 
 * Revision 2.1  89/11/09  23:09:51  malcolm
 * Removed an unused Buffer.
 * 
 * Revision 2.0  89/07/25  18:58:48  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.1  89/07/19  12:48:39  malcolm
 * Initial revision
 * 
 */

#include	<stdio.h>
#include	<ctype.h>

FILE	*ToRemote, *FromRemote;
int	RemotePID;

OpenConnection(machine)
char	*machine;
{
	int	i;
	int	topipe[2], frompipe[2];

	i = pipe(topipe);
	if (i < 0){
		perror("OpenConnection: To Pipe failed");
		exit(1);
	}
	pipe(frompipe);
	if (i < 0){
		perror("OpenConnection: From Pipe failed");
		exit(1);
	}

	RemotePID = fork();
	if (RemotePID < 0){
		fprintf(stderr, "Couldn't fork to open connection to %s.\n",
			machine);
		fprintf(stderr, 
		    "Try setting NCPUS to one to disable multiprocessing.\n");
		exit(1);
	}

	if (RemotePID > 0){			/* Child */
		i = dup2(topipe[0],0);		/* Standard Input */
		if (i < 0){
			perror("OpenConnection: Dup2 ToPipe Failed");
			exit(1);
		}
		i = dup2(frompipe[1],1);	/* Standard Output */
		if (i < 0){
			perror("OpenConnection: Dup2 FromPipe Failed");
			exit(1);
		}
		i = dup2(frompipe[1],2);	/* Standard Error */
		if (i < 0){
			perror("OpenConnection: Dup2 FromPipe Failed");
			exit(1);
		}
		i = close(topipe[0]);
		if (i < 0){
			perror("OpenConnection: Close ToPipe[0] Failed");
			exit(1);
		}
		i = close(topipe[1]);
		if (i < 0){
			perror("OpenConnection: Close ToPipe[1] Failed");
			exit(1);
		}
		i = close(frompipe[0]);
		if (i < 0){
			perror("OpenConnection: Close FromPipe[0] Failed");
			exit(1);
		}
		i = close(frompipe[1]);
		if (i < 0){
			perror("OpenConnection: Close FromPipe[1] Failed");
			exit(1);
		}

		execl("/usr/ucb/remsh", "remsh", machine, "exec", 
						"/bin/csh", "-i", 0);
		fprintf(stderr, "Couldn't exec remsh from child.\n");
		exit(1);
	}

						/* Parent */
	ToRemote = fdopen(topipe[1],"a");
	if (ToRemote == 0){
		fprintf(stderr, "OpenConnection: FDOpen topipe failed.\n");
		exit(1);
	}
	FromRemote = fdopen(frompipe[0], "r");
	if (FromRemote == 0){
		fprintf(stderr, "OpenConnection: FDOpen frompipe failed.\n");
		exit(1);
	}
	i = close(topipe[0]);
	if (i < 0){
		perror("OpenConnection: Close ToPipe[0] Failed");
		exit(1);
	}
	close(frompipe[1]);
	if (i < 0){
		perror("OpenConnection: Close FromPipe[1] Failed");
		exit(1);
	}

	while((i = getc(FromRemote)) != '%')
		putchar(i);
	getc(FromRemote);			/* Get the trailing space */

	SendCommandToRemote("set prompt = \"ok\\\n\"\n");
}

SendCommandToRemote(command)
char	*command;
{
	int	i;
	char	Buffer[BUFSIZ];

	i = strchr(command, '\n');
	if (i == 0){
		command[strlen(command)] = '\n';
		command[strlen(command)+1] = 0;
	}
	i = fputs(command,ToRemote);
	fflush(ToRemote);
	do {
		fgets(Buffer, BUFSIZ, FromRemote);
#ifdef	DEBUG
		printf(" Got back %s from remote side.\n", Buffer);
#endif	DEBUG
	} while (!feof(FromRemote) && strcmp(Buffer,"ok\n") != 0);
	if (feof(FromRemote)){
		printf("Got an end of file from the remote command.\n");
		exit(1);
	}
}

CloseConnection(){
	if (ToRemote)
		fclose(ToRemote);
	if (FromRemote)
		fclose(FromRemote);
}

#ifdef	MAIN

main(){
	int	i;

	OpenConnection("dumbo");

	for (i=0;i<10;i++){
		SendCommandToRemote("date");
	}

	CloseConnection();
}

#endif	MAIN
!Funky!Stuff!
echo x - output.c
cat >output.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: output.c,v 2.4 91/01/22 14:59:15 malcolm Exp $
 *
 * $Log:	output.c,v $
 * Revision 2.4  91/01/22  14:59:15  malcolm
 * Fixed an extra factor of two in the SPHYNX cosine transform code.
 * 
 * Revision 2.3  90/12/17  18:03:57  malcolm
 * Changed max to Max to clear up preprocessor problem on some machines.
 * 
 * Revision 2.2  90/11/06  20:53:05  malcolm
 * Added support for Sphynx VQ format.  All we do here is compute the
 * first 13 coefficients of the Cosine transform.
 * 
 * Revision 2.1  89/11/09  23:09:29  malcolm
 * Cleaned up some unused variables.
 * 
 * Revision 2.0.1.2  89/08/14  11:12:09  malcolm
 * Added binary option to the fopen call for LightSpeed C.
 * 
 * Revision 2.0.1.1  89/07/31  16:15:05  malcolm
 * Fixed bug in the BYTEOUTPUT part of WriteOutputFile.  Seems like the cast
 * was being applied to early and all zeros was getting written out.
 * 
 * Revision 2.0  89/07/25  18:58:51  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.5  89/07/19  12:49:13  malcolm
 * Added option (compile time) for byte and ASCII output files.
 * 
 * Revision 1.4  89/04/09  17:06:24  malcolm
 * Added support for decimation factor of zero.
 * 
 * Revision 1.3  89/03/15  10:16:38  malcolm
 * Fixed the OGC syncrep format so that it outputs the channels from low
 * frequency to high.
 * 
 * Revision 1.2  89/02/26  15:55:33  malcolm
 * Added code to support the OGC (actually CMU) output file format.
 * 
 * Revision 1.1  89/02/26  14:40:41  malcolm
 * Initial revision
 * 

 */

static char	*RCSid = "$Header: output.c,v 2.4 91/01/22 14:59:15 malcolm Exp $";

#include	<stdio.h>
#include	<math.h>
#include	"ear.h"

#ifdef	NOHEADER

static FILE	*ofp = NULL;
static int	LineCount = 0;
static int	LineLength = 0;
static char	*FileName = "";

OpenOutputFile(ofn)
char	*ofn;
{
        if (ofn && *ofn){
		FileName = ofn;
#ifdef	THINK_C
#ifdef	TEXTOUTPUT				/* Stupid LSC can't handle right way */
		ofp = fopen(ofn, "w");
#else
		ofp = fopen(ofn, "wb");
#endif	/* TEXTOUTPUT */
#else
                ofp = fopen(ofn, "w");
#endif	/* THINK_C */
                if (!ofp){
                        fprintf(stderr,
			    "OpenOutputFile: Can't open %s for output data.\n",
                                ofn);
                        exit(1);
                }
        }
}

WriteOutputFile(Data,Length)
float	*Data;
int	Length;
{
	int	i, result;
	float	Max, scale;

	if (ofp) {
		if (LineLength && Length != LineLength){
		    fprintf(stderr,"WriteOutputFile: Uneven line lengths.\n");
		    fprintf(stderr," Expecting %d, got %d at line %d.\n",
			LineLength, Length, LineCount);
		    exit(1);
		}
		LineLength = Length;
				
#ifdef	TEXTOUTPUT
		for (i=0; i<Length; i++){
			fprintf(ofp, "%g\t", Data[i]);
			if ((i % 4) == 3)
				fprintf(ofp,"\n");
		}
		fprintf(ofp,"\n");
#else 
#ifdef BYTEOUTPUT
		Max = 2*AgcStage4Target;
		scale = 255.0/Max;
		for (i=0; i<Length; i++){
			if (Data[i] < 0)
				putc(0, ofp);
			else if (Data[i] > Max)
				putc(0xff, ofp);
			else
				putc((int) (Data[i] * scale + 0.5), ofp);
		}
#else	/* Not bytes or ascii.....must be floats. */
		result = fwrite(Data,sizeof(float),Length,ofp);
		if (result != Length){
			fprintf(stderr,"Couldn't write output data (%d).\n",
				result);
			CloseOutputFile();
			exit(1);
		}
#endif	/* BYTEOUTPUT */
#endif	/* TEXTOUTPUT */
		LineCount++;
	}
}

CloseOutputFile(){
	if (ofp) {
#ifdef	TEXTOUTPUT
		printf("Image (%s) is %dx%d (ascii text, no header).\n", 
			FileName, LineLength, LineCount);
#else
#ifdef	BYTEOUTPUT
		printf("Image (%s) is %dx%d (8 bit bytes, no header).\n", 
			FileName, LineLength, LineCount);
#else
		printf("Image (%s) is %dx%d (floating point, no header).\n", 
			FileName, LineLength, LineCount);
#endif	/* BYTEOUTPUT */
#endif	/* TEXTOUTPUT */
		fclose(ofp);
	}
}
 
#endif	/* NOHEADER */



#ifdef	OGC

				/* WARNING....this stuff is a real
				 * hack to see if things can work.
				 *	Malcolm@apple.com  1/12/89
				 */
#include	"syncstruct.h"

static	int	NumberOfFrames = 0;
static	int	StartADCIndex = 0;

struct DataStruct	{
	short	*Data;
	int	Length;
	int	Start;
	struct DataStruct *Next;
};
struct DataStruct  FirstBuffer = {NULL, 0, 0, NULL};
struct DataStruct  *LastBuffer = &FirstBuffer;

/* HACK---Just set up the first buffer.
 * Only used if OGC is defined.
 */

static FILE	*ofp;
static char	*FileName = "";
#define	MAX	(AgcStage4Target*1.5)

OpenOutputFile(ofn)
char	*ofn;
{

        if (ofn && *ofn){
		FileName = ofn;
                ofp = fopen(ofn, "w");
                if (!ofp){
                        fprintf(stderr,
			    "OpenOutputFile: Can't open %s for output data.\n",
                                ofn);
                        exit(1);
                }
		FirstBuffer.Data = NULL;
		FirstBuffer.Length = 0;
		FirstBuffer.Start = 0;
		FirstBuffer.Next = NULL;
        }
}

/* HACK --- Save the data so that we can output it all at once at
 * the end of the run.
 */
WriteOutputFile(Data,Length)
float	*Data;
int	Length;
{
	int	i;
	float	Max;
	struct DataStruct *NextData;
	extern	int	DecimationFactor;
	extern	float	AgcStage4Target;

	if (!ofp)
		return;

	NextData = (struct DataStruct *)malloc(sizeof(*NextData));
	if (!NextData){
		fprintf(stderr, "Can't allocate space for data struct.\n");
		exit(1);
	}

	NextData->Data = (short *) malloc(Length*
					sizeof(*NextData->Data));
	if (!NextData->Data){
		fprintf(stderr, "Can't allocate data space.\n");
		exit(1);
	}

	for (i=0;i<Length;i++){
#ifdef	TEST
		NextData->Data[i] = 100*sin(6.28/Length*i*NumberOfFrames/80);
		if (NextData->Data[i] < 0)
			NextData->Data[i] = 0;
#else	
		if (Data[i] > MAX)
			Data[i] = MAX;
		NextData->Data[i] = Data[i]/MAX * 100;
#endif	TEST
	}
	NextData->Length = Length;
	NextData->Start = StartADCIndex;
	NextData->Next = NULL;
	LastBuffer->Next = NextData;
	LastBuffer = NextData;

	NumberOfFrames++;
	StartADCIndex += (DecimationFactor < 1)? 1 : DecimationFactor;

}

/* HACK---OK, now write out the data to the file.  First write out
 * all the headers and then send out the data.
 */
CloseOutputFile()
{
	SYNC	FrameInfo;
	int	Header[2], i = 0;
	struct	DataStruct *dp;

	rewind(ofp);
	Header[0] = -1;
	Header[1] = NumberOfFrames;
	Write32BitsHighLow(ofp,Header[0]);
	Write32BitsHighLow(ofp,Header[1]);

	for (dp = FirstBuffer.Next;dp;dp=dp->Next){
		Write32BitsHighLow(ofp,dp->Start);
		Write16BitsHighLow(ofp,256);	/* Fake it. */
		Write16BitsHighLow(ofp,(DecimationFactor < 1)?
					1 : DecimationFactor);
		Write16BitsHighLow(ofp, 0);	/* Don't know if pitch*/
		Write16BitsHighLow(ofp, dp->Length);	/* Spectral Size */
		Write32BitsHighLow(ofp, 0);	/* Frame */
		Write16BitsHighLow(ofp, 0);	/* Number of Energy Points */
		Write16BitsHighLow(ofp, 0);	/* Padding */
		Write32BitsHighLow(ofp, 0);	/* Energy and Extra Space */
		i++;
	}
	printf("Number of frames in output file %s is  %d (OGC Format).\n",
		FileName, i);

	for (dp = FirstBuffer.Next;dp;dp=dp->Next){
		for (i=dp->Length-1;i>=0;i--){
			Write16BitsHighLow(ofp, dp->Data[i]);
		}
	}
}
#endif	/* OGC */

#ifdef	SPHYNX

static	int	NumberOfFrames = 0;
static	char	*FileName;
static	FILE	*ofp;

OpenOutputFile(ofn)
char	*ofn;
{

        if (ofn && *ofn){
		FileName = ofn;
                ofp = fopen(ofn, "w");
                if (!ofp){
                        fprintf(stderr,
			    "OpenOutputFile: Can't open %s for output data.\n",
                                ofn);
                        exit(1);
                }
		Write32BitsHighLow(ofp,0);	/* Save room for byte count */
        }
}

#define	COS_LENGTH	13
static	float	(*CosTransform)[][COS_LENGTH] = 0;

WriteOutputFile(Data,Length)
float	*Data;
int	Length;
{
	int	f, i;
	float	result;

	if (!ofp)
		return;

	if (CosTransform == 0){
		printf("Computing the Sphynx cosine transform.\n");
		CosTransform = (float (*)[][COS_LENGTH])
				NewFloatArray(COS_LENGTH*Length);

		for (f = 0;f<COS_LENGTH;f++){
			for (i=0;i<Length;i++){
				(*CosTransform)[i][f] = 
					cos(PI*f*i/(float)Length);
			}
		}
		for (i=0;i<Length;i++)
			(*CosTransform)[i][0] *= 800000;

		picout("cos.transform", CosTransform, COS_LENGTH*Length);
	}

	for (f=0;f<COS_LENGTH;f++){
		result = 0.0;
#include	"ivdep.h"
		for (i=0;i<Length;i++){
			result += (*CosTransform)[i][f]*Data[i];
		}
		WriteIeeeFloatHighLow(ofp,result);
	}
	
	NumberOfFrames++;
}

/* HACK---OK, now write out the frame count to the file.
 */
CloseOutputFile()
{
	rewind(ofp);
						/* Number of Bytes */
	Write32BitsHighLow(ofp,4*COS_LENGTH*NumberOfFrames);	
	fflush(ofp);
	printf("Number of frames in output file %s is  %d (Sphynx Format).\n",
		FileName, NumberOfFrames);
}
#endif	/* SPHYNX */

!Funky!Stuff!
echo x - patterson.c
cat >patterson.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1990
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: patterson.c,v 1.1 90/12/17 18:04:20 malcolm Exp $
 *
 * $Log:	patterson.c,v $
 * Revision 1.1  90/12/17  18:04:20  malcolm
 * Initial revision
 * 
 */

static char     *RCSid = "$Header: patterson.c,v 1.1 90/12/17 18:04:20 malcolm Exp $";

/*
 *	This file calculates correlations of the signals produced by each 
 *	channel of the cochlea.  The output from these routines is called
 *	a correlogram.  This version uses an implementation suggested
 *	by Roy Patterson and presented at the Fall 1990 Acoustical Society
 *	of America Meeting in San Diego.
 *
 *	There are three types of routines in this file.  They are 
 *		Initialization
 *		Data Transmission
 *		Calculations
 *	The routine InitCorrelation must be called first so that space can
 *	be allocated to save the incoming data to be correlated.  A routine
 *	called SendInputToCorrelation is called for every sample output from
 *	the cochlear model to save the data for later correlation.   Finally
 *	the routine PattersonEarCorrelation gets the data ready for display.
 */

#include	<stdio.h>
#include	<math.h>
#include	"ear.h"
#include	"complex.h"
#include	"filter.h"

/*
 *	Decay Time Constants - There are two time constants in Roy's
 *	Triggered Temporal Integration correlogram.  The first is the
 *	frame rate (correlogram) decay rate.  This is the rate a single
 *	pixel in the correlogram frame decays to nothing.  The 
 *	PATTERSON_FRAME_DECAY_FACTOR is multiplied by the correlogram
 *	sampling rate (often 1/30Hz) to get the time constant for a
 *	one pole decay.
 *
 *	The threshold decays by a fixed amount every sample time.  The
 *	time constant of this delay is the same for all channels and is
 *	given by PATTERSON_THRESHOLD_TIME.  After each sample the threshold
 *	in each channel days by a factor that is a function of this threshold
 *	time.  It should be set to something on the order of the most common
 *	pitch.  But note, when a new threshold is computed for each channel 
 *	the current maximum is incremented by enough so that at the next 
 *	resonance of this channel we are still above the threshold.
 */

#define	PATTERSON_FRAME_DECAY_FACTOR	1.0
#define	PATTERSON_THRESHOLD_TIME	(1/200.0)

static int	CorrelationChannels;		/* Saved # of channels */

static int	CochleagramFifoIndex = 0;	/* Position in FIFO */

static float	*ChannelLocalMax;		/* Last Maximum seen */
static float	*ChannelThreshold;		/* Current Threshold Value */
static float	*ChannelThresholdCompensation;	/* Factor for new Threshold */
static int	*ChannelDecayTime;		/* Last time decayed */

static float	*CochleagramData;		/* Input FIFO Storage */
static float	*CorrelogramData;		/* Storage for Output */

static float    PattersonFrameDecayEpsilon;
static float	PattersonThresholdDecayEpsilon;

#define	CochleagramDataArray(Channel, Index) \
	(CochleagramData[(int32)(Channel)*CorrelogramWidth + \
	((int32)(CochleagramFifoIndex + (Index))%CorrelogramWidth)])
	
						/* How to access data in
						 * the output data array
						 */
#define	CorrelogramDataArray(Channel, Lag) \
	(Output[(int32)(Channel)*CorrelogramWidth + (Lag)])

						/* OK, let's decay a single
						 * output channel by the value
						 * PattersonDecayEpsilon
						 * for each sample since the
						 * last time we did it.  The
						 * last time we decayed the
						 * channel is stored in the
						 * ChannelDecayTime[i] array.
						 */
#define	DecayCorrelogramChannel(chan) { 				\
	register int	j; 						\
	register float	Factor = pow(PattersonFrameDecayEpsilon,	\
					(float)(SampleNumber-		\
					      ChannelDecayTime[chan])), \
			*fp = &CorrelogramData[chan*CorrelogramWidth];	\
									\
	for (j=0; j<CorrelogramWidth; j++) {				\
		fp[j] *= Factor; 					\
	} 								\
	ChannelDecayTime[chan] = SampleNumber;				\
}

						/*
						 * Add a channel's worth of
						 * data into the correlogram
						 * output array.
						 */

#define	AddInChannel(chan) {						\
	register int	j;						\
	register float *fp = &CorrelogramData[chan*CorrelogramWidth];	\
									\
	for (j=0; j<CorrelogramWidth; j++)				\
		fp[CorrelogramWidth-1-j] += CochleagramDataArray(chan, j);\
}

/*
 *	InitCorrelation - This routine should be called once to define the
 *	number of channels in the cochlear model and to set the number of 
 *	samples that should be saved.  The resolution of the correlogram
 *	is determined by the number of samples saved.
 */
PattersonInitCorrelation(Channels, Length, Between)
int	Channels, Length, Between;
{
	extern	int	UseUltra;
	register int	i;
	int32	PictureSize;

	CorrelogramWidth = Length;
	CorrelogramHeight = Channels;
	CorrelationChannels = Channels;
	PictureSize = CorrelogramWidth * CorrelogramHeight;

	if (Debug)
		printf("CorrelogramWidth is %d, Height is %d.\n",
			CorrelogramWidth, CorrelogramHeight);

	ChannelLocalMax = NewFloatArray((int32)CorrelationChannels,
					"PattersonInitCorrelation");
	ChannelThreshold = NewFloatArray((int32)CorrelationChannels,
					"PattersonInitCorrelation");
	ChannelThresholdCompensation = 
			NewFloatArray((int32)CorrelationChannels,
					"PattersonInitCorrelation");
	ChannelDecayTime = NewIntArray((int32)CorrelationChannels,
					"PattersonInitCorrelation");

	CochleagramData = NewFloatArray((int32)PictureSize,
					"PattersonInitCorrelation");
	CorrelogramData = NewFloatArray((int32)PictureSize,
					"PattersonInitCorrelation");

	if (!ChannelLocalMax || !ChannelThreshold || 
	    !ChannelThresholdCompensation || !ChannelDecayTime ||
	    !CorrelogramData || !CochleagramData){
		extern	char *progname;

		fprintf(stderr, 
			"%s: Can't allocate space for Patterson correlogram.\n",
			progname);
		exit(1);
	}
	
						/* Amount to decay each
						 * pixel in the correlogram
						 * after each sample arrives.
						 */
	PattersonFrameDecayEpsilon = 
		1 - EpsilonFromTauFS(PATTERSON_FRAME_DECAY_FACTOR*Between/
								sample_rate,
					sample_rate);

						/* Amount to decay each 
						 * channels' threshold after
						 * each sample arrives.
						 */
	PattersonThresholdDecayEpsilon = 
		1 - EpsilonFromTauFS(PATTERSON_THRESHOLD_TIME, sample_rate);

	if (Debug) {
		printf("PattersonFrameDecayEpsilon is %g.\n",  
			PattersonFrameDecayEpsilon);
		printf("PattersonThresholdDecayEpsilon is %g.\n",  
			PattersonThresholdDecayEpsilon);
	}


#include	"ivdep.h"
	for (i=0; i<CorrelationChannels; i++){
		ChannelLocalMax[i] = 0;
		ChannelThreshold[i] = 0;
		ChannelDecayTime[i] = 0;
		ChannelThresholdCompensation[i] = 
			pow(1/PattersonThresholdDecayEpsilon,
				sample_rate/EarChannelCF(i+2,sample_rate));
	}

#include	"ivdep.h"
	for (i=0; i<PictureSize;i++){
		CochleagramData[i] = 0.0;
		CorrelogramData[i] = 0.0;
	}

#ifndef	PLOT3D
	if (UseUltra){
		InitDisplay();
							/* Set both frame 
							 * buffers to blue.
							 */
		SetDisplayValue(80 + 80*256 + 255*256*256);
		UpdateDisplay(CorrelogramData,0,0,0.0,1.0);
		SetDisplayValue(80 + 80*256 + 255*256*256);
		UpdateDisplay(CorrelogramData,0,0,0.0,1.0);
	}
#endif	/* PLOT3D */
}

/*
 *	SendInputToCorrelation - This routine is called to pass an array of
 *	data from the cochlear model to the correlation routines.  The input
 *	array represents the firing rate of each channel of the cochlear model.
 *	The routine InitCorrelation should be called first to set the 
 *	parameters of the ear model.
 *
 *	The sequence of events is as follows:
 *		For each channel
 *			Check for Threshold Crossing
 *				This really means
 *				    New Data is bigger than ChannelThreshold
 *				or  New Data is less than ChannelLocalMax
 *				    (this works since ChannelLocalMax is
 *				     equal to zero until the Threshold is
 *				     crossed and then it is set to follow
 *				     the maximum.)
 *				Decay the Current Channel's values
 *				Add in New Channel (to all lags)
 *				Reset Threshold
 */
PattersonSendInputToCorrelation(Data)
float	Data[];
{
	register int	i;
	int	One = 1;
	static FILE	*debugfp = 0;

	for (i=0;i<CorrelationChannels;i++){
		if (Data[i] < ChannelLocalMax[i]){	/* Going down? */
			SystemCursor();
			DecayCorrelogramChannel(i);
			AddInChannel(i);
			ChannelThreshold[i] = ChannelLocalMax[i] *
				ChannelThresholdCompensation[i];
			ChannelLocalMax[i] = 0;
		} else {
			ChannelThreshold[i] *= PattersonThresholdDecayEpsilon;
		}
		if (Data[i] > ChannelThreshold[i])	/* Crossed Threshold? */
			ChannelLocalMax[i] = Data[i];
	}

	VMOV(Data,&One,&CorrelogramHeight,
		CochleagramData+CochleagramFifoIndex,&CorrelogramWidth);

	CochleagramFifoIndex = (CochleagramFifoIndex + 1) % CorrelogramWidth;

	if (Debug) {
		if (!debugfp)
			debugfp = fopen("thresh","w");
	
#define	CHAN	40
		fprintf(debugfp, "%g %g\n", Data[CHAN], ChannelThreshold[CHAN]);
	}
}

CheckCochleagram(place)
char	*place;
{
	int	i;

#ifdef	TEST
	for (i=0; i<CorrelogramWidth*CorrelogramHeight;i++){
		if (CochleagramData[i] > 1.0){
			printf("%s: Found bad cochleagram data %g at sample %d",
				place, CochleagramData[i], SampleNumber);
			printf(", channel %d.\n", i/CorrelogramWidth);
			exit(2);
		}
	}
#endif	/* TEST */
}

double
PattersonEarCorrelation(Output)
float	*Output;
{
	float	Max;
	
	if (UseUltra || cfn){
		register int	i;
		register float	*inp, *outp;
		int	Count = CorrelogramHeight * CorrelogramWidth;

		for (i=0;i<CorrelogramHeight;i++)
			DecayCorrelogramChannel(i);

		Max = .004;

		inp = CorrelogramData;
		outp = Output;
#include	"ivdep.h"
		for (i=0; i<Count; i++)
			*outp++ = *inp++;

/*
		picout("cochlea.pic", CochleagramData, Count);
		picout("correlogram.pic", CorrelogramData, Count);
		printf("SampleNumber is %d.\n", SampleNumber);

		exit(1);
 */

		if (UseUltra)
			UpdateDisplay(Output,CorrelogramWidth,
				CorrelogramHeight, 0.0, Max);
	}
	picout("threshold.pic", ChannelThreshold, 
				CorrelationChannels);
	return(Max);
}

!Funky!Stuff!
echo x - picout.c
cat >picout.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: picout.c,v 2.3 90/12/17 18:04:51 malcolm Exp $
 *
 * $Log:	picout.c,v $
 * Revision 2.3  90/12/17  18:04:51  malcolm
 * Added include of fcntl.h for ThinkC and changed some max's to Max to
 * keep some preprocessors happy.
 * 
 * Revision 2.2  90/11/06  20:53:51  malcolm
 * Added check to make sure the max and min are not equal.
 * 
 * Revision 2.1  89/11/09  23:08:53  malcolm
 * Fixed some unused variables.
 * 
 * Revision 2.0.1.1  89/08/14  11:10:28  malcolm
 * Fixed problem with 16 bit ints (!!$@#$!#$) for LightSpeed when writing
 * binary data with write() system call.
 * 
 * Revision 2.0  89/07/25  18:58:53  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.5  89/07/19  12:49:53  malcolm
 * Changed name of preprocessor flags that control output mode.
 * 
 * Revision 1.4  89/06/20  22:47:52  malcolm
 * Added support for LightSpeed C by changing a bunch of ints to int32.
 * Also added output routine called BytePicout so that byte files could
 * be quantized and output.
 * 
 * Revision 1.3  88/12/06  21:15:19  malcolm
 * Added support (compile time option) for ascii output.
 * 
 * Revision 1.2  88/11/04  16:58:08  malcolm
 * Added missing endif for MAIN.
 * 
 * Revision 1.1  88/10/23  22:43:24  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: picout.c,v 2.3 90/12/17 18:04:51 malcolm Exp $";

/*
 *	Debugging file output.
 */

#include	<stdio.h>
#include	<fcntl.h>
#include	"ear.h"

#ifdef	THINK_C
#include	<unix.h>
#endif	/* THINK_C */

picout(name,pic,num)
char	*name;
float	*pic;
int32	num;
{
	int	output;

#ifndef	TEXTOUTPUT
#ifdef	THINK_C
	if ((output = creat(name,O_WRONLY+O_CREAT+O_TRUNC+O_BINARY)) >= 0){
		num *= sizeof(*pic);
		while (num > 0){
			int	writenum;

			writenum = num>32000 ? 32000 : num;
			num -= writenum;
			if (write(output,(char *)pic,(unsigned int)writenum)
					!= writenum){
				extern int	errno;
				printf(
				 "Error %d in the write of %ld bytes to %s.\n",
					errno, (long)num, name);
				exit(0);
			}
		}
		close(output);
	}
#else
	if ((output = creat(name,0644)) >= 0){
		num *= sizeof(*pic);
		if (write(output,pic,(unsigned int)num) != num){
			extern int	errno;
			printf("Error %d in the write of %ld bytes to %s.\n", 
				errno, (long)num, name);
			exit(0);
		}
		close(output);
	} 
#endif	/* THINK_C */
#else	/* !TEXTOUTPUT */
	FILE	*fp;
	
	if ((fp = fopen(name,"w")) != NULL){
		int	i;
		for (i=0;i<num;i++){
			fprintf(fp,"%g\t",pic[i]);
			if (i%4 == 3)
				fprintf(fp,"\n");
		}
		fprintf(fp,"\n");
		fclose(fp);
	}
#endif	/* TEXTOUTPUT */
	else {
		fprintf(stderr, "Couldn't open %s for creating picture output.\n",
				name);
		exit(1);
	}
}

BytePicout(name, pic, num, Min, Max)
char	*name;
float	*pic;
int32	num;
float	Min, Max;
{
	FILE	*fp;
	register int	ch;
	register int32	i;
	register float	gain;
	
	if (Max-Min == 0)
		gain = 0;
	else
		gain = 255.0/(Max-Min);
	
	if (fp = fopen(name,"w")){
		for (i=0;i<num;i++,pic++){
			ch = (*pic - Min)*gain;
			if (ch < 0)
				putc(0,fp);
			else if (ch > 254)
				putc(255,fp);
			else
				putc(ch,fp);
		}
		fclose(fp);
	}
	else {
		fprintf(stderr, "Couldn't open %s for creating picture output.\n",
				name);
		exit(1);
	}
}
	
	
	
	
#ifdef	MAIN

#include	<math.h>
float	a[64][64];

main(){
	int	i, j;

	for (i=0;i<64;i++)
		for (j=0;j<64;j++){
			float	radius;
			radius = sqrt((float)i*i+j*j);
			a[i][j] = sin(radius/4.0)*(1-radius/128.0);
		}
	picout("sin.pic",a,64*64);
}

#endif	/* MAIN */
!Funky!Stuff!
echo x - script.c
cat >script.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: script.c,v 2.2 90/11/06 20:54:53 malcolm Exp $
 *
 * $Log:	script.c,v $
 * Revision 2.2  90/11/06  20:54:53  malcolm
 * Changed copyright messsage.
 * 
 * Revision 2.1  89/11/09  23:16:35  malcolm
 * Rewrote video starting condition (when starting in the middle.)
 * 
 * Revision 2.0  89/07/25  18:58:55  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 *
 */

static char	*RCSid = "$Header: script.c,v 2.2 90/11/06 20:54:53 malcolm Exp $";

#include	<stdio.h>
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

#define	IMPULSE_HEIGHT .0001

main(argc,argv)
int	argc;
char	**argv;
{
	int	i;
	FILE	*ofp;

	progname = *argv;
	while(argv++ , --argc){
		if (**argv == '?')
			syntax();
		if(( **argv=='-' || **argv=='+')&& argv[0][1]) {
			ProcessOption(*argv);
		}else {
			ProcessArgument(*argv);
		}
	}
	
	inittimers();

	Animation2();
}

Animation1()
{
	register int	i;
	int	one = 1, two = 2, three = 3, four = 4, Channel;
	float	Output[MaxN], *Sound, GETAGC();
	float	*Data, *ReadInputFile();

	UseDifference = 0;
	DecimationFactor = 1;
	
	if (ImpulseInput){
		DataLength = 512;
		Data = (float *)calloc(DataLength, sizeof(*Data));
		Data[0] = IMPULSE_HEIGHT;
	} else {
		float 	*Signal;
		Signal = ReadInputFile(ifn, &sample_rate, &DataLength);
		Data = (float *) malloc(3*DataLength*sizeof(*Data));
		for (i=0;i<DataLength;i++)
			Data[i] = Data[i+DataLength] = Data[i+2*DataLength] =
				Signal[i];
		DataLength *= 3;
	}

	ChangeDecimationParameters();
	ChangeAgcParams();

	DesignEarFilters();

#ifdef	MINUSG
	CPUs = 1;
#endif	/* MINUSG */

#ifdef CRAY
	if (CPUs > 1 && (UseUltra || cfn) ){	
		printf("Getting %d cpus.\n", CPUs);
		GETCPUS(&CPUs);
	}
#endif	/* CRAY */

/*
	AgcStage1Tau = AgcStage2Tau = AgcStage3Tau = AgcStage4Tau = 1000000;
 */

	if (printflag){
		PrintStats();
	}

	Sound = (float *)malloc(DataLength*sizeof(*Data));

	for (i=0;i<DataLength;i++){
		SystemCursor();
		SampleNumber = i;

		starttimer(10);
		EARSTEP(&Data[i], Output);
		endtimer(10);
		Channel = (i*EarLength)/DataLength+1;
		Sound[i] = Output[Channel] ;
	}
	WriteADCFile(ofn, sample_rate, DataLength, Sound);

	printtimers();
}

#define	Between(a,b,c)	((a > b && a < c) || (a < b && a > c))

Median(Data,Length)
float	*Data;
int	Length;
{
	register int	i;
	register float a, b, c, save;

	save = Data[0];
	for (i=1;i<Length-1;i++){
		a = Data[i-1];
		b = Data[i];
		c = Data[i+1];
		Data[i-1] = save;
		if (Between(a,b,c))
			save = a;
		else if (Between(c,a,b))
			save = c;
		else
			save = b;
	}
}

Animation2()
{
	int	LineCount = 0;
	int	CorrelationLineCount = 0, CorrelationPictureCount = 0;
	int	CorrelationOutputSize;
	float	*CorrelationOutput = NULL, *CorrelationZero = NULL;
	float	*Data, *ReadInputFile();
	register int	i;
	float	Output[MaxN], SamplesPerFrame, SamplesToNextFrame;

	cfn = ofn = "";
	UseUltra = 1;
	TauFactor= 1;
	DecimationFactor= 1;
	CorrelationLags = 512;
	Normalization = .5;
	EarQ = 4;
	EarStepFactor = .125;

	if (ImpulseInput){
		DataLength = 512;
		Data = (float *)calloc(DataLength, sizeof(*Data));
		Data[0] = IMPULSE_HEIGHT;
	} else {
		Data = ReadInputFile(ifn, &sample_rate, &DataLength);
	}

	ChangeDecimationParameters();
	ChangeAgcParams();

	DesignEarFilters();

#ifdef	MINUSG
	CPUs = 1;
#endif	/* MINUSG */

#ifdef CRAY
	if (CPUs > 1 && (UseUltra || cfn) ){	
		printf("Getting %d cpus.\n", CPUs);
		GETCPUS(&CPUs);
	}
#endif	/* CRAY */

	if (printflag){
		PrintStats();
	}

	InitCorrelation(EarLength-2, 2*CorrelationLags);
	CorrelationOutputSize = (EarLength + 10) * 
				CorrelationLags;
	CorrelationOutput = (float *)
				malloc(CorrelationOutputSize*
				sizeof(CorrelationOutput[0]));
	if (!CorrelationOutput){
		fprintf(stderr, 
			"%s: Couldn't get %d bytes for correlation output.\n",
			"Correlation Animation", CorrelationOutputSize);
		exit(2);
	}

	SamplesPerFrame = sample_rate/29.985;
	SamplesToNextFrame = SamplesPerFrame;
	printf("sample_rate is %g, SamplesPerFrame is %g.\n",
		sample_rate, SamplesPerFrame);
	
	OpenConnection("dumbo");
	SendCommandToRemote("setenv WF_RECDEV diaq");

	for (i=0;i<DataLength;i++){
		SampleNumber = i;
		starttimer(10);
		EARSTEP(&Data[i], Output);
		endtimer(10);
		SendInputToCorrelation(Output+2);

		SamplesToNextFrame--;
		if (SamplesToNextFrame < 0){
			extern int	FrameNumber;
			SamplesToNextFrame += SamplesPerFrame;

			EarCorrelation(CorrelationOutput, 
					CorrelationLags);
			if (SampleNumber/sample_rate > -1.0)
				RecordVideo();
			else
				printf("Skipping frame %d.\n",FrameNumber++);
			CorrelationPictureCount++;
		}
	}
	printtimers();
}


int	FrameNumber = 0;

RecordVideo(){
	int	i;
	extern	int	errno;
	FILE	*fp;


#ifdef	OLD
	i = system("/usr/ucb/remsh dumbo 'setenv WF_RECDEV diaq;/usr/local/wave/bin/record'");
/*
	i = system("/usr/ucb/remsh dumbo 'date'");
	*/
	if (i){
		printf("%d: system returns %d (errno is %d).\n",FrameNumber,
			i,errno);
		exit(1);
	} else {
		printf("Finished frame %d.\n", FrameNumber);
	}
	WaitForFrameBuffer();
#endif	OLD

	SendCommandToRemote("/usr/local/wave/bin/record");
	
	fp = fopen(".frame","w");
	if (fp){
		fprintf(fp,"%d\n", FrameNumber);
		fclose(fp);
	}
	FrameNumber++;
/*
	char	Buffer[512];
	int	i;
	printf("Recording a frame.....");
	clearerr(stdin);
	i = fgets(Buffer,512,stdin);
	printf("fgets got *%d*\n",i);
 */
}

#define	WAITFILE	"/tmp/stopanimation"

WaitForFrameBuffer(){
	FILE	*fp;

	fp = fopen(WAITFILE,"r");
	if (fp){
		fclose(fp);
		printf("Found %s....waiting.\n", WAITFILE);
		while (fp = fopen(WAITFILE,"r")){
			fclose(fp);
			sleep(1);
		}
		printf("Resuming animation.\n");
	}
}
!Funky!Stuff!
echo x - shamma.c
cat >shamma.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: shamma.c,v 1.4 90/12/17 18:05:21 malcolm Exp $
 *
 * $Log:	shamma.c,v $
 * Revision 1.4  90/12/17  18:05:21  malcolm
 * Cleanup correlogram code for MacEar release 2.1
 * 
 * Revision 1.3  90/11/06  20:55:00  malcolm
 * Added some debugging code.
 * 
 * Revision 1.2  90/01/28  15:24:04  malcolm
 * WORKING and TESTED version.  As near as I can tell this version of
 * the Shamma correlogram is working as well as can be expected.  All
 * delay values and best frequencies have been verified.
 * 
 * Revision 1.1  90/01/16  14:24:07  malcolm
 * Initial revision
 *
 *
 */

static char     *RCSid = "$Header: shamma.c,v 1.4 90/12/17 18:05:21 malcolm Exp $";

/*
 *	This file calculates correlations of the signals produced by each 
 *	channel of the cochlea.  The output from these routines is called
 *	a correlogram.  This version uses an implementation first suggested
 *	by Shihab A. Shamma in the following article
 *		"Stereausis:  Binaural processing without neural delays,"
 *		by Shihab Shamma, Naiming Shen and Preetham Gopalaswamy,
 *		Journal of the Acousical Society of America, Volume 86,
 *		Number 3, September 1989, pp 989-1006.
 *
 *	There are three types of routines in this file.  They are 
 *		Initialization
 *		Data Transmission
 *		Calculations
 *	The routine InitCorrelation must be called first so that space can
 *	be allocated to save the incoming data to be correlated.  A routine
 *	called SendInputToCorrelation is called for every sample output from
 *	the cochlear model to save the data for later correlation.  Finally
 *	several routines are provided to calculate the correlation.  The 
 *	different routines use algorithms with varying degrees of robustness
 *	and speed.
 */

#include	<stdio.h>
#include	<math.h>
#include	"ear.h"
#include	"complex.h"
#include	"filter.h"

#ifndef	PI
3.141592653589793234
#endif	/* PI */

static int	CorrelationChannels = 0;		/* Number of Channels
							 */

							/* How to access data 
							 * in the output data 
							 * array
							 */
#define	OutputDataArray(Channel, Lag) \
	(ShammaData[(int32)((Lag)*CorrelationChannels + (Channel))])

static	float	*ShammaData;
static	float	NextWeight, LastWeight;
						/*
						 * Storage for interpolated
						 * data.
						 */
static	float	*ExpandedData;			
#define	FACTOR	1

#define	BestFreq(Channel, Lag) \
     (BestFreqArray[(int32)((Lag)*CorrelationChannels + (Channel))])
static	float	*BestFreqArray;

						/*
						 * Storage for the Shamma
						 * transformation.
						 */
#define	Transform(Delay,Freq) \
     (TransformArray[(int32)(Freq) * CorrelationChannels + (Delay)])

static	int	*TransformArray;

/*
 *	InitCorrelation - This routine should be called once to define the
 *	number of channels in the cochlear model and to set the number of 
 *	samples that should be saved.  The resolution of the correlogram
 *	is determined by the number of samples saved.
 */
ShammaInitCorrelation(Channels, Length, Between)
int	Channels, Length, Between;
{
	extern	char	*progname;
	extern	int	UseUltra;
	extern	int	CorrelationStep;
	extern float	EpsilonFromTauFS();
	register int	i, j;

	CorrelogramWidth = CorrelogramHeight = CorrelationChannels = Channels;

	ShammaData = NewFloatArray((int32)Channels*Channels,
					"ShammaInitCorrelation");

	ExpandedData = NewFloatArray((int32)ceil(FACTOR*Channels), 
					"ShammaInitCorrelation");

#ifndef	PLOT3D
	if (UseUltra){
		InitDisplay();
							/* Set both frame 
							 * buffers to blue.
							 */
		SetDisplayValue(80 + 80*256 + 255*256*256);
		UpdateDisplay(ShammaData,0,0,0.0,1.0);
		SetDisplayValue(80 + 80*256 + 255*256*256);
		UpdateDisplay(ShammaData,0,0,0.0,1.0);
	}
#endif	/* PLOT3D */
	
	NextWeight = EpsilonFromTauFS(2.0*Between,1.0);
	LastWeight = 1.0 - NextWeight;

/*	if (TransformCorrelogram) */ {
		ComputeShammaTransform();
/*		ColorShammaTransform();	*/
	}
}

/*
 *	SendInputToCorrelation - This routine is called to pass an array of
 *	data from the cochlear model to the correlation routines.  The input
 *	array represents the firing rate of each channel of the cochlear model.
 *	The routine InitCorrelation should be called first to set the 
 *	parameters of the ear model.
 */
ShammaSendInputToCorrelation(Data)
float	Data[];
{
	register int	lChannel, i;
	register float	t;

#include	"ivdep.h"
	for (i=0;i<CorrelationChannels*FACTOR;i++){
		int	Index;
		float	Point;
		float	LeftFactor, RightFactor;

		Point = (float)i/(float)FACTOR;
		Index = (int)Point;
		RightFactor = Point - Index;
		LeftFactor = 1 - RightFactor;
		ExpandedData[i] = Data[Index]*LeftFactor + 
					Data[Index+1]*RightFactor;
	}

	for (lChannel=0; lChannel<CorrelationChannels; lChannel++){
		int	Middle = CorrelationChannels/2;
#include	"ivdep.h"
		for (i=0; i<=lChannel; i++){
			t = Data[lChannel] * ExpandedData[
						(int)(FACTOR*lChannel-i)];
			OutputDataArray(lChannel-i,lChannel) = 
			    OutputDataArray(lChannel,lChannel-i) = 
				OutputDataArray(lChannel-i,lChannel)*LastWeight+
						t*NextWeight;
		}
	}
}

#define	Out(x,y) (Output[((y)*Lags)+(x)])
#define	Sout(x,y) (SharpOutput[((y)*Lags)+(x)])

SharpenResponse(Output, SharpOutput, Lags)
float	*Output, *SharpOutput;
int	Lags;
{
	register int	x, y;

	for (x=0;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags;y++)
			Sout(x,y) = 0.0;

	for (x=1;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags-3;y++)
			Sout(x,y) += Out(x-1,y+3);
	for (x=2;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags-2;y++)
			Sout(x,y) += (float)1 * Out(x+-2,y+2);
	for (x=0;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags-2;y++)
			Sout(x,y) += (float)-3 * Out(x+0,y+2);
	for (x=3;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags-1;y++)
			Sout(x,y) += (float)1 * Out(x+-3,y+1);
	for (x=1;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags-1;y++)
			Sout(x,y) += (float)-3 * Out(x+-1,y+1);
	for (x=0;x<Lags-1;x++)
#include	"ivdep.h"
		for (y=0;y<Lags-1;y++)
			Sout(x,y) += (float)5 * Out(x+1,y+1);
	for (x=2;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags;y++)
			Sout(x,y) += (float)-3 * Out(x+-2,y+0);
	for (x=0;x<Lags;x++)
#include	"ivdep.h"
		for (y=0;y<Lags;y++)
			Sout(x,y) += (float)5 * Out(x+0,y+0);
	for (x=0;x<Lags-2;x++)
#include	"ivdep.h"
		for (y=0;y<Lags;y++)
			Sout(x,y) += (float)-3 * Out(x+2,y+0);
	for (x=1;x<Lags;x++)
#include	"ivdep.h"
		for (y=1;y<Lags;y++)
			Sout(x,y) += (float)5 * Out(x+-1,y-1);
	for (x=0;x<Lags-1;x++)
#include	"ivdep.h"
		for (y=1;y<Lags;y++)
			Sout(x,y) += (float)-3 * Out(x+1,y-1);
	for (x=0;x<Lags-3;x++)
#include	"ivdep.h"
		for (y=1;y<Lags;y++)
			Sout(x,y) += (float)1 * Out(x+3,y-1);
	for (x=0;x<Lags;x++)
#include	"ivdep.h"
		for (y=2;y<Lags;y++)
			Sout(x,y) += (float)-3 * Out(x+0,y-2);
	for (x=0;x<Lags-2;x++)
#include	"ivdep.h"
		for (y=2;y<Lags;y++)
			Sout(x,y) += (float)1 * Out(x+2,y-2);
	for (x=0;x<Lags-1;x++)
#include	"ivdep.h"
		for (y=3;y<Lags;y++)
			Sout(x,y) += (float)1 * Out(x+1,y-3);
}
			 
static	int TransformDebugged = 0;
/*
 *	EarCorrelation - This routine is actually called from the main program
 *	to display the correlations.  
 */
double
ShammaEarCorrelation(Output)
float	*Output;
{
	float	Max;
	extern	int	UseUltra;
	
	if (UseUltra || cfn){
		char	PlotBuffer[BUFSIZ];
		int	i, Channel;

		starttimer(7);

		if (SharpResponse){
			static float	*SharpBuffer = 0;
			
			if (!SharpBuffer)
				SharpBuffer = 
				    NewFloatArray((int32)CorrelationChannels*
							CorrelationChannels,
							"ShammaEarCorrelation");

			if (TransformCorrelogram){
				extern	int	SampleNumber;

				SharpenResponse(ShammaData,SharpBuffer,
						CorrelationChannels);
#ifdef	POKEATSHAMMA
				if (SampleNumber>11000 && !TransformDebugged
						&& UseUltra){
					Max = 0;
					TransformDebugged = 1;
					for (i=0;i<CorrelationChannels*
						CorrelationChannels;i++){
						if (Output[i] > Max)
							Max = Output[i];
					}
					PokeAtCorrelogram(SharpBuffer,Max);
				}
#endif	/* POKEATSHAMMA */
				ResampleCorrelogram(SharpBuffer,Output,
				    TransformArray,
				    CorrelationChannels*CorrelationChannels);
			} else {
				extern int	SampleNumber;
				SharpenResponse(ShammaData,Output,
						CorrelationChannels);
#ifdef	POKEATSHAMMA
				if (SampleNumber>11000 && !TransformDebugged
						&& UseUltra){
					Max = 0;
					TransformDebugged=1;
					for (i=0;i<CorrelationChannels*
						CorrelationChannels;i++){
						if (Output[i] > Max)
							Max = Output[i];
					}
					PokeAtCorrelogram(Output,Max);
				}
#endif	/* POKEATSHAMMA */
			}
		} else {
			extern int	SampleNumber;
			if (TransformCorrelogram)
				ResampleCorrelogram(ShammaData,Output,
				    TransformArray,
				    CorrelationChannels*CorrelationChannels);
			else {
#include	"ivdep.h"
				for (i=0;
				     i<CorrelationChannels*CorrelationChannels;
				     i++)
					Output[i] = ShammaData[i];
			}
#ifdef	POKEATSHAMMA
			if (SampleNumber>11000 && !TransformDebugged
					&& UseUltra){
				Max = 0;
				TransformDebugged=1;
				for (i=0;i<CorrelationChannels*
					CorrelationChannels;i++){
					if (Output[i] > Max)
						Max = Output[i];
				}
				PokeAtCorrelogram(Output,Max);
			}
#endif	/* POKEATSHAMMA */
		}

#ifdef	PLOT3D
#define	TmpFile	"/tmp/correlogram"
#define	PlotCommand "/v/malcolm/bin/plot3d z=/tmp/correlogram xsize=%d ysize=%d xskip=1 zmax=%g -P yp=5 scfac=.5 tl=\"%10.5f\" phi1=-40 | oultraplot -a"
		sprintf(PlotBuffer,PlotCommand,Lags,CorrelationChannels,
		    AgcStage4Target*sqrt(2.0*CorrelationLags)*10*UltraHeadroom,
		    SampleNumber/sample_rate);
	        Output[Lags*(CorrelationChannels-1)] = 
		    AgcStage4Target*sqrt(2.0*CorrelationLags)*10*UltraHeadroom;
		

		picout(TmpFile,Output,Lags*CorrelationChannels);
		printf("%s\n", PlotBuffer);
		i = system(PlotBuffer);
		if (i < 0){
		     fprintf(stderr,"System() failed.  Try setenv NCPUS=1\n");
		     exit(1);
		}
#else	/* !PLOT3D */
		Max = 0;
		for (i=0;i<CorrelationChannels*CorrelationChannels;i++){
			if (Output[i] > Max)
				Max = Output[i];
		}

		if (UseUltra)
			UpdateDisplay(Output,CorrelationChannels,
				CorrelationChannels, 0.0, Max/8);
#endif	/* PLOT3D */
		endtimer(7);
	}
	return(Max/8);
}

/*
 * CalculateBestFreq - Calculate the best frequency for each position
 *	in the Shamma correlogram.  This is done by simplying averaging
 *	the center frequency of the left and right channel.  The output
 *	of this routine is an array called BestFreqArray (or just BestFreq)
 *	that gives the best frequency as a function of the two channel
 *	indices.
 */

CalculateBestFreq()
{
	int	channel, delta, i;
	float	ChannelFreq[FACTOR*MaxN];
	int	Index;
	float	Point, LeftFrac, RightFrac;

	BestFreqArray = NewFloatArray((int32)CorrelationChannels*
						CorrelationChannels,
					"CalculateBestFreq");

#include	"ivdep.h"
	for (i=0;i<FACTOR*CorrelationChannels;i++){
		Point = i/(float)FACTOR;
		Index = Point;
		RightFrac = Point - Index;
		LeftFrac = 1.0 - RightFrac;
		
		ChannelFreq[i] = LeftFrac*EarChannelCF(Index,sample_rate) + 
				RightFrac*EarChannelCF(Index+1,sample_rate);
	}

	for (channel = 0; channel < CorrelationChannels; channel++){
#include	"ivdep.h"
		for (delta = 0; delta <= channel; delta++){
			BestFreq(channel,channel-delta) =
			 BestFreq(channel-delta,channel) =  /* 1000;	*/
			   sqrt(ChannelFreq[(int)floor(channel*(float)FACTOR)]*
			         ChannelFreq[(int)floor(channel*(float)FACTOR - 
							              delta)]);
		}
	}

	picout("bestfreq.pic",BestFreqArray,
				CorrelationChannels*CorrelationChannels);
}

/*
 *	ComputeChannelDelays - Find the delay between any two channels.
 *		First find the delay at each channel as a function of
 *		frequency (We sample the frequency axis at the center
 *		frequency of each filter stage.  There is nothing magical
 *		about these frequencies but they do have the right spacing.)
 *		We convert this delay into sample times (or pixels in the
 *		correlogram.  Note, this delay includes both the frequency
 *		dependent delay due to the filter but also the one sample
 *		delay due to the cascade of filters.  The output of this
 *		half of the routine is stored in the TotalDelayArray and
 *		is indexed by channel number and by frequency index.
 *
 *		Finally, we compute the difference in delay due to two
 *		different channels in the correlogram.  We do this by
 *		getting the delay at the best frequency for this pixel in
 *		the correlogram (for each of the two channels) and using 
 *		bilinear interpolation to get the real value.
 *
 *		The output of this routine is stored in an array called 
 *		DeltaDelayArray (or just DeltaDelay).
 */
#define	TotalDelay(Channel, Freq) \
     (TotalDelayArray[(int32)((Freq)* CorrelationChannels + (Channel))])

static	float	*TotalDelayArray;

#define	DeltaDelay(lChannel, rChannel) \
     (DeltaDelayArray[(int32)((rChannel)*CorrelationChannels + (lChannel))])

static	float	*DeltaDelayArray;

ComputeChannelDelays()
{
	int	channel, freqindex;
	int	lChannel, rChannel, Index;
	float	Freq, LeftFreq, RightFreq, Left, Right;
	float	LeftDelay, RightDelay, Factor;

	TotalDelayArray = NewFloatArray((int32)CorrelationChannels*
							CorrelationChannels,
					"ComputeChannelDelays");

	for (freqindex = 0;freqindex<CorrelationChannels;freqindex++){
		float	Freq, SamplePhaseDelay, ChannelDelay;
		Freq = EarChannelCF(freqindex,sample_rate);
/*		Freq = 1000.0;			/* Keep everything fixed */
		SamplePhaseDelay = 1;		/* In samples */
#include	"ivdep.h"
		for (channel=0;channel<CorrelationChannels;channel++){
						/* 
						 * Need to disregard the
						 * first two channels of
						 * preemphasis.
						 */
			ChannelDelay = 
				cphase(FilterGain(&EarFilterArray[channel+2],
					Freq))/(2*PI*Freq/sample_rate);
/*			ChannelDelay = 0;	   TESTING	*/

						/* Sum up the effect due
						 * to previous channels
						 */
			if (channel == 0)
				TotalDelay(channel,freqindex) = ChannelDelay;
			else
				TotalDelay(channel,freqindex) = ChannelDelay + 
					TotalDelay(channel-1,freqindex) -
					SamplePhaseDelay;
		}
	}

	picout("TotalDelay.pic",TotalDelayArray,
				CorrelationChannels*CorrelationChannels);

	DeltaDelayArray = NewFloatArray((int32)CorrelationChannels*
						CorrelationChannels,
						"DeltaDelayArray");

	for (lChannel=0;lChannel<CorrelationChannels;lChannel++){
#include	"ivdep.h"
		for (rChannel=0;rChannel<=lChannel;rChannel++){
			Freq = BestFreq(lChannel,rChannel);

						/* Now interpolate wrt
						 * to frequency (since we
						 * have an integer channel)
						 *
						 * First find the position in
						 * the TotalDelay array
						 * and then we can do a bilinear
						 * interpolation
						 */

			Index = ChannelIndex(Freq);
			LeftFreq = EarChannelCF(Index,sample_rate);
			RightFreq = EarChannelCF(Index+1,sample_rate);
			if (Freq > LeftFreq || Freq < RightFreq ){
				printf("At (%d,%d) Freq is %g, LeftFreq is %g, RightFreq is %g.\n",
					lChannel,rChannel,Freq,LeftFreq,RightFreq);
			}
			Right = Factor = (Freq-LeftFreq)/(RightFreq-LeftFreq);
			Left = 1-Factor;
			if (Index+1 < CorrelationChannels) {
				LeftDelay = Left*TotalDelay(lChannel,Index) + 
					   Right*TotalDelay(lChannel,Index+1);
				RightDelay = Left*TotalDelay(rChannel,Index) + 
					   Right*TotalDelay(rChannel,Index+1);
			} else {
				LeftDelay = TotalDelay(lChannel,Index);
				RightDelay = TotalDelay(rChannel,Index);
			}

			DeltaDelay(rChannel,lChannel) = 
				DeltaDelay(lChannel,rChannel) = 
				fabs(RightDelay-LeftDelay);
#ifdef	POKEATSHAMMA
			if (lChannel==61 && rChannel==57){
				printf("EarChannelCF[0,160000] is %g.\n",
					EarChannelCF(0,16000));
				printf("EarChannelCF[1,160000] is %g.\n",
					EarChannelCF(1,16000));
				printf("Index is %d.\n", Index);
				printf("BestFreq is %g.\n", Freq);
				printf("TotalDelay(%d,%d) is %g.\n",
				 lChannel,Index,TotalDelay(lChannel,Index));
				printf("TotalDelay(%d,%d) is %g.\n",
				 lChannel,Index+1,TotalDelay(lChannel,Index+1));
				printf("TotalDelay(%d,%d) is %g.\n",
				 rChannel,Index,TotalDelay(rChannel,Index));
				printf("TotalDelay(%d,%d) is %g.\n",
				 rChannel,Index+1,TotalDelay(rChannel,Index+1));
				printf("Left and Right Freq are %g and %g.\n",
					LeftFreq, RightFreq);
				printf("Left and Right Factors are %g, %g.\n",
					Left, Right);
				printf("LeftDelay is %g.\n", LeftDelay);
				printf("RightDelay is %g.\n", RightDelay);
				printf("Filter 0 is:\n");
				PrintFilter(&EarFilterArray[0]);
				printf("Filter 1 is:\n");
				PrintFilter(&EarFilterArray[1]);
				printf("Filter 2 is:\n");
				PrintFilter(&EarFilterArray[2]);
				printf("Filter 3 is:\n");
				PrintFilter(&EarFilterArray[3]);
				printf("Filter 82 is:\n");
				PrintFilter(&EarFilterArray[82]);
			}
#endif	/* POKEATSHAMMA */
		}
	}

	free(TotalDelayArray);			/* Don't need this anymore */
	picout("DeltaDelay.pic",DeltaDelayArray,
			CorrelationChannels*CorrelationChannels);
}

FindBestPixel(Delay,Freq)
float	Delay, Freq;
{
	register int	i;
	int	num, skip;
	static	float *ErrorArray = 0;
	float	s, t;

	if (!ErrorArray)
		ErrorArray = NewFloatArray(CorrelationChannels*
						CorrelationChannels,
						"FindBestPixel");

#include	"ivdep.h"
	for (i=0;i<CorrelationChannels*CorrelationChannels;i++){
		s = DeltaDelayArray[i] - Delay;
		t = BestFreqArray[i] - Freq;
		ErrorArray[i] = sqrt(10000*s*s+t*t);
	}

	num = CorrelationChannels*CorrelationChannels;
	skip = 1;
	i = ISMIN(&num, ErrorArray, &skip) - 1;
	if (ErrorArray[i] > 300)
		return 0;
	return i;
}

ComputeShammaTransform()
{
	int	Freq, Delay;

	CalculateBestFreq();
	ComputeChannelDelays();

	TransformArray = NewIntArray((int32)CorrelationChannels*
					CorrelationChannels,
					"ComputeShammaTransform");
	
	for (Freq=0;Freq < CorrelationChannels;Freq++){
		for (Delay=0;Delay < CorrelationChannels;Delay++){
		    Transform(Delay,Freq) = 
			    FindBestPixel((float)Delay,
			   		 EarChannelCF(Freq,sample_rate));
		}
	}
	picout("transform.pic",TransformArray,
			CorrelationChannels*CorrelationChannels);
}

			 
	
ResampleCorrelogram(Old, New, Transformation, Num)
float	*Old, *New;
int	*Transformation, Num;
{
	register int i;

	Old[0] = 0.0;

#include	"ivdep.h"
	for (i=0;i<Num;i++)
		New[i] = Old[Transformation[i]];
}


TestShammaTransform(){
	int	x = 42, y = 42;
	register int	i;
	float	*OutputBuffer;

	OutputBuffer = NewFloatArray(CorrelationChannels*CorrelationChannels);

	while (!feof(stdin)){
		char	Buffer[512];

		printf("Enter location in the Correlogram domain: ");
		fflush(stdout);
		i = (int)gets(Buffer);
		if (!i)
			continue;

		i = sscanf(Buffer,"%d %d", &x, &y);

		if (i<2 || x < 0 || y < 0){
			printf("i is %d\n",i);
			continue;
		}

#include	"ivdep.h"
		for (i=0;i<CorrelationChannels*CorrelationChannels;i++)
			ShammaData[i] = 0.0;

		printf("At pixel %d,%d in the Correlogram Domain:\n", x, y);
		i = Transform(x,y);
		printf("\tBest pixel in Shamma domain is %d, %d.\n",
			i%CorrelationChannels,i/CorrelationChannels);
		printf("\tBest frequency in Shamma domain is %g.\n",
			BestFreqArray[i]);
		printf("\tBest sample delay in Shamma domain is %g.\n",
			DeltaDelayArray[i]);
	}
	free(OutputBuffer);
#include	"ivdep.h"
	for (i=0;i<CorrelationChannels*CorrelationChannels;i++)
		ShammaData[i] = 0.0;
	printf("Finished testing Shamma Transform.\n");
}

#ifdef	CRAY

ColorShammaTransform(){
	float	Freq, Delay;
	register int	i;
	float	*OutputBuffer;

	OutputBuffer = NewFloatArray(CorrelationChannels*CorrelationChannels);

	while (!feof(stdin)){
		char	Buffer[512];
		int	FreqIndex, DelayIndex, j;

		printf("Enter freq and delay (in ms): ");
		fflush(stdout);
		i = (int)gets(Buffer);
		if (!i)
			continue;

		i = sscanf(Buffer,"%g %g", &Freq, &Delay);

		if (i<2 || Freq < 0 || Delay < 0){
			printf("i is %d\n",i);
			continue;
		}

#include	"ivdep.h"
		for (i=0;i<CorrelationChannels*CorrelationChannels;i++)
			ShammaData[i] = 0.0;

		FreqIndex = ChannelIndex(Freq);
		DelayIndex = Delay/1000*sample_rate;
		printf("FreqIndex is %d, DelayIndex is %d.\n",
			FreqIndex, DelayIndex);
		for (i=FreqIndex;i>=0;i--){
			j = TransformArray[i*CorrelationChannels+DelayIndex];
			ShammaData[j] = 1.;
		}
		for (i=0;i<CorrelationChannels;i++)
			OutputDataArray(i,i) = .5;
/*		ResampleCorrelogram(ShammaData,OutputBuffer,TransformArray,
			CorrelationChannels*CorrelationChannels);	*/
		UpdateDisplay(ShammaData,CorrelationChannels,
			CorrelationChannels,0.0,1.0);
	}
	free(OutputBuffer);
#include	"ivdep.h"
	for (i=0;i<CorrelationChannels*CorrelationChannels;i++)
		ShammaData[i] = 0.0;
	printf("Finished testing Shamma Transform.\n");
}

PokeAtCorrelogram(OutputDataArray,Max)
float	*OutputDataArray, Max;
{
	int MarkedPixelX = 22, MarkedPixelY = 22;

	MarkedPixelX++; MarkedPixelY++;		/* Fortran Offset */
	MRKPXL(&MarkedPixelX, &MarkedPixelY);
	UpdateDisplay(OutputDataArray,CorrelationChannels,
		CorrelationChannels,0.0,Max/8);
	MarkedPixelX--; MarkedPixelY--;		/* Fortran Offset */

	clearerr(stdin);
	while (!feof(stdin)){
		char	Buffer[512];
		int	i;

		printf("Enter x and y location: ");
		fflush(stdout);
		i = (int)gets(Buffer);
		if (!i)
			continue;

		if (Buffer[0] == 'q'){
			break;
		} else if (Buffer[0] == 'h'){
			MarkedPixelX--;
			if (MarkedPixelX <0)
				MarkedPixelX = 0;
		} else if (Buffer[0] == 'l'){
			MarkedPixelX++;
			if (MarkedPixelX >= CorrelationChannels)
				MarkedPixelX = CorrelationChannels-1;
		} else if (Buffer[0] == 'k'){	/* Picture is upside down. */
			MarkedPixelY--;
			if (MarkedPixelY < 0)
				MarkedPixelY = 0;
		} else if (Buffer[0] == 'j'){
			MarkedPixelY++;
			if (MarkedPixelY >= CorrelationChannels)
				MarkedPixelY = CorrelationChannels-1;
		} else {
			int	i;

			i = sscanf(Buffer,"%d %d", &MarkedPixelX, 
				&MarkedPixelY);
			if (i<2 || MarkedPixelX < 0 || MarkedPixelY < 0){
				printf("i is %d\n",i);
				continue;
			}
		}

		MarkedPixelX++; MarkedPixelY++;		/* Fortran Offset */
		MRKPXL(&MarkedPixelX, &MarkedPixelY);
		UpdateDisplay(OutputDataArray,CorrelationChannels,
			CorrelationChannels,0.0,Max/8);
		MarkedPixelX--; MarkedPixelY--;		/* Fortran Offset */
		printf("At %d,%d:\n",MarkedPixelX, MarkedPixelY);
		printf("\tBest Frequency is %g.\n", BestFreq(MarkedPixelX,
							     MarkedPixelY));
		printf("\tDelay is %g samples, %gms or %g cycles.\n",
						DeltaDelay(MarkedPixelX,
							     MarkedPixelY),
						1000*DeltaDelay(MarkedPixelX,
						     MarkedPixelY)/sample_rate,
						DeltaDelay(MarkedPixelX,
								MarkedPixelY)/
						     sample_rate*
						     BestFreq(MarkedPixelX,
							      MarkedPixelY));
		printf("\tValue in correlogram is %g.\n",
			OutputDataArray[MarkedPixelY*CorrelationChannels+
					MarkedPixelX]);
	}
	MarkedPixelX = MarkedPixelY = -1;
	MRKPXL(&MarkedPixelX, &MarkedPixelY);
}

#endif	/* CRAY */

#ifndef	CRAY

ISMIN(n,sx,incx)
int	n, incx;
float	*sx;
{
	int	i, mini = 0;
	float	Min = sx[0];

	for (i=incx;i<n;i += incx){
		if (sx[i] < Min){
			Min = sx[i];
			mini = i;
		}
	}
	return (mini+1);			/* Just like Fortran */
}
			
#endif	/* CRAY */
!Funky!Stuff!
echo x - sosdesign.c
cat >sosdesign.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: sosdesign.c,v 1.2 90/12/17 18:05:39 malcolm Exp $
 *
 * $Log:	sosdesign.c,v $
 * Revision 1.2  90/12/17  18:05:39  malcolm
 * Added references to the Patterson correlogram in the test code.
 * 
 * Revision 1.1  90/11/06  20:55:43  malcolm
 * Initial revision
 * 
 */

static char	*RCSid = "$Header: sosdesign.c,v 1.2 90/12/17 18:05:39 malcolm Exp $";

/*
 *	This file designs the second order filters used to model the cochlea.
 *	Compile with -DMAIN to test these functions.
 */

#include	<stdio.h>
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

/*
 *	DesignEarFilters - This routine designs all of the filters needed for
 *	the ear model.  Most of the real work is done in the file eardesign.c.
 *	Mostly this routine is responsible for calling the filter design 
 *	functions and filling in the arrays that the actual ear model code
 *	needs to function.
 *
 *	The first stage is the ear filter bank models the outer and middle 
 *	ears and is a simple high pass filter.  The second stage has a zero
 *	at DC to model the conversion of acoustic pressure into basilar
 *	membrane motion, a zero at the Nyquist rate to compensate for the
 *	narrow spacing of channels and finally the first pair of poles from
 *	the cascade of ear filters.
 */

DesignEarFilters(){
	int	i;
	float	cf, prevcf, StageDcGain;
	struct filter *fp;

	fp = OuterMiddleEarFilter(sample_rate);
	a2[0] = FilterNumeratorCoeff(fp,0);
	a1[0] = FilterNumeratorCoeff(fp,1);
	a0[0] = FilterNumeratorCoeff(fp,2);
	b2[0] = 0.0;
	b1[0] = 0.0;
	EarFilterArray[0] = *fp;

	fp = EarFrontFilter(sample_rate);
	a2[1] = FilterNumeratorCoeff(fp,0);
	a1[1] = FilterNumeratorCoeff(fp,1);
	a0[1] = FilterNumeratorCoeff(fp,2);
	b2[1] = FilterDenominatorCoeff(fp,0);
	b1[1] = FilterDenominatorCoeff(fp,1);
	EarFilterArray[1] = *fp;

	for (i=2;i<MaxN;i++){
		prevcf = EarChannelCF(i-2, sample_rate);
		cf = EarChannelCF(i-1, sample_rate);
		StageDcGain = prevcf / cf;

		if ( CascadePoleQ(cf) < 0.5){
			EarLength = min(i,EarLength);
			a0[i] = a1[i] = a2[i] = 0.0;
			b1[i] = b2[i] = 0.0;
		} else {
			fp = EarStageFilter(cf, sample_rate, StageDcGain);
			a2[i] = FilterNumeratorCoeff(fp,0);
			a1[i] = FilterNumeratorCoeff(fp,1);
			a0[i] = FilterNumeratorCoeff(fp,2);
			b2[i] = FilterDenominatorCoeff(fp,0);
			b1[i] = FilterDenominatorCoeff(fp,1);
			EarFilterArray[i] = *fp;
		}
	}
/*
	EarLength = max(EarLength, EAR_LENGTH);
 */

	if (Debug) {
		FILE *fp;
		fp = fopen("coeffs.list","w");
		if (!fp){
		    fprintf(stderr,
		    "ear: Couldn't open coeffs.list for coefficient list.\n");
		    return;
		}
		for (i=0;i<EarLength;i++){
			fprintf(fp,"((%g %g %g)\n", a2[i], a1[i], a0[i]);
			fprintf(fp," (%g %g %g))\n", b2[i], b1[i], 1.0);
		}
		fclose(fp);
	}
}

/*
 *	MaximumEarCF - What is the maximum frequency for a pole in the
 *	cascade-only ear model.  This is a function of the Nyquist frequency,
 *	the location of the zero in the first full stage and the width of
 *	each channel.
 */
float MaximumEarCF(fs)
float	fs;
{
	float	topf = fs / 2.0;

	return( (topf - (CascadeZeroCF(topf) - topf)) + 
		EarBandwidth(topf) * EarStepFactor);
}

/*
 *	EarChannelCF - Compute the center frequency of each channel of the
 *	ear filter bank.  We use the EarChannel array to cache the results
 *	so that we don't need to recompute them everytime.
 */
#define	MaxChannels	256
static	float	EarChannelCFResults[MaxChannels];

float EarChannelCF(index, fs)
int	index;
float	fs;
{
	if (index >= 0 && index < MaxChannels && 
	    EarChannelCFResults[index] != 0.0)
		return EarChannelCFResults[index];
	if (index == 0)
		return EarChannelCFResults[index] = MaximumEarCF(fs);
	else {
		float	cf, result;
		cf = EarChannelCF(index-1, fs);
		result = cf - EarStepFactor*EarBandwidth(cf);
		if (index >= 0 && index < MaxChannels)
			EarChannelCFResults[index] = result;
		return(result);
	}
}

ChannelIndex(Freq)
float	Freq;
{
	register int	i;

	for (i=0;EarChannelCFResults[i] > 0;i++){
		if (EarChannelCFResults[i] < Freq)
			return i-1;			/* Back up one */
	}

	return i-2;
}


InitParms()
{
	Debug = 0;
	printflag = 1;
	ImpulseInput = 0;
	UseAgc = 1;
	UseCascade = 1;
	UseDifference = 1;
	ComputeFiltered = 0;
	UseUltra = 0;
	CPUs = 4;
	VideoRecord = 0;
	LogDisplay = 0;			/* Stretch Correlation on Log Display */
	ifn = "data.adc";		/* Input File Name */
	ofn = "cochlea.pic";		/* Output File for Cochleagram */
	ffn = NULL;			/* Filtered Output */
	cfn = NULL;			/* Correlogram Directory Name */

	sample_rate = 16000.0;
	MaxSamples = -1;

	AgcStage1Tau = 0.640;
	AgcStage2Tau = 0.16;
	AgcStage3Tau = 0.04;
	AgcStage4Tau = 0.01;
	AgcStage1Target = 0.0032;
	AgcStage2Target = 0.0016;
	AgcStage3Target = 0.0008;
	AgcStage4Target = 0.0004;
	DecimationFactor = 20;
	CorrelationStep = 128;
	CorrelationLags = 256;
	TauFactor = 3.0;
	Normalization = .75;
	UltraHeadroom = 1.0;
	SharpResponse = 1;
	TransformCorrelogram = 1;

	EarBreakFreq = 1000.0;
	EarQ = 8.0;
	EarStepFactor = .25;
	EarSharpness = 5.0;
	EarZeroOffset = 1.5;
	EarPreemphCorner = 300.0;
	InputGain = 0.10;
}

CheckParms()
{
}

#ifdef	MAIN

main(argc, argv)
int	argc;
char	**argv;
{
	int	index;
	float	sampling_rate;
	float	cf;
	double	atof();

	InitParms();

	if (argc < 3){
		printf("syntax: %s index sampling_rate\n",
			argv[0]);
		exit(1);
	}
	index = atoi(argv[1]);
	sampling_rate = atof(argv[2]);

	EarQ = 4;
	EarStepFactor=.25;

	CheckParms();

	cf = EarChannelCF(index, sampling_rate);
	printf("The center frequency of the %d'th filter (%g sampling rate)",
		index, sampling_rate);
	printf(" is %g.\n", cf);
	printf("\tEarBandwidth is %g.\n", EarBandwidth(cf));
	printf("\tCascadeZeroCF is %g.\n", CascadeZeroCF(cf));
	printf("\tCascadeZeroQ is %g.\n", CascadeZeroQ(cf));
	printf("\tCascadePoleCF is %g.\n", CascadePoleCF(cf));
	printf("\tCascadePoleQ is %g.\n", CascadePoleQ(cf));

	printf("EpsilonFromTauFS(5.0/cf,%g) is %g.\n",sampling_rate,
		EpsilonFromTauFS(5.0/cf, sampling_rate));

	printf("FirstOrderFromTau(5.0/cf,%g) are ", sampling_rate);
	PrintPolynomial(FirstOrderFromTau(5.0/cf, sampling_rate));
	printf("\n");

	printf("FirstOrderFromCorner(.25*cf,%g) are ", sampling_rate);
	PrintPolynomial(FirstOrderFromCorner(.25*cf, sampling_rate));
	printf("\n");

	printf("SecondOrderFromCenterQ(.25*cf,2,%g) are ", sampling_rate);
	PrintPolynomial(SecondOrderFromCenterQ(.25*cf, 2.0, sampling_rate));
	printf("\n");

	printf("OuterMiddleEarFilter(%g) is: \n",sampling_rate);
	PrintFilter(OuterMiddleEarFilter(sampling_rate));

	printf("EarFrontFilter(%g) is: \n", sampling_rate);
	PrintFilter(EarFrontFilter(sampling_rate));

	printf("EarStageFilter(%g,%g,1.032525595) is: \n", cf, sampling_rate);
	PrintFilter(EarStageFilter(cf, sampling_rate, 1.032525595));
	printf("\tGroup delay of this filter at CF is %g.\n",
		FilterGroupDelay(EarStageFilter(cf,sampling_rate,1.032525595),
				 cf, sampling_rate));
	DesignEarFilters();
	printf("There are %d stages.\n", EarLength);
}

double LickEarCorrelation(){}			/* Just to make loader happy */
LickInitCorrelation(){}
LickSendInputToCorrelation(){}
double ShammaEarCorrelation(){}
ShammaInitCorrelation(){}
ShammaSendInputToCorrelation(){}
double PattersonEarCorrelation(){}
PattersonInitCorrelation(){}
PattersonSendInputToCorrelation(){}
#endif	/* MAIN */
		
!Funky!Stuff!
echo x - sosfilters.c
cat >sosfilters.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: sosfilters.c,v 1.2 90/12/17 18:05:55 malcolm Exp $
 *
 * $Log:	sosfilters.c,v $
 * Revision 1.2  90/12/17  18:05:55  malcolm
 * Clean up for MacEar release 2.1
 * 
 * Revision 1.1  90/11/06  20:56:04  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: sosfilters.c,v 1.2 90/12/17 18:05:55 malcolm Exp $";

/*
 *	The routines in this file implement the ear model.  A single input
 *	sample is passed to EARSTEP and the processing for all channels of the
 *	the cochlea model are performed.  EARSTEP is written in both C and
 *	Fortran; this explains the un-C-like calling sequence.
 */

#include	<stdio.h>
#include	<math.h>
#include	"ear.h"

float Sos1State[MaxN], Sos2State[MaxN];
float Agc1State[MaxN+2], Agc2State[MaxN+2], Agc3State[MaxN+2],
	Agc4State[MaxN+2];
float InputState[MaxN], DecimateState1[MaxN], DecimateState2[MaxN];


EARSTEP(input, output)
float	*input;
float	output[];

{
	register int i;
	extern	FILE	*ffp;
	extern int	EarLength;
	extern float	AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4;
	extern float	AgcStage1Target, AgcStage2Target;
	extern float	AgcStage3Target, AgcStage4Target;
	extern float	DecimationEpsilon;
	extern float	a0[], a1[], a2[], b1[], b2[];
	extern int	UseAgc, UseDifference, UseCascade, ComputeFiltered;
	extern int	DecimationFactor;

#ifdef	TEST
	if (SampleNumber < 1){
		printf("a0[0]=%g, a1[0]=%g, a2[0]=%g, b1[0]=%g, b2[0]=%g.\n",
			a0[0], a1[0], a2[0], b1[0], b2[0]);
		printf("a0[1]=%g, a1[1]=%g, a2[1]=%g, b1[1]=%g, b2[1]=%g.\n",
			a0[1], a1[1], a2[1], b1[1], b2[1]);
		printf("a0[2]=%g, a1[2]=%g, a2[2]=%g, b1[2]=%g, b2[2]=%g.\n",
			a0[2], a1[2], a2[2], b1[2], b2[2]);
	}
#endif	/* TEST */

	if (UseCascade){
		for (i= EarLength-1; i>0 ; i--)		/* Don't do preemph 
							 * channel
							 */
			InputState[i] = InputState[i-1];
		InputState[0] = *input;			/* Now fill in the 
							 * preemph
							 */
	} else {
		for (i=0;i<EarLength;i++){		/* Copy input to all 
							 * channels
							 */
			InputState[i] = *input;
		}
	}

	sos(InputState, Sos1State, Sos2State, a0, a1, a2, b1, b2, 
		InputState, EarLength);

	if (UseAgc){
		hwr(InputState, output, EarLength);
		agc(output, Agc1State, output, AgcEpsilon1, 
				AgcStage1Target, EarLength);
		agc(output, Agc2State, output, AgcEpsilon2, 
				AgcStage2Target, EarLength);
		agc(output, Agc3State, output, AgcEpsilon3, 
				AgcStage3Target, EarLength);
		agc(output, Agc4State, output, AgcEpsilon4, 
				AgcStage4Target, EarLength);
	} else {
		for (i=0;i<EarLength;i++)
			output[i] = InputState[i];
	}
	if (ComputeFiltered){
		float	Output[MaxN+1];
		if (UseAgc){
			for (i=0;i< EarLength;i++){
				Output[i] = InputState[i] * 
						fabs(1.0 - Agc1State[i+1]) *
						fabs(1.0 - Agc2State[i+1]) *
						fabs(1.0 - Agc3State[i+1]) *
						fabs(1.0 - Agc4State[i+1]);
			}
			fwrite(Output, EarLength, sizeof(Output[0]), ffp);
		} else {
			fwrite(InputState, EarLength, sizeof(InputState[0]), 
				ffp);
		}
	}
	if (UseDifference){
		difference(output, output, EarLength);
		hwr(output, output, EarLength);
	}
	
	if (DecimationFactor > 0) {
		fos(output, DecimateState1, output, DecimationEpsilon, 
			EarLength);
		fos(output, DecimateState2, output, DecimationEpsilon, 
			EarLength);
	}
}

agc(input, state, output, epsilon, target, n)
float	input[], state[], output[];
float	epsilon, target;
int	n;
{
	register int i;
	float	temp[MaxN+2];
#ifdef	NOCROSSTALK
	float	OneMinusEpsOverThree = (1.0 - epsilon);
#else	/* CROSSTALK */
	float	OneMinusEpsOverThree = (1.0 - epsilon)/3.0;
#endif	/* NOCROSSTALK */
	float	EpsOverTarget = epsilon/target;

	state[0] = state[1];			/* Take care of end effects */  
	state[n+1] = state[n];			/* Take care of end effects */  

#include	"ivdep.h"
	for (i=0;i<n;i++){
		output[i] = fabs((1.0 - state[i+1]) * input[i]);
#ifdef	NOCROSSTALK
		temp[i+1] = output[i] * EpsOverTarget + 
			      OneMinusEpsOverThree * state[i+1];
#else	/* CROSSTALK */
		temp[i+1] = output[i] * EpsOverTarget + 
			      OneMinusEpsOverThree * 
			      (state[i]+state[i+1]+state[i+2]);
#endif	/* NOCROSSTALK */
	}

#include	"ivdep.h"
	for (i=1;i<n+1;i++){
		register float f;
		
		f = temp[i];
		if (f > 1.0)
			f = 1.0;
		state[i] = f;
	}
}

#ifdef	MAIN

float AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4;
float AgcStage1Target, AgcStage2Target, AgcStage3Target, AgcStage4Target;
float DecimationEpsilon;

float	a0[MaxN], a1[MaxN], a2[MaxN], b1[MaxN], b2[MaxN];
float	input[MaxN], state1[MaxN], state2[MaxN];

#define	LENGTH		500
#define	CHANNELS	100

float	Output[CHANNELS];
int	UseAgc = 0;
int	ComputeFiltered = 0;
int	DecimationFactor = 20;
int	EarLength;
int	UseCascade = 1;
int	UseDifference = 1;
FILE	*ffp = NULL;

main(){
	register int i, j;
	float	period;
	
	for (period = 10.0, i=0; i < CHANNELS; i++, period++){
		a0[i] = 1.0;
		a1[i] = 0.0;
		a2[i] = 0.0;
		b1[i] = -2.0 * cos(2.0*PI/period);
		b2[i] = 1.0;
		state1[i] = state2[i] = 0.0;
	}

	fprintf(stderr, "Impulse respose (%d x %d)\n", CHANNELS, LENGTH);
	for (i=0;i<LENGTH;i++){
		if (i == 0)
			for (j=0; j<CHANNELS; j++)
				input[j] = 1.0;
		else
			for (j=0; j<CHANNELS; j++)
				input[j] = 0.0;
		sos(input, state1, state2, a0, a1, a2, b1, b2, 
			Output, CHANNELS);
		for (j=0;j<CHANNELS;j++)
			printf("%g\n", Output[j]);
		printf("\n");
	}
}

#endif	/* MAIN */
!Funky!Stuff!
echo x - syncstruct.h
cat >syncstruct.h <<'!Funky!Stuff!'
typedef struct
{
    int         ref;            /* reference adc pitch point */
    short       size;           /* number of adc points in this point */
    short       dist;           /* distance to last frame in adc points */
    short       syncflag;       /* flag saying if frame is pitch sync */
    short       framesize;      /* spectral size of frame */
    short       *frame;         /* usual frame info entire spectrum */
    short       enersize;       /* number of energy points */
    short	padding;	/* Padding to make things work on Sun-4 */
    short       *ener;          /* usual energy info and extra space */
} SYNC;
!Funky!Stuff!
echo x - timer.c
cat >timer.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: timer.c,v 2.3 91/02/27 14:26:14 malcolm Exp $
 *
 * $Log:	timer.c,v $
 * Revision 2.3  91/02/27  14:26:14  malcolm
 * Added optional timer.names file instead of .timers since some Mac
 * programs don't like leading periods.
 * 
 * Revision 2.2  90/12/17  18:06:08  malcolm
 * Added support for A/UX.
 * 
 * Revision 2.1  90/11/06  20:56:24  malcolm
 * Changed copyright and also added support for NeXT.
 * 
 * Revision 2.0.1.1  89/08/10  22:19:46  malcolm
 * David Mellinger (at CCRMA@Stanford) added NeXT support.
 * 
 * Revision 2.0  89/07/25  18:59:44  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.7  89/07/25  18:52:17  malcolm
 * Added support for the SGI machine.
 * 
 * Revision 1.6  89/07/19  12:50:31  malcolm
 * Changed printfs to use fixed width fields so that maybe output will line
 * up on all machines.
 * 
 * Revision 1.5  89/04/09  17:05:54  malcolm
 * Changed name of rt subroutine to realtime.
 * 
 * Revision 1.4  89/02/27  10:46:12  malcolm
 * Added support for Stellar and Sequent
 * 
 * Revision 1.3  89/02/24  22:52:45  malcolm
 * Added support for Lightspeeds Think C Compiler
 * 
 * Revision 1.2  88/11/04  16:58:28  malcolm
 * Added Macintosh and standard Unix versions of rt.
 * 
 * Revision 1.1  88/10/23  22:43:54  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: timer.c,v 2.3 91/02/27 14:26:14 malcolm Exp $";

/*
 *	The following implement an elementary performance analysis tool.  This
 *	was necessary because the tools on the Cray were not able to handle
 *	a program that combined C and Fortran.
 */

#include	<stdio.h>
#include	<ctype.h>
#include	"ear.h"

#if	MPW || THINK_C
#define	HZ 1

unsigned long realtime(){
	unsigned long	time;
	GetDateTime(&time);
	return (time);
}
#endif	/* Macintosh OS */

#if	sun || vax || stellar || sequent || sgi || NeXT || _AUX_SOURCE
#include	<sys/types.h>
#include	<sys/times.h>
#include	<sys/param.h>

unsigned long realtime(){
	struct tms buffer;

	times(&buffer);
	return(buffer.tms_utime + buffer.tms_stime);
}
#endif

#if	sequent || NeXT
#define	HZ	60
#endif

#ifdef	cray
#include	<sys/types.h>
#endif

#ifndef	HZ
#define	HZ	1
#endif


static int	starttime;

long	timertime[NTIMERS];
long	timercount[NTIMERS];

inittimers(){
	int	i;

	for (i=0;i<NTIMERS;i++){
		timertime[i] = 0;
		timercount[i] = 0;
	}

	starttime = realtime();
}

printtimers(){
	int	runtime, i;
	FILE	*fp;
	char	Buffer[BUFSIZ], *p;

	fp = fopen(".timers","r");
	if (!fp)
		fp = fopen("timer.names","r");

	runtime = realtime()-starttime;
	if (fp){
		printf("Total Time      Calls   ms/Call       Percentage   Where\n");
		while (!feof(fp)){
			if (fgets(Buffer, BUFSIZ, fp) == 0)
				continue;
			if (Buffer[0] == '#')
				continue;
			i = atoi(Buffer);
			if (i < 0 || i >= NTIMERS)
				continue;
			if (!timercount[i])
				continue;
			for (p=Buffer;*p;p++)
				if (!isspace(*p))
					break;
			for (;*p;p++)
				if (!isdigit(*p))
					break;
			for (;*p;p++)
				if (!isspace(*p))
					break;
			printf("%7.3gs     %8ld   %7.3g      %7.3g",
				timertime[i]/(float)HZ, timercount[i],
				timertime[i]/(float)HZ/timercount[i]*1000,
				100.0*timertime[i]/(float)runtime);
			printf("     %s", p);		/* To fix LSC bug */
		}
		printf("%7gs\n", runtime/(float)HZ);
		fclose(fp);
	} else {
		printf("Total Time      Calls   ms/Call       Percentage   Where\n");
		for (i=0;i<NTIMERS;i++){
			if (timercount[i] == 0)
				continue;
			printf("%d:	%gs  	%ld	%g  	%g\n",
				i, timertime[i]/(float)HZ, timercount[i],
				timertime[i]/(float)HZ/timercount[i]*1000,
				100.0*timertime[i]/(float)runtime);
		}
		printf("Total	%gs\n", runtime/(float)HZ);
	}
}
!Funky!Stuff!
echo x - timer.h
cat >timer.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *
 * $Header: timer.h,v 2.1 90/12/17 18:06:20 malcolm Exp $
 *
 * $Log:	timer.h,v $
 * Revision 2.1  90/12/17  18:06:20  malcolm
 * Added support for A/UX.
 * 
 * Revision 2.0  89/07/25  18:59:47  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.2  89/04/09  17:04:40  malcolm
 * Changed name of rt subroutine on the Cray to fit new name.
 * 
 * Revision 1.1  88/10/23  22:44:09  malcolm
 * Initial revision
 * 
 *
 */

#define	NTIMERS	20

extern long	timertime[NTIMERS];
extern long	timercount[NTIMERS];
extern unsigned long realtime();

#define starttimer(i)	(timercount[i]++, timertime[i] -= realtime())
#define endtimer(i)	(timertime[i] += realtime())

#ifdef	CRAY
#define	realtime	rtclock
#endif	
!Funky!Stuff!
echo x - ub.h
cat >ub.h <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1989 by Apple Computer, Inc
 *
 * $Header: ub.h,v 2.1 90/12/17 18:06:43 malcolm Exp $
 *
 * $Log:	ub.h,v $
 * Revision 2.1  90/12/17  18:06:43  malcolm
 * Cleanup for MacEar release 2.1
 * 
 * Revision 2.0  89/07/25  18:59:49  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.1  88/10/23  22:44:17  malcolm
 * Initial revision
 * 
 *
 */

/*	#define	NTSC	0 */

#ifdef	NTSC
#define UB_WIDTH 	752
#define UB_HEIGHT 	484
#else	/* !NTSC */
#define UB_WIDTH 	1280
#define UB_HEIGHT 	1024
#endif	/* NTSC */

#define UB_HWIDTH 	(UB_WIDTH/2)
#define SIGDISPLAY	56
#define SIGRECORD	57

int	*UBAllocate();
int	*CurrentUltraBuffer();
!Funky!Stuff!
echo x - utilities.c
cat >utilities.c <<'!Funky!Stuff!'
/*
 *			Lyon's Cochlear Model, The Program
 *	   			   Malcolm Slaney
 *			     Advanced Technology Group
 *				Apple Computer, Inc.
 *				 malcolm@apple.com
 *				   November 1988
 *
 *	This program implements a model of acoustic propagation and detection
 *	in the human cochlea.  This model was first described by Richard F.
 *	Lyon.  Please see 
 *		Malcolm Slaney, "Lyon's Cochlear Model, the Mathematica 
 *		Notebook," Apple Technical Report #13, 1988
 *	for more information.  This report is available from the Apple 
 *	Corporate Library.
 *
 *	Warranty Information
 *	Even though Apple has reviewed this software, Apple makes no warranty
 *	or representation, either express or implied, with respect to this
 *	software, its quality, accuracy, merchantability, or fitness for a 
 *	particular purpose.  As a result, this software is provided "as is,"
 *	and you, its user, are assuming the entire risk as to its quality
 *	and accuracy.
 *
 *	Copyright (c) 1988-1990 by Apple Computer, Inc
 *		All Rights Reserved.
 *
 * $Header: utilities.c,v 2.4 90/12/17 18:06:54 malcolm Exp $
 *
 * $Log:	utilities.c,v $
 * Revision 2.4  90/12/17  18:06:54  malcolm
 * Cleaned up correlogram code and removed the NewFloatArray and
 * NewIntArray routines to the file alloc.c
 * 
 * Revision 2.3  90/11/06  20:56:44  malcolm
 * Added gain input variable.  (Sets the gain of the file reading routines.)
 * 
 * Revision 2.2  90/01/28  15:35:05  malcolm
 * Added NewFloatArray and NewIntArray routines.  Also added definitions
 * for function pointers so that either the Licklider or the Shamma
 * style of correlograms can be computed.  Finally added the 's' and 't'
 * and the 'cor=' parameter to support the Shamma style of correlogram.
 * 
 * Revision 2.1  89/11/09  23:14:18  malcolm
 * Removed CalculateResponse option.  Added options for stretching (log) the
 * display and correlograms synced to the video rate.
 * 
 * Revision 2.0.1.2  89/08/10  22:24:45  malcolm
 * Dave Mellinger (at Stanford CCRMA) added support for MaxSamples.  Also 
 * ifndef'ed the declaration of atof.  Finally fixed correlogram spelling.
 * 
 * Revision 2.0.1.1  89/07/28  21:32:05  malcolm
 * Fixed a missing definition for atof in the Macintosh environments.
 * 
 * Revision 2.0  89/07/25  18:59:51  malcolm
 * Completely debugged and tested version on the following machines (roughly
 * in order of performance):
 * Cray, Stellar, SGI, Sun-4, Sequent Balance, Sun-3, VAX, Macintosh under
 * both MPW and LightSpeed C.
 * 
 * Revision 1.3  89/06/20  22:45:58  malcolm
 * Added support (int32 type) for LightSpeed C.
 * 
 * Revision 1.2  89/04/09  16:58:01  malcolm
 * Added support for Ultra frame buffer video taping.  Also added support
 * for a decimation factor of zero indicating no decimation and no filtering.
 * 
 * Revision 1.1  89/02/25  12:13:21  malcolm
 * Initial revision
 * 
 *
 */

static char	*RCSid = "$Header: utilities.c,v 2.4 90/12/17 18:06:54 malcolm Exp $";

#include	<stdio.h>
#ifdef	__STDC__
#include	<stdlib.h>
#endif	/* STDC */
#include	"complex.h"
#include	"filter.h"
#include	"ear.h"

int	Debug = 0;
int	printflag = 1;
int	ImpulseInput = 0;
int	UseAgc = 1;
int	UseCascade = 1;
int	UseDifference = 1;
int	ComputeFiltered = 0;
int	UseUltra = 0;
int	CPUs = 4;
int	VideoRecord = 0;
int	LogDisplay = 0;			/* Stretch Correlation on Log Display */
char	*progname;
char	*ifn = "data.adc";		/* Input File Name */
char	*ofn = "cochlea.pic";		/* Output File for Cochleagram */
char	*ffn = NULL;			/* Filtered Output */
char	*cfn = NULL;			/* Correlogram Directory Name */

float	sample_rate = 16000.0;
int32	DataLength;
int32	MaxSamples = -1;

float	AgcStage1Tau = 0.640;
float	AgcStage2Tau = 0.16;
float	AgcStage3Tau = 0.04;
float	AgcStage4Tau = 0.01;
float	AgcStage1Target = 0.0032;
float	AgcStage2Target = 0.0016;
float	AgcStage3Target = 0.0008;
float	AgcStage4Target = 0.0004;
float	InputGain = 0.10;
int	DecimationFactor = 20;
int	CorrelationStep = 128;
int	CorrelationLags = 256;
float	TauFactor = 3.0;
float	Normalization = .75;
float	UltraHeadroom = 1.0;
int	SharpResponse = 1;
int	TransformCorrelogram = 1;

float	EarBreakFreq = 1000.0;
float	EarQ = 8.0;
float	EarStepFactor = .25;
float	EarSharpness = 5.0;
float	EarZeroOffset = 1.5;
float	EarPreemphCorner = 300.0;

float	AgcEpsilon1, AgcEpsilon2, AgcEpsilon3, AgcEpsilon4;
float	a0[MaxN], a1[MaxN], a2[MaxN], b1[MaxN], b2[MaxN];
float	DecimationEpsilon;
struct filter	EarFilterArray[MaxN];

float	Output[MaxN];
int	EarLength = MaxN;
int	SampleNumber = 0;

int	(*SendInputToCorrelation)() = LickSendInputToCorrelation;
int	(*InitCorrelation)() = LickInitCorrelation;
double	(*EarCorrelation)() = LickEarCorrelation;
char	*CorrelogramType = "Licklider's Model";

FILE	*ffp;

char	*ArgumentTable[] = {
		"if",
		"of",
		"tau1",
		"tau2",
		"tau3",
		"tau4",
		"target1",
		"target2",
		"target3",
		"target4",
		"taufactor",
		"df",
		"breakf",
		"earq",
		"stepfactor",
		"sharpness",
		"offset",
		"preemph",
		"ff",
		"cf",
		"cstep",
		"clag",
		"cpus",
		"normalize",
		"umax",
		"maxsamples",
		"cor",
		"gain",
		0
	};

ProcessOption(p)
char	*p;
{
	int	Flag, cc;

	if (*p == '+')
		Flag = 1;
	else
		Flag = 0;

	while(cc= *++p)switch(cc){
	case 'D':
	case 'd':
		if (Flag)
			Debug ++;
		else
			Debug = 0;
		break;
	case 'p':
		printflag = Flag;
		break;
	case 'i':
		ImpulseInput = Flag;
		break;
	case 'a':
		UseAgc = Flag;
		break;
	case 'c':
		UseCascade = Flag;
		break;
	case 'm':
		UseDifference = Flag;
		break;
	case 'u':
		UseUltra = Flag;
		if (Flag)
			DecimationFactor = 1;
		break;
	case 'v':
		VideoRecord = Flag;
		break;
	case 'l':
		LogDisplay = Flag;
		break;
	case 's':
		SharpResponse = Flag;
		break;
	case 't':
		TransformCorrelogram = Flag;
		break;
	default:
		fprintf(stderr,"bad flag: %c\n",cc);
		exit(1);
	}
}

ProcessArgument(p)
char	*p;
{
#ifndef	unix
	float	atof();
#endif	/* unix */
	
	switch(comm(p,ArgumentTable)){
	case 1:			/* if - input file for speech */
		ifn = p+3;
		break;
	case 2:			/* of - output file for cochlea data */
		ofn = p+3;
		if (!*ofn)
			ofn = 0;
		break;
	case 3:			/* tau1 - first agc time constant */
		AgcStage1Tau = atof(p+5);
		break;
	case 4:			/* tau2 - second agc time constant */
		AgcStage2Tau = atof(p+5);
		break;
	case 5:			/* tau3 - third agc time constant */
		AgcStage3Tau = atof(p+5);
		break;
	case 6:			/* tau4 - fourth agc time constant */
		AgcStage4Tau = atof(p+5);
		break;
	case 7: 		/* target1 - first Agc Target */
		AgcStage1Target = atof(p+8);
		break;
	case 8: 		/* target2 - second Agc Target */
		AgcStage2Target = atof(p+8);
		break;
	case 9: 		/* target3 - third Agc Target */
		AgcStage3Target = atof(p+8);
		break;
	case 10: 		/* target4 - fourth Agc Target */
		AgcStage4Target = atof(p+8);
		break;
	case 11:		/* taufactor */
		TauFactor = atof(p+10);
		break;
	case 12:		/* df - Decimation Factor 1 */
		DecimationFactor = atoi(p+3);
		if (DecimationFactor < 0)
			DecimationFactor = 1;
		break;
	case 13:		/* breakf - Ear Break Frequency */
		EarBreakFreq = atof(p+7);
		break;
	case 14:		/* earq */
		EarQ = atof(p+5);
		break;
	case 15:		/* stepfactor */
		EarStepFactor = atof(p+11);
		break;
	case 16:		/* sharpness */
		EarSharpness = atof(p+10);
		break;
	case 17:		/* offset */
		EarZeroOffset = atof(p+7);
		break;
	case 18:		/* preemph */
		EarPreemphCorner = atof(p+8);
		break;
	case 19:		/* fn - Filtered File Name */
		ffn = p+3;
		if (*ffn){
			ComputeFiltered = 1;
		} else {
			ffn = 0;
		}
		break;
	case 20:		/* cf - Correlation File Name */
		cfn = p+3;
		if (!*cfn)
			cfn = 0;
		break;
	case 21:		/* cstep - Steps between correlations */
		CorrelationStep = atoi(p+6);
		break;
	case 22:		/* clag - Total lags in correlations */
		CorrelationLags = atoi(p+5);
		break;
	case 23:		/* cpus - Number of CPUs to use */
		CPUs = atoi(p+5);
		break;
	case 24:		/* Normalize - For Correlation */
		Normalization = atof(p+10);
		break;
	case 25:		/* umax - Ultra Headroom factor */
		UltraHeadroom = atof(p+5);
		break;
	case 26:		/* maxsamples - limit the number of samples */
		MaxSamples = atoi(p+11);
		break;
	case 27:		/* cor - Type of Correlogram to compute */
		if (p[4] == 'l'){
			SendInputToCorrelation = LickSendInputToCorrelation;
			InitCorrelation = LickInitCorrelation;
			EarCorrelation = LickEarCorrelation;
			CorrelogramType = "Licklider's Model";
		} else if (p[4] == 's'){
			SendInputToCorrelation = ShammaSendInputToCorrelation;
			InitCorrelation = ShammaInitCorrelation;
			EarCorrelation = ShammaEarCorrelation;
			CorrelogramType = "Shamma's Model";
			CPUs = 1;
		} else if (p[4] == 'p'){
			SendInputToCorrelation = 
					PattersonSendInputToCorrelation;
			InitCorrelation = PattersonInitCorrelation;
			EarCorrelation = PattersonEarCorrelation;
			CorrelogramType = "Patterson's Model";
			CPUs = 1;
		} else {
			fprintf(stderr,"%s: Unknown correlogram model (%s).\n",
				progname, p+4);
			fprintf(stderr,
			  "\tPlease use either cor=licklider, cor=shamma or cor=patterson.\n");
			exit(1);
		}
		break;
	case 28:		/* gain - Input Gain to System */
		InputGain = atof(p+5);
		break;
	}
}

PrintStats(){
	printf("Lyon Ear Model\n");
	printf("\tInput File (if).....................%s\n", 
		ImpulseInput? "An Impulse" : ifn);
	printf("\tOutput File (of)....................%s\n", ofn?ofn:"None");
	printf("\tFiltered Sound File (ff)............%s\n", ffn?ffn:"None");
	printf("\tCorrelation Output File (cf)........%s\n", cfn?cfn:"None");
	printf("\tInput Gain (gain)...................%g\n", InputGain);
	if (UseAgc){
	 printf("\tAgc Stage 1 Tau (tau1)..............%gs\n", AgcStage1Tau);
	 printf("\tAgc Stage 2 Tau (tau2)..............%gs\n", AgcStage2Tau);
	 printf("\tAgc Stage 3 Tau (tau3)..............%gs\n", AgcStage3Tau);
	 printf("\tAgc Stage 4 Tau (tau4)..............%gs\n", AgcStage4Tau);
	 printf("\tAgc State 1 Target (target1)........%g\n", AgcStage1Target);
	 printf("\tAgc State 2 Target (target2)........%g\n", AgcStage2Target);
	 printf("\tAgc State 3 Target (target3)........%g\n", AgcStage3Target);
	 printf("\tAgc State 4 Target (target4)........%g\n", AgcStage4Target);
	}
	printf("\tDecimation Tau Factor (taufactor)...%g\n", TauFactor);
	printf("\tDecimation Factor (df)..............%d\n", DecimationFactor);
	printf("\tEar Break Frequency (breakf)........%g\n", EarBreakFreq);
	printf("\tEar Q Factor (earq).................%g\n", EarQ);
	printf("\tEar Step Factor (stepfactor)........%g\n", EarStepFactor);
	printf("\tEar Zero Sharpness (sharpness)......%g\n", EarSharpness);
	printf("\tEar Zero Offset (offset)............%g\n", EarZeroOffset);
	printf("\tEar Preemphasis Corner (preemph)....%g\n", EarPreemphCorner);
	if (UseUltra || cfn){
		printf("\tCorrelogram Type....................%s\n",
			CorrelogramType);
		printf("\tCorrelation Time Step (cstep).......%d samples\n", 
			CorrelationStep);
		printf("\tCorrelation Lags (clag).............%d samples\n", 
			CorrelationLags);
		printf("\tCorrelation Normalize (normalize)...%g\n", 
			Normalization);
		printf("\tUltra Headroom factor (umax)........%g\n", 
			UltraHeadroom);
		if (CorrelogramType[0] == 'S' && SharpResponse)
			printf("\tUse an LIN to sharpen response (+s)\n");

	}
	if (MaxSamples > 0)
		printf("\tNumber of samples (maxsamples)......%ld\n",
			MaxSamples);
	if (!UseAgc)
		printf("\tNo AGC (-a)\n");
	if (!UseCascade)
		printf("\tNo cascade (independent channels) (-c)\n");
	if (!UseDifference)
		printf("\tNo difference of channels (-m)\n");
	if (UseUltra)
		printf("\tAnimate correlogram on Ultra (+u)\n");
	if ((UseUltra || cfn) && LogDisplay)
		printf("\tShow correlogram on log delay scale (+l)\n");
	if (UseUltra && VideoRecord)
		printf("\tRecording video at VTR rates (30 frames/sec )(+v)\n");
	if (Debug)
		printf("\tDebug Mode\n");
#ifndef	THINK_C
	fflush(stdout);
#endif	/* !THINK_C */
}

syntax(){}

ChangeAgcParams()
{
	AgcEpsilon1 = EpsilonFromTauFS(AgcStage1Tau, sample_rate);
	AgcEpsilon2 = EpsilonFromTauFS(AgcStage2Tau, sample_rate);
	AgcEpsilon3 = EpsilonFromTauFS(AgcStage3Tau, sample_rate);
	AgcEpsilon4 = EpsilonFromTauFS(AgcStage4Tau, sample_rate);
}


ChangeDecimationParameters(){
	DecimationEpsilon = EpsilonFromTauFS(
		((DecimationFactor<1) ? 1 : DecimationFactor) * 
			TauFactor / sample_rate,
		sample_rate);
}

/* 
 * This is sort of a sleazy hack.  We want C and Fortran to share a common
 * set of global variables.  There is no way to convince the loader to do
 * it so we fake it.  The structure below corresponds exactly to a common
 * block defined in fear.f.  We have Fortran call the routine INITCOM with
 * the first variable in the common block.  Since Fortran is call by address
 * this gives INITCOM the starting location of the common block.  We just
 * use the CommonStruct to give C an easy hook into the rest of the block.
 * Sleazy, but it works.  And this saves us from passing every single one 
 * of the variables through a function call.
 */
struct CommonStruct {
	int	n;
	int	UseAgc, UseDifference, UseCascade, ComputeFiltered;
	int	DecimationFactor;
	float	DecimationEpsilon;
	float	AgcEpsilon1, AgcEpsilon2;
	float	AgcEpsilon3, AgcEpsilon4;
	float	AgcStage1Target, AgcStage2Target;
	float	AgcStage3Target, AgcStage4Target;
	float	a0[MaxN], a1[MaxN], a2[MaxN], b1[MaxN], b2[MaxN];
	};

#define	InitCommon(x)	CBlock->x = x;

INITCOM(CBlock)
struct CommonStruct *CBlock;
{
	register int i;

	CBlock->n = EarLength;
	InitCommon( UseAgc );
	InitCommon( UseDifference );
	InitCommon( UseCascade );
	InitCommon( ComputeFiltered );
	InitCommon( DecimationFactor );
	InitCommon( DecimationEpsilon );
	InitCommon( AgcEpsilon1 );
	InitCommon( AgcEpsilon2 );
	InitCommon( AgcEpsilon3 );
	InitCommon( AgcEpsilon4 );
	InitCommon( AgcStage1Target );
	InitCommon( AgcStage2Target );
	InitCommon( AgcStage3Target );
	InitCommon( AgcStage4Target );

	for (i=0;i<MaxN;i++){
		InitCommon( a0[i] );
		InitCommon( a1[i] );
		InitCommon( a2[i] );
		InitCommon( b1[i] );
		InitCommon( b2[i] );
	}
}

!Funky!Stuff!
echo x - Makefile
cat >Makefile <<'!Funky!Stuff!'
# This makefile is for the Cray.  See the Makefile.unix file for other
# Unix machines.  Feel free to move Makefile.unix to Makefile if you don't
# have a Cray and are tired of typing make -f Makefile.unix.  Most of
# development is done on the Cray so I keep the names so it is most convenient
# for me.
#
# This makefile can either build the all C version (ear) or the C/Fortran
# version (fear).  The Fortran version has all the main loops coded in Fortran
# so they run as fast as possible.
#

SHELL = /bin/sh

CFILES = correlate.c \
	animate.c comm.c complex.c ear.c eardesign.c \
	earfilters.c fft.c file.c oneframe.c output.c picout.c script.c \
	timer.c utilities.c shamma.c patterson.c alloc.c \
	sosdesign.c sosfilters.c \
	hydesign.c hyfilters.c

FFILES = fcor.f fear.f fmag.f ftopix.f

FortranObjs = ftopix.o fcor.o fmag.o
GenObjs = $(FortranObjs) correlate.o shamma.o patterson.o \
	ear.o eardesign.o comm.o file.o complex.o fft.o \
	timer.o animate.o picout.o utilities.o output.o alloc.o  

FearObjs = $(GenObjs) sosdesign.o fear.o
SosObjs = $(GenObjs) sosdesign.o sosfilters.o earfilters.o
HydroObjs = $(GenObjs) hydesign.o hyfilters.o earfilters.o

CC=	scc
CFT=	cf77

#
#	CFLAGS - Here are some of the interesting options you might want to
#	use.
#		-DULTRA - Compile the ear model to include support for the 
#			Ultra Frame Buffer (at Apple).
#		-DPLOT3D - Compile the ear model to generate 3d plots using 
#			the Purdue Plot3d program.
#	Some machines also need some help with the floating point.  On Suns
#	you probably want to include -ffpa or -fweitek.  On Sequents you'll
#	either want -f1167 or -f387.
CFLAGS = -O -DULTRA $(COMMANDCCFLAGS)

#
#	Fortran Flags 
#	Use the following if you want debugging enabled on the Fortran stuff.
# FFLAGS= -g -a stack -c -m 2 -Zp 
#
FFLAGS= -a stack -c -m 2 -Zp  

LDFLAGS=

ULTRALIBS = ../ub/libub.a -lugraf 
CRAYLIBS = -lf -lsci -lu -lio -lnet 
LIBS=	$(ULTRALIBS) $(CRAYLIBS) -lm

#
#	The following is three different versions of the ear model.  
#	Fear is a C/Fortran implementation of the second order cascade model
#	Ear is a C implementation of the second order cascade model
#	Hear is a C implementation of the hydrodynamics model
#
fear:		$(FearObjs) Makefile 
		$(CC) $(LDFLAGS) $(CFLAGS) $(FearObjs) \
			$(LIBS) -o fear -lc

ear:		$(SosObjs) Makefile 
		$(CC) $(LDFLAGS) $(SosObjs) \
			$(LIBS) -o ear 

hear:		$(HydroObjs) Makefile 
		$(CC) $(LDFLAGS) $(HydroObjs) \
			$(LIBS) -o hear 

#
#	Most of the routines that do real work include stand alone test
#	code that can be used to verify the routines are working.
#	In all cases definining -DMAIN causes this test code to be included.
#
sosdesign:	sosdesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) sosdesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o sosdesign
		rm -f sosdesign.o

sosfilters:	sosfilters.c earfilters.o
		$(CC) $(LDFLAGS) sosfilters.c -DMAIN \
			earfilters.o -lm -o sosfilters
		rm -f sosfilters.o

hydesign:	hydesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) hydesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o hydesign
		rm -f hydesign.o

hyfilters:	hyfilters.c complex.o utilities.o comm.o eardesign.o \
			hydesign.o earfilters.o
		$(CC) hyfilters.c -DMAIN hydesign.o \
			complex.o eardesign.o comm.o utilities.o earfilters.o \
			-lm -o hyfilters
		rm -f hyfilters.o

complex:	complex.c 
		$(CC) $(LDFLAGS) -DMAIN complex.c -o complex
		rm -f complex.o

fft:		fft.c alloc.o timer.o
		$(CC) $(LDFLAGS) -DMAIN fft.c alloc.o timer.o $(LIBS) -o fft
		rm -f fft.o

correlate:	correlate.c fcor.o animate.o fft.o timer.o picout.o animate.o \
			ftopix.o alloc.o fmag.o
		$(CC) correlate.c -DMAIN animate.o fft.o timer.o fcor.o \
			picout.o animate.o ftopix.o alloc.o fmag.o \
			$(LIBS) -lm -o correlate
		rm -f correlate.o

oneframe:	oneframe.c
		$(CC) -DMAIN $(CFLAGS) oneframe.c -o oneframe -DDEBUG

animate:	animate.c ftopix.o timer.o 
		$(CC) -DMAIN $(CFLAGS) animate.c ftopix.o timer.o \
			-o animate -DDEBUG $(LIBS)
		-rm -f animate.o

ivq:		ivq.c file.o alloc.o
		$(CC) ivq.c file.o alloc.o -lm -o ivq

icos:		icos.c file.o alloc.o
		$(CC) icos.c file.o alloc.o -lm -o icos

#
#	Miscellaneous code that does useful work.
#
catsound:	catsound.o file.o
		$(CC) $(LDFLAGS) catsound.o file.o -o catsound $(LIBS)

all:		ear fear hear catsound

test:		sosdesign sosfilters hydesign hyfilters complex correlate \
		animate fft oneframe

clean:
		-rm *.o core ear fear hear sosdesign sosfilters hydesign \
			hyfilters complex correlate animate fft oneframe

SourceFiles = READ* *.[chf] Make* *.man ear.make .timers

shar:
		rm -f ear.shar
		shar ear.shar $(SourceFiles)

distribute:
		rcp $(SourceFiles) ceres:Speech/Ear
		rcp $(SourceFiles) medusa:Speech/Ear
		rcp $(SourceFiles) goofy:Speech/Ear
		rcp $(SourceFiles) jumbo:Speech/Ear
		rcp $(SourceFiles) blorb:Speech/Ear
		rcp $(SourceFiles) nucleus:Speech/Ear
		rcp $(SourceFiles) dataio:Speech/Ear

# depend:
#	Generates list of #include dependencies, also including nested
#	#includes.
#
# The for-loop generates a list of "file.o: header.h" dependencies, using
# cpp to expand nested includes.  The egrep picks out those lines that
# reference an include file.  The sed does: extract only the header-file,
# insert the object file name, changes redundant occurances of
# "../something/.." to ".." and "something/../somethingelse" to
# "somethingelse" up to two times.  This whole mess is sorted (uniq'd),
# and handed to awk to compress them on to 78-char lines.  The uniq is
# needed due to cpp output redundantly listing the same header file.
#
depend:
	echo '# DO NOT DELETE THIS LINE -- make depend uses it' > makedep
	-for file in ${CFILES} ; \
	do \
		obj=`basename $$file .c`.o; \
		${CC} ${COPTS} -E $$file | \
		egrep '^# line[ 	]+[0-9]+[ 	]+".*\.h"' | \
		sed -e 's/^.*"\(.*\)".*$$/\1/' \
		    -e "s/^/$$obj: /" \
		    -e 's;\.\./[^./]*/\.\.;..;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;\.\/\.\.;..;'; \
	done | sort -u | \
	awk ' { if ($$1 != prev) { print rec; rec = $$0; prev = $$1; } \
		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
		       else rec = rec " " $$2 } } \
	      END { print rec } ' >> makedep
	echo '/^# DO NOT DELETE THIS LINE/,$$d' >eddep
	echo '$$r makedep' >>eddep
	echo 'w' >> eddep
	rm -f Makefile.bak
	cp Makefile Makefile.bak
	ed - Makefile < eddep
	rm eddep makedep

# DO NOT DELETE THIS LINE -- make depend uses it

alloc.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
alloc.o: /usr/include/stdc/stdio.h /usr/include/stdc/stdlib.h
animate.o: ./timer.h ./ub.h /usr/include/stdc/math.h /usr/include/stdc/stdio.h
comm.o: /usr/include/stdc/stdio.h
complex.o: ./complex.h /usr/include/stdc/math.h
correlate.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
correlate.o: /usr/include/stdc/stdio.h
ear.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/errno.h
ear.o: /usr/include/stdc/math.h /usr/include/stdc/stdio.h
ear.o: /usr/include/sys/cpu.h
eardesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
eardesign.o: /usr/include/stdc/stdio.h
earfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
earfilters.o: /usr/include/stdc/stdio.h
fft.o: ./timer.h /usr/include/stdc/math.h
file.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
file.o: /usr/include/stdc/stdio.h
hydesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
hydesign.o: /usr/include/stdc/stdio.h
hyfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
hyfilters.o: /usr/include/stdc/stdio.h
oneframe.o: /usr/include/stdc/ctype.h /usr/include/stdc/locstruct.h
oneframe.o: /usr/include/stdc/stdio.h
output.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
output.o: /usr/include/stdc/stdio.h
patterson.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
patterson.o: /usr/include/stdc/stdio.h
picout.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
picout.o: /usr/include/stdc/stdio.h /usr/include/sys/fcntl.h
script.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
script.o: /usr/include/stdc/stdio.h
shamma.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
shamma.o: /usr/include/stdc/stdio.h
sosdesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
sosdesign.o: /usr/include/stdc/stdio.h
sosfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
sosfilters.o: /usr/include/stdc/stdio.h
timer.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/ctype.h
timer.o: /usr/include/stdc/locstruct.h /usr/include/stdc/math.h
timer.o: /usr/include/stdc/stdio.h /usr/include/sys/types.h
utilities.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
utilities.o: /usr/include/stdc/stdio.h /usr/include/stdc/stdlib.h
!Funky!Stuff!
echo x - Makefile.bak
cat >Makefile.bak <<'!Funky!Stuff!'
# This makefile is for the Cray.  See the Makefile.unix file for other
# Unix machines.  Feel free to move Makefile.unix to Makefile if you don't
# have a Cray and are tired of typing make -f Makefile.unix.  Most of
# development is done on the Cray so I keep the names so it is most convenient
# for me.
#
# This makefile can either build the all C version (ear) or the C/Fortran
# version (fear).  The Fortran version has all the main loops coded in Fortran
# so they run as fast as possible.
#

SHELL = /bin/sh

CFILES = correlate.c \
	animate.c comm.c complex.c ear.c eardesign.c \
	earfilters.c fft.c file.c oneframe.c output.c picout.c script.c \
	timer.c utilities.c shamma.c patterson.c alloc.c \
	sosdesign.c sosfilters.c \
	hydesign.c hyfilters.c

FFILES = fcor.f fear.f fmag.f ftopix.f

FortranObjs = ftopix.o fcor.o fmag.o
GenObjs = $(FortranObjs) correlate.o shamma.o patterson.o \
	ear.o eardesign.o comm.o file.o complex.o fft.o \
	timer.o animate.o picout.o utilities.o output.o alloc.o  

FearObjs = $(GenObjs) sosdesign.o fear.o
SosObjs = $(GenObjs) sosdesign.o sosfilters.o earfilters.o
HydroObjs = $(GenObjs) hydesign.o hyfilters.o earfilters.o

CC=	cc
CFT=	cf77

#
#	CFLAGS - Here are some of the interesting options you might want to
#	use.
#		-DULTRA - Compile the ear model to include support for the 
#			Ultra Frame Buffer (at Apple).
#		-DPLOT3D - Compile the ear model to generate 3d plots using 
#			the Purdue Plot3d program.
#	Some machines also need some help with the floating point.  On Suns
#	you probably want to include -ffpa or -fweitek.  On Sequents you'll
#	either want -f1167 or -f387.
CFLAGS = -O -DULTRA $(COMMANDCCFLAGS)

#
#	Fortran Flags 
#	Use the following if you want debugging enabled on the Fortran stuff.
FFLAGS= -g -a stack -c -m 2 -Zp 
#
# FFLAGS= -a stack -c -m 2 -Zp  

LDFLAGS=

ULTRALIBS = ../ub/libub.a -lultra /usr/lib/ugraf.a
CRAYLIBS = -lf -lsci -lu -lio -lnet 
LIBS=	$(ULTRALIBS) $(CRAYLIBS) -lm

#
#	The following is three different versions of the ear model.  
#	Fear is a C/Fortran implementation of the second order cascade model
#	Ear is a C implementation of the second order cascade model
#	Hear is a C implementation of the hydrodynamics model
#
fear:		$(FearObjs) Makefile 
		$(CC) $(LDFLAGS) $(CFLAGS) $(FearObjs) \
			$(LIBS) -o fear -lc

ear:		$(SosObjs) Makefile 
		$(CC) $(LDFLAGS) $(SosObjs) \
			$(LIBS) -o ear 

hear:		$(HydroObjs) Makefile 
		$(CC) $(LDFLAGS) $(HydroObjs) \
			$(LIBS) -o hear 

#
#	Most of the routines that do real work include stand alone test
#	code that can be used to verify the routines are working.
#	In all cases definining -DMAIN causes this test code to be included.
#
sosdesign:	sosdesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) sosdesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o sosdesign
		rm -f sosdesign.o

sosfilters:	sosfilters.c earfilters.o
		$(CC) $(LDFLAGS) sosfilters.c -DMAIN \
			earfilters.o -lm -o sosfilters
		rm -f sosfilters.o

hydesign:	hydesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) hydesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o hydesign
		rm -f hydesign.o

hyfilters:	hyfilters.c complex.o utilities.o comm.o eardesign.o \
			hydesign.o earfilters.o
		$(CC) hyfilters.c -DMAIN hydesign.o \
			complex.o eardesign.o comm.o utilities.o earfilters.o \
			-lm -o hyfilters
		rm -f hyfilters.o

complex:	complex.c 
		$(CC) $(LDFLAGS) -DMAIN complex.c -o complex
		rm -f complex.o

fft:		fft.c alloc.o timer.o
		$(CC) $(LDFLAGS) -DMAIN fft.c alloc.o timer.o $(LIBS) -o fft
		rm -f fft.o

correlate:	correlate.c fcor.o animate.o fft.o timer.o picout.o animate.o \
			ftopix.o alloc.o fmag.o
		$(CC) correlate.c -DMAIN animate.o fft.o timer.o fcor.o \
			picout.o animate.o ftopix.o alloc.o fmag.o \
			$(LIBS) -lm -o correlate
		rm -f correlate.o

oneframe:	oneframe.c
		$(CC) -DMAIN $(CFLAGS) oneframe.c -o oneframe -DDEBUG

animate:	animate.c ftopix.o timer.o 
		$(CC) -DMAIN $(CFLAGS) animate.c ftopix.o timer.o \
			-o animate -DDEBUG $(LIBS)
		-rm -f animate.o

#
#	Miscellaneous code that does useful work.
#
catsound:	catsound.o file.o
		$(CC) $(LDFLAGS) catsound.o file.o -o catsound $(LIBS)

all:		ear fear hear catsound

test:		sosdesign sosfilters hydesign hyfilters complex correlate \
		animate fft oneframe

clean:
		-rm *.o core ear fear hear sosdesign sosfilters hydesign \
			hyfilters complex correlate animate fft oneframe

SourceFiles = READ* *.[chf] Make* *.man ear.make .timers

shar:
		rm -f ear.shar
		shar ear.shar $(SourceFiles)

distribute:
		rcp $(SourceFiles) ceres:Speech/Ear
		rcp $(SourceFiles) medusa:Speech/Ear
		rcp $(SourceFiles) goofy:Speech/Ear
		rcp $(SourceFiles) jumbo:Speech/Ear
		rcp $(SourceFiles) blorb:Speech/Ear
		rcp $(SourceFiles) nucleus:Speech/Ear
		rcp $(SourceFiles) dataio:Speech/Ear

# depend:
#	Generates list of #include dependencies, also including nested
#	#includes.
#
# The for-loop generates a list of "file.o: header.h" dependencies, using
# cpp to expand nested includes.  The egrep picks out those lines that
# reference an include file.  The sed does: extract only the header-file,
# insert the object file name, changes redundant occurances of
# "../something/.." to ".." and "something/../somethingelse" to
# "somethingelse" up to two times.  This whole mess is sorted (uniq'd),
# and handed to awk to compress them on to 78-char lines.  The uniq is
# needed due to cpp output redundantly listing the same header file.
#
depend:
	echo '# DO NOT DELETE THIS LINE -- make depend uses it' > makedep
	-for file in ${CFILES} ; \
	do \
		obj=`basename $$file .c`.o; \
		${CC} ${COPTS} -E $$file | \
		egrep '^# line[ 	]+[0-9]+[ 	]+".*\.h"' | \
		sed -e 's/^.*"\(.*\)".*$$/\1/' \
		    -e "s/^/$$obj: /" \
		    -e 's;\.\./[^./]*/\.\.;..;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;\.\/\.\.;..;'; \
	done | sort -u | \
	awk ' { if ($$1 != prev) { print rec; rec = $$0; prev = $$1; } \
		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
		       else rec = rec " " $$2 } } \
	      END { print rec } ' >> makedep
	echo '/^# DO NOT DELETE THIS LINE/,$$d' >eddep
	echo '$$r makedep' >>eddep
	echo 'w' >> eddep
	rm -f Makefile.bak
	cp Makefile Makefile.bak
	ed - Makefile < eddep
	rm eddep makedep

# DO NOT DELETE THIS LINE -- make depend uses it

alloc.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
alloc.o: /usr/include/stdc/stdio.h /usr/include/stdc/stdlib.h
animate.o: ./timer.h ./ub.h /usr/include/stdc/math.h /usr/include/stdc/stdio.h
comm.o: /usr/include/stdc/stdio.h
complex.o: ./complex.h /usr/include/stdc/math.h
correlate.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
correlate.o: /usr/include/stdc/stdio.h
ear.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/errno.h
ear.o: /usr/include/stdc/math.h /usr/include/stdc/stdio.h
ear.o: /usr/include/sys/cpu.h
eardesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
eardesign.o: /usr/include/stdc/stdio.h
earfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
earfilters.o: /usr/include/stdc/stdio.h
fft.o: ./timer.h /usr/include/stdc/math.h
file.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
file.o: /usr/include/stdc/stdio.h
hydesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
hydesign.o: /usr/include/stdc/stdio.h
hyfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
hyfilters.o: /usr/include/stdc/stdio.h
oneframe.o: /usr/include/stdc/ctype.h /usr/include/stdc/locstruct.h
oneframe.o: /usr/include/stdc/stdio.h
output.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
output.o: /usr/include/stdc/stdio.h
patterson.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
patterson.o: /usr/include/stdc/stdio.h
picout.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
picout.o: /usr/include/stdc/stdio.h /usr/include/sys/fcntl.h
script.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
script.o: /usr/include/stdc/stdio.h
shamma.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
shamma.o: /usr/include/stdc/stdio.h
sosdesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
sosdesign.o: /usr/include/stdc/stdio.h
sosfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
sosfilters.o: /usr/include/stdc/stdio.h
timer.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/ctype.h
timer.o: /usr/include/stdc/locstruct.h /usr/include/stdc/math.h
timer.o: /usr/include/stdc/stdio.h /usr/include/sys/types.h
utilities.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
utilities.o: /usr/include/stdc/stdio.h /usr/include/stdc/stdlib.h
!Funky!Stuff!
echo x - Makefile.noult
cat >Makefile.noult <<'!Funky!Stuff!'
# This makefile is for the Cray.  See the Makefile.unix file for other
# Unix machines.  Feel free to move Makefile.unix to Makefile if you don't
# have a Cray and are tired of typing make -f Makefile.unix.  Most of
# development is done on the Cray so I keep the names so it is most convenient
# for me.
#
# This makefile can either build the all C version (ear) or the C/Fortran
# version (fear).  The Fortran version has all the main loops coded in Fortran
# so they run as fast as possible.
#

SHELL = /bin/sh

CFILES = correlate.c \
	animate.c comm.c complex.c ear.c eardesign.c \
	earfilters.c fft.c file.c oneframe.c output.c picout.c script.c \
	timer.c utilities.c shamma.c patterson.c alloc.c \
	sosdesign.c sosfilters.c \
	hydesign.c hyfilters.c

FFILES = fcor.f fear.f fmag.f ftopix.f

FortranObjs = ftopix.o fcor.o fmag.o
GenObjs = $(FortranObjs) correlate.o shamma.o patterson.o \
	ear.o eardesign.o comm.o file.o complex.o fft.o \
	timer.o animate.o picout.o utilities.o output.o alloc.o  

FearObjs = $(GenObjs) sosdesign.o fear.o
SosObjs = $(GenObjs) sosdesign.o sosfilters.o earfilters.o
HydroObjs = $(GenObjs) hydesign.o hyfilters.o earfilters.o

CC=	scc
CFT=	cf77

#
#	CFLAGS - Here are some of the interesting options you might want to
#	use.
#		-DULTRA - Compile the ear model to include support for the 
#			Ultra Frame Buffer (at Apple).
#		-DPLOT3D - Compile the ear model to generate 3d plots using 
#			the Purdue Plot3d program.
#	Some machines also need some help with the floating point.  On Suns
#	you probably want to include -ffpa or -fweitek.  On Sequents you'll
#	either want -f1167 or -f387.
CFLAGS = -O $(COMMANDCCFLAGS)

#
#	Fortran Flags 
#	Use the following if you want debugging enabled on the Fortran stuff.
# FFLAGS= -g -a stack -c -m 2 -Zp 
#
FFLAGS= -a stack -c -m 2 -Zp  

LDFLAGS=

ULTRALIBS = ../ub/libub.a -lultra /usr/lib/ugraf.a
CRAYLIBS = -lf -lsci -lu -lio -lnet 
LIBS=	$(CRAYLIBS) -lm

#
#	The following is three different versions of the ear model.  
#	Fear is a C/Fortran implementation of the second order cascade model
#	Ear is a C implementation of the second order cascade model
#	Hear is a C implementation of the hydrodynamics model
#
fear:		$(FearObjs) Makefile 
		$(CC) $(LDFLAGS) $(CFLAGS) $(FearObjs) \
			$(LIBS) -o fear -lc

ear:		$(SosObjs) Makefile 
		$(CC) $(LDFLAGS) $(SosObjs) \
			$(LIBS) -o ear 

hear:		$(HydroObjs) Makefile 
		$(CC) $(LDFLAGS) $(HydroObjs) \
			$(LIBS) -o hear 

#
#	Most of the routines that do real work include stand alone test
#	code that can be used to verify the routines are working.
#	In all cases definining -DMAIN causes this test code to be included.
#
sosdesign:	sosdesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) sosdesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o sosdesign
		rm -f sosdesign.o

sosfilters:	sosfilters.c earfilters.o
		$(CC) $(LDFLAGS) sosfilters.c -DMAIN \
			earfilters.o -lm -o sosfilters
		rm -f sosfilters.o

hydesign:	hydesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) hydesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o hydesign
		rm -f hydesign.o

hyfilters:	hyfilters.c complex.o utilities.o comm.o eardesign.o \
			hydesign.o earfilters.o
		$(CC) hyfilters.c -DMAIN hydesign.o \
			complex.o eardesign.o comm.o utilities.o earfilters.o \
			-lm -o hyfilters
		rm -f hyfilters.o

complex:	complex.c 
		$(CC) $(LDFLAGS) -DMAIN complex.c -o complex
		rm -f complex.o

fft:		fft.c alloc.o timer.o
		$(CC) $(LDFLAGS) -DMAIN fft.c alloc.o timer.o $(LIBS) -o fft
		rm -f fft.o

correlate:	correlate.c fcor.o animate.o fft.o timer.o picout.o animate.o \
			ftopix.o alloc.o fmag.o
		$(CC) correlate.c -DMAIN animate.o fft.o timer.o fcor.o \
			picout.o animate.o ftopix.o alloc.o fmag.o \
			$(LIBS) -lm -o correlate
		rm -f correlate.o

oneframe:	oneframe.c
		$(CC) -DMAIN $(CFLAGS) oneframe.c -o oneframe -DDEBUG

animate:	animate.c ftopix.o timer.o 
		$(CC) -DMAIN $(CFLAGS) animate.c ftopix.o timer.o \
			-o animate -DDEBUG $(LIBS)
		-rm -f animate.o

ivq:		ivq.c file.o alloc.o
		$(CC) ivq.c file.o alloc.o -lm -o ivq

icos:		icos.c file.o alloc.o
		$(CC) icos.c file.o alloc.o -lm -o icos

#
#	Miscellaneous code that does useful work.
#
catsound:	catsound.o file.o
		$(CC) $(LDFLAGS) catsound.o file.o -o catsound $(LIBS)

all:		ear fear hear catsound

test:		sosdesign sosfilters hydesign hyfilters complex correlate \
		animate fft oneframe

clean:
		-rm *.o core ear fear hear sosdesign sosfilters hydesign \
			hyfilters complex correlate animate fft oneframe

SourceFiles = READ* *.[chf] Make* *.man ear.make .timers

shar:
		rm -f ear.shar
		shar ear.shar $(SourceFiles)

distribute:
		rcp $(SourceFiles) ceres:Speech/Ear
		rcp $(SourceFiles) medusa:Speech/Ear
		rcp $(SourceFiles) goofy:Speech/Ear
		rcp $(SourceFiles) jumbo:Speech/Ear
		rcp $(SourceFiles) blorb:Speech/Ear
		rcp $(SourceFiles) nucleus:Speech/Ear
		rcp $(SourceFiles) dataio:Speech/Ear

# depend:
#	Generates list of #include dependencies, also including nested
#	#includes.
#
# The for-loop generates a list of "file.o: header.h" dependencies, using
# cpp to expand nested includes.  The egrep picks out those lines that
# reference an include file.  The sed does: extract only the header-file,
# insert the object file name, changes redundant occurances of
# "../something/.." to ".." and "something/../somethingelse" to
# "somethingelse" up to two times.  This whole mess is sorted (uniq'd),
# and handed to awk to compress them on to 78-char lines.  The uniq is
# needed due to cpp output redundantly listing the same header file.
#
depend:
	echo '# DO NOT DELETE THIS LINE -- make depend uses it' > makedep
	-for file in ${CFILES} ; \
	do \
		obj=`basename $$file .c`.o; \
		${CC} ${COPTS} -E $$file | \
		egrep '^# line[ 	]+[0-9]+[ 	]+".*\.h"' | \
		sed -e 's/^.*"\(.*\)".*$$/\1/' \
		    -e "s/^/$$obj: /" \
		    -e 's;\.\./[^./]*/\.\.;..;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;\.\/\.\.;..;'; \
	done | sort -u | \
	awk ' { if ($$1 != prev) { print rec; rec = $$0; prev = $$1; } \
		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
		       else rec = rec " " $$2 } } \
	      END { print rec } ' >> makedep
	echo '/^# DO NOT DELETE THIS LINE/,$$d' >eddep
	echo '$$r makedep' >>eddep
	echo 'w' >> eddep
	rm -f Makefile.bak
	cp Makefile Makefile.bak
	ed - Makefile < eddep
	rm eddep makedep

# DO NOT DELETE THIS LINE -- make depend uses it

alloc.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
alloc.o: /usr/include/stdc/stdio.h /usr/include/stdc/stdlib.h
animate.o: ./timer.h ./ub.h /usr/include/stdc/math.h /usr/include/stdc/stdio.h
comm.o: /usr/include/stdc/stdio.h
complex.o: ./complex.h /usr/include/stdc/math.h
correlate.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
correlate.o: /usr/include/stdc/stdio.h
ear.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/errno.h
ear.o: /usr/include/stdc/math.h /usr/include/stdc/stdio.h
ear.o: /usr/include/sys/cpu.h
eardesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
eardesign.o: /usr/include/stdc/stdio.h
earfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
earfilters.o: /usr/include/stdc/stdio.h
fft.o: ./timer.h /usr/include/stdc/math.h
file.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
file.o: /usr/include/stdc/stdio.h
hydesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
hydesign.o: /usr/include/stdc/stdio.h
hyfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
hyfilters.o: /usr/include/stdc/stdio.h
oneframe.o: /usr/include/stdc/ctype.h /usr/include/stdc/locstruct.h
oneframe.o: /usr/include/stdc/stdio.h
output.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
output.o: /usr/include/stdc/stdio.h
patterson.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
patterson.o: /usr/include/stdc/stdio.h
picout.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
picout.o: /usr/include/stdc/stdio.h /usr/include/sys/fcntl.h
script.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
script.o: /usr/include/stdc/stdio.h
shamma.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
shamma.o: /usr/include/stdc/stdio.h
sosdesign.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
sosdesign.o: /usr/include/stdc/stdio.h
sosfilters.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
sosfilters.o: /usr/include/stdc/stdio.h
timer.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/ctype.h
timer.o: /usr/include/stdc/locstruct.h /usr/include/stdc/math.h
timer.o: /usr/include/stdc/stdio.h /usr/include/sys/types.h
utilities.o: ./complex.h ./ear.h ./filter.h ./timer.h /usr/include/stdc/math.h
utilities.o: /usr/include/stdc/stdio.h /usr/include/stdc/stdlib.h
!Funky!Stuff!
echo x - Makefile.unix
cat >Makefile.unix <<'!Funky!Stuff!'
# This makefile is for the Cray.  See the Makefile.unix file for other
# Unix machines.  Feel free to move Makefile.unix to Makefile if you don't
# have a Cray and are tired of typing make -f Makefile.unix.  Most of
# development is done on the Cray so I keep the names so it is most convenient
# for me.
#
# This makefile can either build the all C version (ear) or the C/Fortran
# version (fear).  The Fortran version has all the main loops coded in Fortran
# so they run as fast as possible.
#

SHELL = /bin/sh

CFILES = correlate.c \
	animate.c comm.c complex.c ear.c eardesign.c \
	earfilters.c fft.c file.c oneframe.c output.c picout.c script.c \
	timer.c utilities.c shamma.c patterson.c alloc.c \
	sosdesign.c sosfilters.c \
	hydesign.c hyfilters.c

FFILES = fcor.f fear.f fmag.f ftopix.f

FortranObjs =
GenObjs = $(FortranObjs) correlate.o shamma.o patterson.o \
	ear.o eardesign.o comm.o file.o complex.o fft.o \
	timer.o animate.o picout.o utilities.o output.o alloc.o  

FearObjs = $(GenObjs) sosdesign.o fear.o
SosObjs = $(GenObjs) sosdesign.o sosfilters.o earfilters.o
HydroObjs = $(GenObjs) hydesign.o hyfilters.o earfilters.o

CC=	cc
CFT=	cf77

#
#	CFLAGS - Here are some of the interesting options you might want to
#	use.
#		-DULTRA - Compile the ear model to include support for the 
#			Ultra Frame Buffer (at Apple).
#		-DPLOT3D - Compile the ear model to generate 3d plots using 
#			the Purdue Plot3d program.
#	Some machines also need some help with the floating point.  On Suns
#	you probably want to include -ffpa or -fweitek.  On Sequents you'll
#	either want -f1167 or -f387.
CFLAGS = -O $(COMMANDCCFLAGS)

#
#	Fortran Flags 
#	Use the following if you want debugging enabled on the Fortran stuff.
# FFLAGS= -g -a stack -c -m 2 -Zp 
#
FFLAGS= -a stack -c -m 2 -Zp  

LDFLAGS=

ULTRALIBS =
CRAYLIBS =
LIBS=	$(ULTRALIBS) $(CRAYLIBS) -lm

#
#	The following is three different versions of the ear model.  
#	Fear is a C/Fortran implementation of the second order cascade model
#	Ear is a C implementation of the second order cascade model
#	Hear is a C implementation of the hydrodynamics model
#
ear:		$(SosObjs) Makefile 
		$(CC) $(LDFLAGS) $(SosObjs) \
			$(LIBS) -o ear 

hear:		$(HydroObjs) Makefile 
		$(CC) $(LDFLAGS) $(HydroObjs) \
			$(LIBS) -o hear 

# fear:		$(FearObjs) Makefile 
# 		$(CC) $(LDFLAGS) $(CFLAGS) $(FearObjs) \
# 			$(LIBS) -o fear -lc

#
#	Most of the routines that do real work include stand alone test
#	code that can be used to verify the routines are working.
#	In all cases definining -DMAIN causes this test code to be included.
#
sosdesign:	sosdesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) sosdesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o sosdesign
		rm -f sosdesign.o

sosfilters:	sosfilters.c earfilters.o
		$(CC) $(LDFLAGS) sosfilters.c -DMAIN \
			earfilters.o -lm -o sosfilters
		rm -f sosfilters.o

hydesign:	hydesign.c complex.o utilities.o comm.o eardesign.o
		$(CC) $(LDFLAGS) hydesign.c -DMAIN complex.o \
			eardesign.o comm.o utilities.o \
			-lm -o hydesign
		rm -f hydesign.o

hyfilters:	hyfilters.c complex.o utilities.o comm.o eardesign.o \
			hydesign.o earfilters.o
		$(CC) hyfilters.c -DMAIN hydesign.o \
			complex.o eardesign.o comm.o utilities.o earfilters.o \
			-lm -o hyfilters
		rm -f hyfilters.o

complex:	complex.c 
		$(CC) $(LDFLAGS) -DMAIN complex.c -o complex
		rm -f complex.o

fft:		fft.c alloc.o timer.o
		$(CC) $(LDFLAGS) -DMAIN fft.c alloc.o timer.o $(LIBS) -o fft
		rm -f fft.o

correlate:	correlate.c animate.o fft.o timer.o picout.o animate.o alloc.o 
		$(CC) correlate.c -DMAIN animate.o fft.o timer.o  \
			picout.o animate.o alloc.o  \
			$(LIBS) -lm -o correlate
		rm -f correlate.o

oneframe:	oneframe.c
		$(CC) -DMAIN $(CFLAGS) oneframe.c -o oneframe -DDEBUG

animate:	animate.c ftopix.o timer.o 
		$(CC) -DMAIN $(CFLAGS) animate.c ftopix.o timer.o \
			-o animate -DDEBUG $(LIBS)
		-rm -f animate.o

ivq:		ivq.c file.o alloc.o
		$(CC) ivq.c file.o alloc.o -lm -o ivq

icos:		icos.c file.o alloc.o
		$(CC) icos.c file.o alloc.o -lm -o icos

#
#	Miscellaneous code that does useful work.
#
catsound:	catsound.o file.o
		$(CC) $(LDFLAGS) catsound.o file.o -o catsound $(LIBS)

all:		ear hear catsound

test:		sosdesign sosfilters hydesign hyfilters complex correlate \
		animate fft oneframe

clean:
		-rm *.o core ear fear hear sosdesign sosfilters hydesign \
			hyfilters complex correlate animate fft oneframe

SourceFiles = READ* *.[chf] Make* *.man ear.make .timers

shar:
		rm -f ear.shar
		shar ear.shar $(SourceFiles)

distribute:
		rcp $(SourceFiles) ceres:Speech/Ear
		rcp $(SourceFiles) medusa:Speech/Ear
		rcp $(SourceFiles) goofy:Speech/Ear
		rcp $(SourceFiles) jumbo:Speech/Ear
		rcp $(SourceFiles) blorb:Speech/Ear
		rcp $(SourceFiles) nucleus:Speech/Ear
		rcp $(SourceFiles) dataio:Speech/Ear

# depend:
#	Generates list of #include dependencies, also including nested
#	#includes.
#
# The for-loop generates a list of "file.o: header.h" dependencies, using
# cpp to expand nested includes.  The egrep picks out those lines that
# reference an include file.  The sed does: extract only the header-file,
# insert the object file name, changes redundant occurances of
# "../something/.." to ".." and "something/../somethingelse" to
# "somethingelse" up to two times.  This whole mess is sorted (uniq'd),
# and handed to awk to compress them on to 78-char lines.  The uniq is
# needed due to cpp output redundantly listing the same header file.
#
depend:
	echo '# DO NOT DELETE THIS LINE -- make depend uses it' > makedep
	-for file in ${CFILES} ; \
	do \
		obj=`basename $$file .c`.o; \
		${CC} ${COPTS} -E $$file | \
		egrep '^# line[ 	]+[0-9]+[ 	]+".*\.h"' | \
		sed -e 's/^.*"\(.*\)".*$$/\1/' \
		    -e "s/^/$$obj: /" \
		    -e 's;\.\./[^./]*/\.\.;..;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;[^./][^./]*/\.\./\([^./]*\);\1;' \
		    -e 's;\.\/\.\.;..;'; \
	done | sort -u | \
	awk ' { if ($$1 != prev) { print rec; rec = $$0; prev = $$1; } \
		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
		       else rec = rec " " $$2 } } \
	      END { print rec } ' >> makedep
	echo '/^# DO NOT DELETE THIS LINE/,$$d' >eddep
	echo '$$r makedep' >>eddep
	echo 'w' >> eddep
	rm -f Makefile.bak
	cp Makefile.unix Makefile.bak
	ed - Makefile.unix < eddep
	rm eddep makedep

# DO NOT DELETE THIS LINE -- make depend uses it

!Funky!Stuff!
echo x - ear.man
cat >ear.man <<'!Funky!Stuff!'
.TH EAR 1 Apple
.SH NAME
ear - Simulate the ear's response to a sound
.SH SYNOPSIS
ear [options]
.SH DESCRIPTION
This program simulates the propagation of sound in the human cochlea 
(inner ear) and computes a picture of sound called a cochleagram.
This program can optionally compute a correlogram 
(autocorrelation of each channel) of the sound.
The theory and implementation of the cochlear model are described in 
\fILyon's Cochlear Model (The Mathematica Notebook)\fR 
and the correlogram is described in 
\fIA Duplex Theory of Pitch Perception.\fR
The correlogram is one possible model for how humans perceive pitch,
perform spatial localization, and form auditory images.
.PP
This program can compute two different kinds of cochleagrams and three
different kinds of correlograms.  The two types of cochleagrams are based
on a cascade of second order sections with a separate automatic gain control
(AGC) and a hydrodynamics model with an integrated AGC.
The cochlear model is determined at compile time.
The three types of correlograms are those first proposed by James
Licklider, Shihab Shamma and Roy Patterson.  The type of correlogram 
computed can be set by the user from the command line.  
See the references for more information about each of these models.
.PP
The input to this program is a file with sound samples in one of a number of
different formats.
The format of data in the input file is determined by the suffix of the file
name.  
The currently supported types (and their file suffixes) are listed below
roughly in order of popularity.
.TP
adc
MIT ADC format.  This format will be described shortly.
.TP
dac
Byte swapped version of ADC format.  Some machines put the bytes of a word
in different orders and there are a few ADC files that have been written 
incorrectly.  This file format deals with the incorrect versions.
.TP
m22
Macintosh MacRecorder Sound File.  This file is produced by MacRecorder and
the sampled sound is in the data fork.  The resource fork specifies the
sampling interval and other information and to pass this information to non 
Macintosh programs the sampling rate is included in the file suffix.  
The suffix \fIm22\fR specifies a 22khz sampling rate.
.TP
m11
Macintosh MacRecorder Sound File.  Like above but an 11khz sampling rate.
.TP
m7
Macintosh MacRecorder Sound File.  Like above but a 7 khz sampling rate.
.TP
aif
Apple's Audio Interchange Format.  Most new Macintosh applications will
support this format and it is described in a document available from the
Apple Programmers and Developers Association (APDA).
.TP
dy22
Dyaxis sound file, as produced by the IMS Dyaxis sound recording
and playback system.  The sampling rate is 22050 Hz; the file has a
512-byte header, 16-bit stereo interleaved samples with left channel
first.  Each sample has high byte first.
.TP
dy44
Dyaxis sound file.  As above but with a sampling rate of 44100 Hz.
.TP
sd
Entropic Signal Processing Systems (ESPS) Waves format.  Note this is 
a proprietary file format so this file format can only be read on machines
that are licensed for the Waves system.
.TP
irc
IRCAM file format.  This format is machine dependent.
.TP
macspeech
MacSpeech (a Macintosh Speech Processing Workstation from GW Instruments)
file format.  
.TP
snd
NeXT machine sound file.  Variable-length header, then 16-bit samples
(interleaved if stereo).  Sampling rate specified in the header.
.TP
wav
Waveform file.  The file contains a stream of 16 bit samples with the low
order byte first.  
Since there is no header information
the file is assumed to have a sampling rate of 16000 samples
per second.
.PP
The MIT ADC file format is a simple stream of eight bit bytes.  
All numbers are stored little-endian.
Sixteen bit quantities are stored with the low order byte first, 
while 32 bit numbers are stored in order from low byte to high byte.
The header of an ADC file has the following quantities:
.TP 20
Header Size
A 16-bit number representing the number of 16-bit words in the header.
.TP
Version Number
A 16-bit number representing the version number of the header information.
This description is for ADC file format version 1.
.TP
Channels
A 16-bit quantity representing the number of channels in the input file.
This program ignores this information and will only work properly for single
channel input.
.TP
Sample Time
A 16 bit quantity representing the number of 250ns clocks 
between audio samples.
The sample rate is given by dividing 4,000,000 by this number.  
The 4MHz rate represents the clock rate of the 
Digital Sound Corporation
digital audio converters.
.TP
Length
A 32 bit quantity (low order bytes first) that indicates how many samples
are in the file.
.PP
Following the header there are zero or more filler words 
(depending on the header size).
The audio data follows the header.  
Each sample is a 16-bit signed two's complement integer.
This program assumes the data only has 12 bits of precision and that
the upper four bits of each 16 bit word are zero.
.PP
There are two types of output from this program, a cochleagram and 
a correlogram.
The cochleagram is a picture that represents the firing rate of the inner
hair cells in the cochlea.  
The data is a function of time and cochlear channel.
The correlogram is our name for the output of a model based on the James
Licklider's Duplex theory of pitch perception.  
The correlogram shows the autocorrelation of each cochlear channel and is
good at detecting periodicities such as pitch in the input signal.
The correlogram is a function of autocorrelation time lag, cochlear channel
and time.
The \fIof\fR and \fIcf\fR option direct the ear program to write a 
cochleagram and/or a correlogram into the files specified.
The format of these files is described below in the Output Format section.
.PP
There are two kinds of options to this program.  
They are parameters that have a string or number value and those
that are either on or off.
In the descriptions that follow we have listed the default value for the 
parameter in parenthesis.
.PP
Parameters that take a value are changed by listing 
the name of the parameter
followed by an "=" and then the new value.
Depending on the parameter, the value will either be a file name
or a number.
For example the input file is set with an argument like "if=test.adc"
(no spaces.)
.PP
Options that are either on or off are changed by listing the single letter 
with either a plus (to turn the option on) or minus before the letter.  
Multiple options can be turned
on or off at the same time by listing multiple letters 
following a single plus or minus sign
(to turn the option off.)
For example the string "+pdi" turns on the print, debug and impulse options.
.PP
The following I/O options are available.
.TP 20
if (data.adc)
Input File - Input data is read from this file.  
The format of this data must be specified by the file suffix (everything after
the last period in the file name).  The available formats are described above.
.TP 
gain (1.0)
Input Gain - This parameter is used to adjust the level of all input files.
.TP 
maxsamples (infinite)
Maximum number of samples to read from input file - This is used to limit
the number of samples of a signal that need to be computed.
.TP
of (cochlea.pic)
Output File - The firing rate at each portion of the cochlea is 
written to this file.
For each output time the file will have the firing rate for 
each of the channels of the
cochlear model.  
The channels are arranged from base to apex (or high to low frequency) as
they are in the ear.
The size of the output file is dependent on the parameters 
of the ear model and are
displayed when the program finishes execution.  
.TP
cf (None)
Correlation File - The autocorrelation of each channel 
of the cochlear output is placed in a sequence of files with names
beginning with the value of this parameter.  
The correlogram output will be placed into a sequence of files that
have names starting with the value of this parameter.
A unique file name for each sample of the correlogram is generated by
appending the sound sample index to the string.
Finally the image size (width by height) is appended to the name.
The full name looks like this
.br
	{user supplied}{sample number}(width x height)
.br
Again the size of the file is
dependent on the parameters of the ear model and is printed out after
the program runs.  
For the correlogram to be most useful the decimation factor
.I (df)
should be set to either 0 or 1.
.PP
The following parameters of the ear model can be set from the command line.
See 
.I 
Lyon's Cochlear Model
for more detailed information about
what these parameters mean.
.TP 20
earq (8.0)
This is the quality factor of each of the poles in the ear cascade.
.TP 
stepfactor (.25)
Channels in the ear model are separated by this factor of the bandwidth
of each ear stage.
.TP
breakf (1000)
The bandwidth of stages above this frequency is approximately equal to 
the frequency of the stage divided by the 
.I earq
(see above).  
Below this frequency the bandwidth approaches a constant given by the
value of 
.I breakf
divided by 
.I earq
.TP
sharpness (5)
This parameter described how much sharper the zeros in each stage of the
cascade are than the poles.
.TP
offset (1.5)
Zeros in the cascade-only filter bank are offset from the poles by this
fraction of the filter spacing.
.TP
preemph (300)
An initial preemphasis stage is used to roughly model 
the outer and middle ears.
The corner frequency of this high pass filter is given by this parameter.
.TP
tau1 (.640), tau2 (.16), tau3 (.04), tau4 (.01)
These are the time constants (in seconds) of the four stages of Automatic
Gain Control (AGC)
.TP
target1 (.0032), target2 (.0016), target3 (.0008), target4 (.0004)
These are the target values for the four stages of AGC.
The AGC can not provide a gain greater than one so each successive value 
should be less than the previous values.
.PP
The following parameters are used to control the flow of data
from the cochlear model to the correlogram code.  
The decimation factor controls how often data is sent to the correlogram
code and
.I taufactor 
controls a low pass filter that is used to prevent aliasing.
.TP 20
df (20)
Decimation Factor - The output of the ear model 
can be sampled at a lower rate than the incoming sound by
smoothing and decimating.  
One sample of the cochlea output will be placed into the output file for
.I df
input sample values.  
Note that setting the decimation factor to 1 means that every sample from
the cochlear model is output.  
Setting the decimation factor to zero means output every value but do NOT
perform the low pass filtering specified by the taufactor parameter.
.TP
taufactor (3)
The output of the cochlear model is often decimated.  This parameter 
specifies the frequency of the low pass filter used to prevent aliasing.
Each channel of the cochlear output is passed through two first order 
filters with a cutoff frequency given by taufactor times the output
sampling frequency.  
Note that this filtering is done on the output of each cochlear channel
before the data is passed to the autocorrelation routines.
If the df parameter is zero than no filtering is done.
.PP
A couple of parameters are available to describe the correlogram 
(autocorrelation of the cochlea output) code.  
The correlogram is actually implemented in this program by using FFT's.
A fixed number of samples (given by twice the 
.I clag 
parameter) are placed into
a buffer, the buffer is FFT'ed, squared and then inverse FFT'ed to get
the autocorrelation of the sequence.
The parameters are described below.
.TP 20
cor (lick)
Correlogram Type - This parameter may be set to one of the three strings
"lick", "shamma", or "patterson" to determine the type of correlogram to 
compute.  See the references for information about these different models.
.TP
clag (256)
This is the number of lags desired in the correlogram.  
This parameter must be a power of two.
.TP
cstep (128)
This is the number of samples between correlograms.  
For best results this parameter should be no more than half of the
.I clag
parameter.
.TP
cpus (4)
This parameter sets the number of CPUs that are used on machines that support
parallel processing.  It is forced to one when debugging is enabled.
.TP
normalize (.75)
Each (horizontal) line of the correlogram is normalized by the zero lag 
value raised to this power.  A value of one means that correlation data
is normalized so that the zero lag value is 1.
Doing this removes any information in the correlogram about relative
intensity of the different channels and hides the formants.  
Values less than one are used to leave some relative intensity 
information in the different channels.
.PP
A number of binary flags are available to control the execution of the program.
These flags are turned on and off by prepending the character with either a
plus (+) or minus (-) sign.
.TP 20
a (on)
Turn on the four stages of Automatic Gain Control (AGC).
.TP 
c (on)
Arrange the filters in a cascade.
When this option is on the input signal is applied to all filters in parallel.
This is useful for testing the response of each filter.
.TP 
d (off)
Turn on some debugging output.
.TP
i (off)
Use an impulse as input to this program.
This option overrides the 
.I if
(input file) parameter.
.TP
l (off)
Stretch the correlogram and display on a log time delay scale.  This
means that all frequency motion is now seen as a translation instead of
a stretching.
.TP
m (on)
Find the difference of adjacent channels.
This makes the output of the cochlea look sharper.
.TP
p (on)
Print the parameters of the program.
.TP
t (off)
Attempt to transform the Shamma correlogram into the normal
frequency vs. time delay picture.
.TP
u (off)
Display the correlogram output on the UltraBuffer at Apple.
This is a frame buffer with an update rate of 100 megabytes/second and
is used to provide near real time display of the correlogram output.
To get the best performance the decimation factor
.I (df)
is set to one.
.TP
v (off)
Compute and display the correlogram at NTSC video frame rates (29.85 Hz).
.SH EXAMPLES
.ta 1i
.PP
The following command will show the response of the cochlea to an impulse.
.br
	ear +i
.LP
The output will be a file called \fIcochlea.pic\fR with 86
samples per time step.
The decimation factor can be changed to one so that the response at each
point in the cochlea is output at each sample time using:
.br
	ear df=1 +i
.br
The following command is used to test the output of the correlogram model.
This will compute the cochleagram for an impulse input and pass every sample
(because of df=1) to the correlogram code.  
.br
	ear df=1 +i cf=tmp/f
.br
The resulting correlogram files will be placed into the subdirectory \fItmp\fR.
Within this directory a file will be written for each 128 (\fIcstep\fR)
samples of the input.  
The \fIcf=\fR parameter specifies the initial part of the name for
each correlogram file.
To this prefix will be appended the sample number for this image of the
correlogram and a string to indicate the width and height of the image.
.PP
The first file of the correlogram output will be named \fItmp/f00001(256x84)\fR.
This file contains the first correlogram 
and the string \fI(256x84)\fR indicates the width 
(128 autocorrelation time lags) and height (84 cochlear channels)
of the image in a format that is useful for NCSA ImageTool on the Macintosh.
Succeedings files will be named with the sample time and will be separated
by intervals of \fIcstep\fR samples 
(for example \fItmp/f00002(256x84)\fR and \fItmp/f00003(256x84)\fR).
.SH OUTPUT FORMATS
The distributed version of this program supports two kinds of output formats.
The simplest format has no header and just consists of a string of numbers in
the file.   It is called the raw format.
The other format is known as the Oregon Graduate Institute/CMU Syncreps format.
This is a specialized format but it does show how to modify the code to
support other file formats.  These options are set as compiler options and
are described shortly.
.PP
Files in the raw format contain just a list of numbers.  There is no
header on the files.  The numbers in this format can be written as either
binary floating point numbers, eight bit unsigned bytes or readable ASCII
text.  The desired output format is set using the C compiler preprocessor.
This is described at the end of this section.
.PP
Cochleagrams are a function of cochlear channel and time.  
For each output time (controlled by the \fIdf\fR parameter) 
a number is written out for each cochlear channel that represents
the inner hair cell firing rate.  
For each output time the cochlear channels are written from base to apex
(high to low frequency).  See the paper \fILyon's Cochlear Model\fR for
the definition of the center frequency of each channel.  
Succeeding times are appended to the cochleagram file.
.PP
Correlograms are a function of autocorrelation time lag, cochlear channel
and sample time.
A correlogram is written as a number of output files with the data from
each output time written to a separate file.  
The names of the output files is described above in the description of the 
\fIcf\fR parameter.
Within each correlogram file the data is written as a 
string of autocorrelations.
Starting at the base of the cochlea (high frequency) 
a string of \fIclag\fR numbers is written that represent the autocorrelation.
The first number represnts the zero lag case and succeeding numbers represent
lags separated by the sample time.  The channels of the correlogram are
written in order from base of the cochlea 
(high frequency) to apex (low frequency.)
.PP
Most options to this program are controlled from the command line.  
One option that is set at compile time is the format of the output file.
Output files (cochleagrams and correlograms) can be output in either 
raw format or in the OGC/CMU Syncreps file format.  
In the raw file format the data can be written out as raw binary floating 
point data, ASCII text or as 8 bit unsigned bits.
These options are defined in the include file ear.h.
.SH SEE ALSO
.PP
We have implementations of two versions of Richard Lyon's cochlear models.  
The first is a relatively simple model that combines a cascade of 
second order digital filters (to model 
propagation along the basilar membrane) with a stage of detectors and then four 
automatic gain control stages to model auditory adaptation.
.PP
The theory behind the second order cascade model can be found in:
.IP
Richard F. Lyon,  "A computational model of filtering, detection and
compression in the cochlea," in 
\fIProceedings of the IEEE International Conference Acoustics, 
Speech and Signal Processing, \fR
Paris, France, May 1982.
.PP
Information on the implementation of the second order cascade model 
can be found in the following publication:
.IP
Malcolm Slaney,  "Lyon's Cochlear Model," Apple Technical Report #13, 
November 1988 (This report is available from the Apple Corporate Library, 
Cupertino, CA 95014).
.PP
The second cochlear model is based on a hydrodynamics analysis of 
the cochlea and is explained in:
.IP
Richard F. Lyon and Carver Mead, "Cochlear Hydrodynamics Demystified," 
CalTech Computer Science Technical Report Caltech-CS-TR-88-4, 1989.
.IP
Richard F. Lyon and Carver Mead, "An Analog Electronic Cochlea," IEEE Trans. 
ASSP., July 1988.
.PP
Note, the hydrodynamics model is relatively new and is still in the 
process of being refined.
.PP
The cochlear model provides input to one of three models of a higher 
process in the brain that we generically call the correlogram.  The 
correlogram produces a two dimensional movie that we believe is 
useful for explaining pitch perception, sound separation and grouping 
results.
.PP
The original correlogram was described by James Licklider and is 
described in:
.IP
J. C. R. Licklider, "A Duplex Theory of Pitch Perception," in 
\fIPsychological Acoustics, \fR
E. D. Schubert, ed., Dowden, Hutchingson and Ross,  Inc., 
Stroudsburg, PA, 1979.
.PP
We also support a approximation to the correlogram first proposed 
by Shihab Shamma and described in:
.IP
Shihab Shamma, Naiming Shen and Preetham Gopalaswamy, "Stereausis: Binaural 
processing without neural delays," 
\fI J. Acoustical Society of America, \fR
Volume 86 
(3), September 1989, pp. 989-1006.
.PP
Finally, Roy Patterson has proposed a correlogram model called the 
Triggered Temporal Integration scheme that is a refined version of 
his Pulse Ribbon Model.  The Temporal Integration scheme is 
described in:
.IP
Roy D. Patterson and John Holdsworth, "A functional model of neural activity 
patterns and auditory images," to appear in 
\fI Advances in Speech, Hearing and Language Processing Volume 3, \fR
edited by W. A. Ainsworth, JAI Press, London.

.SH DISCLAIMER
Even though Apple has reviewed this software, Apple makes no warranty
or representation, either express or implied, with respect to this
software, its quality, accuracy, merchantability, or fitness for a 
particular purpose.  As a result, this software is provided "as is,"
and you, its user, are assuming the entire risk as to its quality
and accuracy.
.PP
Copyright (c) 1988-1990 by Apple Computer, Inc.
!Funky!Stuff!
echo x - ear.make
cat >ear.make <<'!Funky!Stuff!'
#
#	MPW Ear Application make file.
#
#	Note this makefile creates a full fledged Macintosh Application for a Mac-II.
#	This will application will not work without a 68881 (even if it did it would
#	be too slow to make sense.)
#
#							Malcolm Slaney
#							Apple Speech and Hearing
#							malcolm@apple.com
#
#   File:       ear.make
#   Target:     ear
#   Sources:    animate.c
#               comm.c
#               complex.c
#		correlate.c
#               ear.c
#               eardesign.c
#               fft.c
#               earfilters.c
#               file.c
#               output.c
#               picout.c
#               timer.c
#               UNIX.c
#               utilities.c
#   Created:    Sun, Jul 16, 1989 11:42:54 AM

CFLAGS = -mc68881 -mc68020 -d BUILDAPP -m

animate.c.o  ear.make animate.c
	 C {CFLAGS} animate.c -s animate
comm.c.o  ear.make comm.c
	 C {CFLAGS} comm.c -s comm 
complex.c.o  ear.make complex.c
	 C {CFLAGS} complex.c -s complex 
correlate.c.o  ear.make correlate.c
	 C {CFLAGS} correlate.c -s correlate
ear.c.o  ear.make ear.c
	 C {CFLAGS} ear.c -s ear
eardesign.c.o  ear.make eardesign.c
	 C {CFLAGS} eardesign.c -s eardesign
fft.c.o  ear.make fft.c
	 C {CFLAGS} fft.c -s fft
earfilters.c.o  ear.make earfilters.c
	 C {CFLAGS} earfilters.c -s earfilters
file.c.o  ear.make file.c
	 C {CFLAGS} file.c -s file
output.c.o  ear.make output.c
	 C {CFLAGS} output.c -s output
picout.c.o  ear.make picout.c
	 C {CFLAGS} picout.c -s picout
timer.c.o  ear.make timer.c
	 C {CFLAGS} timer.c -s timer
UNIX.c.o  ear.make UNIX.c
	 C {CFLAGS} UNIX.c -s UNIX
utilities.c.o  ear.make utilities.c
	 C {CFLAGS} utilities.c -s utilities

SOURCES = animate.c comm.c complex.c ear.c eardesign.c fft.c earfilters.c file.c output.c picout.c timer.c UNIX.c utilities.c
OBJECTS = 
		animate.c.o 
		comm.c.o 
		complex.c.o 
		correlate.c.o 
		ear.c.o 
		eardesign.c.o 
		fft.c.o 
		earfilters.c.o 
		file.c.o 
		output.c.o 
		picout.c.o 
		timer.c.o 
		UNIX.c.o 
		utilities.c.o

ear  ear.make {OBJECTS}
	duplicate -y MacEar..rsrc ear
	Link -w -t APPL -c Mear 
		{OBJECTS} 
		"{CLibraries}"CLib881.o 
		"{CLibraries}"CRuntime.o 
		"{Libraries}"Interface.o 
		"{CLibraries}"StdCLib.o 
		"{CLibraries}"CSANELib881.o 
		"{CLibraries}"Math881.o 
		"{CLibraries}"CInterface.o 
		-o ear
!Funky!Stuff!
echo x - .timers
cat >.timers <<'!Funky!Stuff!'
0	EarCorrelation
1	First Correlation FFT
2	Complex Magnitude
3	Second Correlation FFT
4	Storing Lags
5	CFFT2
6	FILTERG
7	UpdateDisplay
8	CrayCorrelate Scaling
9	Inner Correlate Loop
10	EarStep
11	First Hartley FFT
12	Hartley Magnitude
13	Second Hartley FFT
14	Cray Fortran FFT 
15	Cray Fortran AMAX 
17	Annotate Display
!Funky!Stuff!
